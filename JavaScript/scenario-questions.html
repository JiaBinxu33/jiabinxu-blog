<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常见场景题 | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.f81cf313.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.bb87b8ff.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.180c3171.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/33.d10d4810.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.3c2a6c83.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.3c49b8de.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.91b5c8e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.ef4b17e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.23f5619b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.4bb3669d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.664e814e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.21ad7801.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.d4db7480.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.31141967.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.97e9a047.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.f04bcbc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.f5223a9d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.2e981bab.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.d58d5448.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.fb28f85b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.f89661dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.a2c20bce.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.edabae48.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.8f37da54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.86e08cd4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.3ff6f6b3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.42a528d4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.46dbe14a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.0b72d4b8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.7d892d86.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.164a4f16.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.5bc0d409.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.82b75b59.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.e959a5f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.cc983ac3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.ed08971b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.9cbc22ee.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.f9457251.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.63e6d8ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.51ebfdbe.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.2e948603.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1907287a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.2aca8e9e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.53572a11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.6c8d55a3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.7c01df11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.1df3a578.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.bf31f66a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.f2feff3d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.d36efdc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.824240b9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.6e5633db.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.0bc9c8bd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.b03cfd91.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.3a221345.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.23192d8d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.e15e8a6b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.d4fc17a1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.bdb98294.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.5b17ac84.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/73.3030d7e2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/74.3329104a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.c9879746.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>常见场景题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#echarts-的-0-秒无感刷新" class="sidebar-link">ECharts 的“0 秒无感刷新”</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#sse-大屏实时化方案" class="sidebar-link">SSE 大屏实时化方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#工作机制" class="sidebar-link">工作机制：</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#为什么-sse-特别适合-大屏" class="sidebar-link">为什么 SSE 特别适合“大屏”？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#注意" class="sidebar-link">注意</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#ai-实训平台-sse-server-sent-events-的实现与管理" class="sidebar-link">ai 实训平台-SSE (Server-Sent Events) 的实现与管理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#ai-实训平台的-token-处理-经典-spa-模式" class="sidebar-link">ai 实训平台的 token 处理(经典 SPA 模式)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#如何知道用户有没有权限" class="sidebar-link">如何知道用户有没有权限</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#next-js-的做法-server-centric-模式" class="sidebar-link">Next.js 的做法(Server-Centric 模式)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#如何将-next-js-的做法-融合到您的项目" class="sidebar-link">如何将 &quot;Next.js 的做法&quot; 融合到您的项目</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#拦截器" class="sidebar-link">拦截器</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/scenario-questions.html#结合-ai-实训平台谈谈路由拦截-nextjs-模式" class="sidebar-link">结合 ai 实训平台谈谈路由拦截（nextjs 模式）</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="常见场景题"><a href="#常见场景题" class="header-anchor">#</a> 常见场景题</h1> <h2 id="echarts-的-0-秒无感刷新"><a href="#echarts-的-0-秒无感刷新" class="header-anchor">#</a> ECharts 的“0 秒无感刷新”</h2> <p>要实现 ECharts 的“0 秒无感刷新”只需在 useEffect 中启动一个定时器（setInterval），用它定期轮询 API 获取最新数据，然后直接调用 ECharts 实例的 setOption 方法，不带第二个参数（或者设为 false）。ECharts 就会自动“合并”新旧数据并平滑地更新图表，而不会产生闪烁。
如果数据量很大，这种方法就不适用了</p> <h2 id="sse-大屏实时化方案"><a href="#sse-大屏实时化方案" class="header-anchor">#</a> SSE 大屏实时化方案</h2> <ul><li><strong>它是什么：</strong> SSE 是一种<strong>单向</strong>的通信协议，允许服务器<strong>主动地</strong>将数据“推送”到客户端（浏览器）。</li> <li><strong>它与 Polling (轮询) 的区别：</strong> <ul><li><strong>轮询 (Pull)：</strong> 客户端每 5 秒问一次“有新数据吗？”，99% 的时间服务器都在回答“没有”。</li> <li><strong>SSE (Push)：</strong> 客户端建立一个“长连接”，告诉服务器：“有新数据了再叫我”。服务器只在<strong>有数据时</strong>才推送，<strong>没有</strong>任何浪费的请求。</li></ul></li> <li><strong>它与 WebSockets 的区别：</strong> <ul><li><strong>WebSockets：</strong> <strong>双向</strong>通信。客户端可以“推”，服务器也可以“推”。这对于“聊天室”是必须的。</li> <li><strong>SSE：</strong> <strong>单向</strong>通信（服务器 -&gt; 客户端）。这对于“大屏”（只负责<em>展示</em>数据）来说，功能不多不少，<strong>刚刚好</strong>，而且开销更小。</li></ul></li></ul> <hr> <h3 id="工作机制"><a href="#工作机制" class="header-anchor">#</a> 工作机制：</h3> <p>要实现 SSE，客户端和服务器必须“串通”，它分为两部分：</p> <h4 id="a-客户端-大屏-订阅者"><a href="#a-客户端-大屏-订阅者" class="header-anchor">#</a> A. 客户端 (大屏) - “订阅者”</h4> <p>客户端的工作<strong>极其简单</strong>，这是 SSE 最大的优势之一。</p> <ol><li><strong>关键 API：EventSource</strong> <ul><li>我们在 <code>useEffect</code> (的 <code>mount</code> 阶段) 中，创建<strong>一个</strong> <code>EventSource</code> 实例，指向一个特定的后端 API（比如 <code>/api/dashboard-stream</code>）。</li></ul></li> <li><strong>监听消息：.onmessage</strong> <ul><li>我们为这个 <code>EventSource</code> 实例绑定一个 <code>.onmessage</code> 事件监听器。</li></ul></li> <li><strong>接收数据</strong> <ul><li><strong>当且仅当</strong>服务器推送了新数据，这个 <code>.onmessage</code> 事件<strong>才会触发</strong>。</li> <li>我们从 <code>event.data</code> 属性中拿到“数据”（通常是 JSON 字符串），然后 <code>JSON.parse</code>。</li></ul></li> <li><strong>更新状态</strong> <ul><li>我们用这个新数据去 <code>setState</code>（或更新 React 19 的 <code>useOptimistic</code> 等）。</li></ul></li> <li><strong>ECharts 更新</strong> <ul><li>ECharts 组件（或任何其他图表库）监听到 state 变化，自动调用 <code>setOption</code> 更新视图。</li> <li><strong>(重点)</strong> ECharts 的“0 秒无感刷新”（<code>setOption</code> 合并）这个优点<strong>被保留</strong>了。</li></ul></li></ol> <h4 id="b-服务端-推送者"><a href="#b-服务端-推送者" class="header-anchor">#</a> B. 服务端 - “推送者”</h4> <p>服务端的工作是 SSE 的<strong>核心</strong>。</p> <ol><li><strong>特定的 API 终结点 (Endpoint)</strong> <ul><li>那个 <code>/api/dashboard-stream</code> 接口<strong>不能</strong>是一个普通的 API。</li> <li>它<strong>不能</strong>在收到请求后立刻 <code>res.json()</code> 并关闭连接。</li></ul></li> <li><strong>特殊的“响应头” (Headers)</strong> <ul><li>服务器<strong>必须</strong>发送一个特殊的 <code>Content-Type</code> 响应头： <code>Content-Type: text/event-stream</code></li> <li>这就是告诉浏览器：“注意，这不是一次性数据，这是一个‘流’，请保持连接！”</li> <li>服务器还必须发送 <code>Cache-Control: no-cache</code> 和 <code>Connection: keep-alive</code>。</li></ul></li> <li><strong>“保持连接” (Long-lived Connection)</strong> <ul><li>服务器**必须“挂起”**这个 HTTP 连接，<strong>不能</strong>关闭它。</li></ul></li> <li><strong>“推送”数据 (The Push)</strong> <ul><li>当后端（比如数据库、Kafka、Redis 消息队列）<strong>真的</strong>有了新数据...</li> <li>服务器<strong>立即</strong>通过这个“挂起”的连接，<code>res.write()</code> 一个<strong>特定格式</strong>的纯文本字符串。</li> <li><strong>SSE 格式：</strong> <code>data: {&quot;chart_id&quot;: &quot;A&quot;, &quot;value&quot;: 123}\n\n</code></li> <li>(注意：必须是 <code>data:</code> 开头，必须是 <code>\n\n</code> 结尾)。</li></ul></li></ol> <hr> <h3 id="为什么-sse-特别适合-大屏"><a href="#为什么-sse-特别适合-大屏" class="header-anchor">#</a> 为什么 SSE 特别适合“大屏”？</h3> <ol><li><strong>真实时，零浪费</strong> <ul><li>解决了 <code>setInterval</code> 的<strong>所有缺陷</strong>。没有浪费的请求，服务器只在需要时才工作，客户端 CPU 占用极低。</li></ul></li> <li><strong>自动重连</strong> <ul><li>这是 SSE <strong>秒杀</strong> WebSocket 的地方（在“大屏”场景下）。</li> <li>“大屏”通常会 24/7 运行。如果网络<strong>闪断</strong>了一下...</li> <li><strong>WebSocket：</strong> 连接会断开，你<strong>必须</strong>自己写复杂的“心跳检测”和“重连”逻辑。</li> <li><strong>SSE (EventSource)：</strong> 浏览器<strong>内置</strong>了“自动重连”机制。如果连接断开，<code>EventSource</code> 会<strong>自动</strong>（在几秒后）尝试重新连接，直到成功。</li></ul></li></ol> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <ul><li><strong>数据格式：</strong> SSE 只能传输<strong>纯文本</strong>。这意味着所有复杂对象（JSON）都<strong>必须</strong>在服务器端 <code>JSON.stringify</code>，并在客户端 <code>JSON.parse</code>。</li> <li><strong>连接数限制：</strong> 浏览器对 <code>EventSource</code> 的<strong>并发连接数</strong>有限制（比如一个域名下最多 6 个）。这对于“大屏”通常不是问题，因为一个“大屏”页面通常只需要一个“主数据流”。</li> <li><strong>代理/防火墙：</strong> <code>SSE</code> 是一种“长连接”。中间的 Nginx 代理或防火墙<strong>必须</strong>被正确配置，允许 <code>keep-alive</code>，并且<strong>不能</strong>“缓冲 (buffer)” <code>text/event-stream</code> 的响应，否则客户端会收不到数据。</li></ul> <h2 id="ai-实训平台-sse-server-sent-events-的实现与管理"><a href="#ai-实训平台-sse-server-sent-events-的实现与管理" class="header-anchor">#</a> ai 实训平台-SSE (Server-Sent Events) 的实现与管理</h2> <ul><li><p><strong>概述</strong>：
与 ai 对话的时候，由于大模型需要时间来思考，如果要让大模型一下输出所有答案的话需要经历长时间的等待，用户体验不好，所以有了 sse 流式输出，就是将一个完整的 sse 事件割到多个数据块中，然后把所有解码后的字符串拼在一个大字符串里面，这个字符串可以称为缓冲区，起到缓冲的作用，检查这个结果中是否有分隔符，这个分隔符就是用来分割要展示的部分，如果你第一次要展示 a，第二次展示 b 那 a 和 b 之间就会有分隔符，如果有分隔符 <code>\n\n</code>。如果有分隔符就说明有一个完整事件，然后逐个渲染完整的事件字符串，把已经渲染的部分从缓冲区移出去，通过一个结束的标志 <code>data: [DONE]</code>决定整条回答是否结束</p> <p>在请求头中设置了 <code>Accept: 'text/event-stream'</code>，返回的是一个响应流通过 <code>response.body.getReader()</code> 获取流的读取器（reader）。然后在一个循环中不断调用 <code>reader.read()</code> 来读取数据块。</p></li> <li><p><strong>实现</strong>:
我在 <code>useChatAPI</code> 这个自定义 Hook 中封装了 SSE 的处理逻辑。通过 <code>fetch</code> API 发起流式请求（利用了 <code>apiClient.js</code> 中封装的 <code>postStream</code> 方法），然后使用 <code>response.body.getReader()</code> 和 <code>TextDecoder</code> 来逐步读取流数据。为了应对网络传输中数据块可能被分割的情况，我维护了一个缓冲区 (<code>buffer</code>)，累积接收到的数据，直到遇到 SSE 事件的分隔符 (<code>\n\n</code>) 才进行处理。解析时需要剥离 <code>data:</code> 前缀，处理 JSON 解析可能出现的异常，并特别识别流结束的标志 <code>[DONE]</code>。</p></li> <li><p><strong>状态更新</strong>:
在流式接收过程中，需要实时更新聊天界面的消息状态 (<code>setMessagesState</code>)，将接收到的文本片段累加到对应的机器人消息上，并展示加载（打字）动画。这里使用了 <code>useRef</code> (如 <code>currentBotMessageIdRef</code>) 来确保在异步回调中能正确地更新对应的消息气泡。</p></li></ul> <p><strong>错误处理</strong>: SSE 的错误处理比较复杂。不仅要处理请求发起时的 HTTP 错误，还要处理流传输过程中可能出现的错误（比如后端模型报错并通过流返回错误信息）。我增加了逻辑来检测流数据中的错误标识，并在 UI 上将对应的消息标记为错误状态，同时确保在流结束或出错时正确释放读取器 (<code>reader.releaseLock()</code>) 并清理状态。</p> <p><strong>SSE 错误处理，内置了自动重连。</strong></p> <ul><li><strong>发生的情况</strong>：
<ol><li>你正在接收 AI 的流式回答。</li> <li>你突然走进了电梯，网络断了。</li> <li><code>EventSource</code> 对象会监听到连接中断 (触发 <code>onerror</code> 事件)。</li> <li>此时，它<strong>会自动</strong>进入重连模式。</li> <li>它会每隔几秒钟（这个时间可以由服务器通过 <code>retry:</code> 字段指定，默认约 3 秒）<strong>自动尝试重新向原来的 URL 发起连接</strong>。</li> <li>当你走出电梯，网络恢复了，它下一次重连尝试就会成功，然后继续接收数据流。</li></ol></li> <li><strong>需要后端配合</strong>： 这种自动重连也需要后端设计配合。后端需要知道你是“断线重连”的，还是“发起新提问”的。 通常，浏览器重连时会发送一个特殊的 HTTP 头 <code>Last-Event-ID</code>（这个 ID 可以由服务器在上一条消息中用 <code>id: ...</code> 字段指定）。服务器看到这个 ID，就应该知道“哦，他刚才收到第 500 个字了”，然后从第 501 个字开始继续推流，而不是从头开始回答。</li></ul> <p><strong>一些细节</strong>：维护机器人消息的 id，需要用 useref 存储，因为获取消息的函数是异步的，异步代码中就存在一个闭包的问题，它里面可能会获取到旧值，为啥不用 useState，虽然可以用 setState 里面获取到上一次的值处理，但是这个 id 是不变的不需要频繁的更新他，所以这里最好用 useRef</p> <p>还有就是防止并发请求，也是用 useRef 维护一个值，初始为 false 表示没有请求正在进行，然后请求的开始的时候把这个值设置为 true，</p> <h2 id="ai-实训平台的-token-处理-经典-spa-模式"><a href="#ai-实训平台的-token-处理-经典-spa-模式" class="header-anchor">#</a> ai 实训平台的 token 处理(经典 SPA 模式)</h2> <ol><li><strong>登录与存储</strong>：
<ul><li>用户在登录页（<code>src/app/register/components/RegisterForm.jsx</code>）提交表单。</li> <li><code>handleFinish</code> 函数被调用，它使用 <code>apiClient.post</code> 请求 <code>/api/user/login</code> 接口。</li> <li>如果登录成功，后端<strong>在响应体（JSON 数据）中</strong>返回 <code>access_token</code> 和 <code>dify_token</code>。</li> <li>您的 <code>authStore.login</code> 方法被调用，它将这个 <code>access_token</code> 存储到 <strong>localStorage</strong> 中，并同时更新 MobX 的 state (<code>this.isLoggedIn = true</code>)。</li></ul></li> <li><strong>请求时携带 Token</strong>：
<ul><li>您的 <code>src/lib/apiClient.js</code> 文件中注册了一个<strong>请求拦截器</strong> (<code>addRequestInterceptor</code>)。</li> <li>这个拦截器会在<strong>每一次 API 请求发送前</strong>自动执行。</li> <li>它的任务是从 <code>localStorage.getItem(&quot;authToken&quot;)</code> 读取 Token。</li> <li>如果 Token 存在，它会将其添加到请求头（Headers）中：<code>Authorization: Bearer ${tokenFromStorage}</code>。</li></ul></li> <li><strong>应用加载时恢复登录</strong>：
<ul><li>当用户刷新页面时，<code>src/app/layout.jsx</code> 会加载 <code>AuthStore</code>。</li> <li><code>AuthStore</code> 的 <code>initializeAuth</code> 方法会运行，它会去 <code>localStorage</code> 检查 &quot;authToken&quot; 是否存在。</li> <li>如果存在，它会立刻尝试调用 <code>/api/user/get_user_info</code>。</li> <li>如果这个请求成功（因为 <code>apiClient</code> 自动携带了 Token），则确认登录有效，设置 <code>this.isLoggedIn = true</code> 并拉取用户信息。如果失败（比如 Token 过期了），则调用 <code>this.logout()</code>。</li></ul></li></ol> <hr> <h3 id="如何知道用户有没有权限"><a href="#如何知道用户有没有权限" class="header-anchor">#</a> 如何知道用户有没有权限</h3> <ol><li><strong>客户端的前置检查（UI 层面）</strong>：
<ul><li>这是主动防御。您的组件（如 <code>src/components/Navigation.jsx</code>）会观察 <code>authStore.isLoggedIn</code> 的状态。</li> <li>如果 <code>isLoggedIn</code> 为 <code>false</code>，导航按钮会直接被设置为 <code>disabled</code>。</li> <li><strong>优点</strong>：用户界面（UI）响应及时，用户甚至没有机会点击一个他无权访问的按钮。</li></ul></li> <li><strong>服务端的拒绝响应（API 层面）</strong>：
<ul><li>这是真正的权限关卡。如果用户未登录（<code>localStorage</code> 中没有 Token）或者 Token 已经过期，但他们仍然尝试调用一个需要权限的 API（比如直接访问某个页面触发了 <code>useEffect</code> 中的 API 请求）：</li> <li>您的 <code>apiClient</code> 会发送请求（此时可能没有 <code>Authorization</code> 头，或者头信息是过期的）。</li> <li>后端服务器会检查 <code>Authorization</code> 头。发现无效或缺失，会拒绝请求，并返回一个 <strong>HTTP 状态码，通常是 401 Unauthorized</strong>。</li> <li>您的 <code>apiClient.js</code> 中的 <code>request</code> 函数会检查 <code>if (!response.ok)</code>，发现响应状态不是 2xx。</li> <li>它会抛出一个 <code>HttpError</code>。</li> <li>在您的 <code>AuthStore.js</code> 中（比如 <code>initializeAuth</code> 或 <code>refreshUserInfo</code>），<code>try...catch</code> 块会捕获这个 <code>HttpError</code>。如果发现 <code>error.status === 401</code>，它就会调用 <code>this.logout()</code>，清空本地状态和 <code>localStorage</code>，强制用户回到未登录状态。</li></ul></li></ol> <hr> <h3 id="next-js-的做法-server-centric-模式"><a href="#next-js-的做法-server-centric-模式" class="header-anchor">#</a> Next.js 的做法(Server-Centric 模式)</h3> <p>Next.js（特别是 App Router）推崇一种更安全、更强大的<strong>以服务端为中心的认证模式</strong>。</p> <ul><li><strong>核心区别</strong>：不使用 <code>localStorage</code>，而是使用 <strong>httpOnly Cookie</strong>。</li> <li><strong>登录</strong>：用户提交登录表单。后端 API 收到请求并验证通过后，<strong>不</strong>在 JSON 响应体中返回 Token。相反，它在响应头中设置一个 <code>Set-Cookie</code>，例如： <code>Set-Cookie: authToken=...; HttpOnly; Secure; SameSite=Strict; Path=/</code></li> <li><strong>什么是 httpOnly？</strong>：这意味着这个 Cookie <strong>不能被任何客户端 JavaScript 访问</strong>（即 <code>document.cookie</code> 看不到它）。这能极大地防止 XSS 攻击者窃取 Token。</li> <li><strong>请求</strong>：浏览器在后续向<strong>同域名</strong>发送的<strong>所有请求</strong>中，都会<strong>自动</strong>携带这个 <code>httpOnly</code> Cookie。您的 <code>apiClient</code> 不再需要任何请求拦截器来手动添加 <code>Authorization</code> 头。</li> <li><strong>权限判断</strong>：
<ol><li><strong>在服务端组件（RSC）中</strong>：Next.js 的 Server Components 可以直接在服务端运行。它们可以读取请求中的 Cookie，判断用户是否登录，然后再决定是否渲染页面或获取数据。</li> <li><strong>在 Middleware 中</strong>：这是 Next.js 最强大的功能之一。您可以在 <code>src/middleware.js</code> 文件中编写一个函数。这个函数会在<strong>所有</strong>（或您指定的 <code>matcher</code> 匹配的）路由被访问<strong>之前</strong>在服务器上运行。
<ul><li>它可以检查请求中是否存在 <code>httpOnly</code> 的 <code>authToken</code> Cookie。</li> <li>如果 Cookie 不存在，它可以<strong>直接将用户重定向</strong>到登录页面，用户甚至永远不会看到受保护页面的内容。</li></ul></li></ol></li></ul> <hr> <h3 id="如何将-next-js-的做法-融合到您的项目"><a href="#如何将-next-js-的做法-融合到您的项目" class="header-anchor">#</a> 如何将 &quot;Next.js 的做法&quot; 融合到您的项目</h3> <ol><li><strong>后端 API 修改 (最重要)</strong> <ul><li>修改您的 <code>/api/user/login</code> 接口。当登录成功时，不再返回 <code>access_token</code>。</li> <li>改为在响应头中设置 <code>httpOnly</code> Cookie。</li> <li>创建一个 <code>/api/user/logout</code> 接口，该接口的唯一作用是返回一个清除 <code>authToken</code> Cookie 的响应头。</li></ul></li> <li><strong>src/lib/apiClient.js 修改</strong> <ul><li><strong>移除</strong> <code>addRequestInterceptor</code> 中从 <code>localStorage</code> 读取并设置 <code>Authorization</code> 头的整段逻辑。</li> <li>（如果您的 API 和 Next.js 应用不在同一个子域下）在 <code>fetch</code> 的 <code>options</code> 中添加 <code>credentials: 'include'</code>，以确保浏览器在跨域请求时也会发送 Cookie。</li></ul></li> <li><strong>src/stores/AuthStores.js 修改</strong> <ul><li><strong>login 方法</strong>：不再需要接收 <code>accessToken</code> 和 <code>difyToken</code>（如果 <code>difyToken</code> 也改用 Cookie）。它只需要在 API 调用成功后，设置 <code>isLoggedIn = true</code>，然后调用 <code>refreshUserInfo</code> (或 <code>initializeAuth</code>) 来获取用户信息。</li> <li><strong>logout 方法</strong>：在清空 MobX 状态之前，<strong>必须</strong>先 <code>await apiClient.post('/api/user/logout')</code> 来通知后端清除 <code>httpOnly</code> Cookie。同时移除 <code>localStorage.removeItem</code>。</li> <li><strong>initializeAuth 方法</strong>：这是变化最大的地方。
<ul><li><strong>移除</strong>所有 <code>localStorage.getItem</code> 的逻辑。</li> <li>它的唯一工作就是：<code>this.setLoading(true)</code>，然后直接尝试调用 <code>apiClient.get(&quot;/api/user/get_user_info&quot;)</code>。</li> <li><strong>如果成功</strong>：说明浏览器自动发送了有效的 <code>httpOnly</code> Cookie，后端验证通过。此时 <code>runInAction</code> 设置 <code>this.userInfo</code> 和 <code>this.isLoggedIn = true</code>。</li> <li><strong>如果失败 (catch 到 401)</strong>：说明没有 Cookie 或 Cookie 无效，调用 <code>this.logout(false)</code> (确保不再次调用 <code>localStorage.removeItem</code>)。</li></ul></li></ul></li> <li><strong>(推荐) 增加 src/middleware.js</strong> <ul><li>在您的 <code>src/</code> 目录下创建一个新文件 <code>middleware.js</code>。</li> <li>在里面，您可以定义哪些路由是受保护的（比如 <code>/modelWorkbench</code> 和 <code>/personalCenter</code>）。</li> <li><code>middleware</code> 会检查请求中是否有 <code>authToken</code> Cookie。如果没有，它会直接返回一个重定向响应，将用户踢到登录页面。</li></ul></li></ol> <p><strong>融合后的好处：</strong></p> <ul><li><strong>更安全</strong>：<code>httpOnly</code> Cookie 无法被 JS 窃取。</li> <li><strong>更优雅</strong>：<code>apiClient</code> 变得更干净，不再需要手动管理 Token 注入。</li> <li><strong>服务端保护</strong>：<code>middleware</code> 提供了真正的路由级保护，而不是像现在这样仅仅在客户端隐藏/禁用 UI 元素。</li></ul> <p>希望这个分析对您有帮助！您想先从哪一步开始讨论修改呢？例如，我们可以先看看如何修改 <code>AuthStore.js</code> 的 <code>initializeAuth</code> 方法。</p> <h3 id="拦截器"><a href="#拦截器" class="header-anchor">#</a> 拦截器</h3> <p><strong>拦截器注册表 (一个数组)</strong></p> <ul><li>在 <code>apiClient.js</code> 文件的顶部，定义了一个全局数组 <code>requestInterceptors = []</code>。</li> <li>文件还导出了一个函数 <code>export function addRequestInterceptor(fn)</code>，任何其他文件都可以调用这个函数，将一个自定义的函数（即一个“拦截器”）添加到 <code>requestInterceptors</code> 数组中。</li></ul> <p><strong>拦截器执行 (在核心请求函数中)</strong></p> <ul><li>在 <code>apiClient.js</code> 文件的核心 <code>request</code> 函数中，<strong>在真正发起 fetch 请求之前</strong>，它会使用一个 <code>for...of</code> 循环来遍历 <code>requestInterceptors</code> 数组。</li> <li>它会执行（<code>await</code>）数组中的每一个拦截器函数，并把当前的请求配置对象（<code>currentOptions</code>）传递给它。</li> <li>拦截器函数会修改这个 <code>currentOptions</code> 对象（比如添加请求头），然后再将其返回，传递给下一个拦截器或最终的 <code>fetch</code> 调用。</li></ul> <p><strong>您的 Token 拦截器 (具体实现)</strong></p> <ul><li>在 <code>apiClient.js</code> 文件的底部，它立即调用了 <code>addRequestInterceptor</code> 注册了一个默认的拦截器。这就是您关心的 Token 注入逻辑。</li> <li>这个拦截器的实现步骤是：
<ul><li>a. 从 <code>localStorage.getItem(&quot;authToken&quot;)</code> 读取 Token。</li> <li>b. 检查 Token 是否存在 (<code>if (tokenFromStorage)</code>)。</li> <li>c. 确保 <code>config.headers</code> 是一个可写的 <code>Headers</code> 对象。</li> <li>d. 检查是否<strong>尚未</strong>存在 <code>Authorization</code> 请求头 (<code>if (!headers.has(&quot;Authorization&quot;))</code>)。</li> <li>e. 如果不存在，它会检查 Token 是否已包含 &quot;Bearer &quot; 前缀，如果不包含，则手动添加，然后设置 <code>headers.set(&quot;Authorization&quot;, authorizationValue)</code>。</li> <li>f. 返回被修改后的 <code>config</code> 对象。</li></ul></li></ul> <h2 id="结合-ai-实训平台谈谈路由拦截-nextjs-模式"><a href="#结合-ai-实训平台谈谈路由拦截-nextjs-模式" class="header-anchor">#</a> 结合 ai 实训平台谈谈路由拦截（nextjs 模式）</h2> <ol><li><p><strong>您的项目中目前有没有路由拦截？</strong> <strong>答：</strong> 您的项目目前<strong>没有</strong>真正意义上的“路由拦截”（Route Interception）或“路由守卫”（Route Guard）。</p></li> <li><p><strong>那您的项目是如何防止未授权访问的？</strong> 您的项目目前依赖两层“保护”，这是一种非常典型的纯客户端 SPA（单页应用）的实现方式：</p> <ul><li><strong>第 1 层：UI 层的“导航守卫” (在 Navigation.jsx 中)</strong> <ul><li><strong>原理：</strong> 您的 <code>Navigation</code> 组件 会从 <code>authStore</code> 侦听 <code>isLoggedIn</code> 状态。如果用户未登录 (<code>!isLoggedIn</code>)，它会直接给“模型工作台”和“智能体工作台”等链接对应的 <code>GradientButton</code> 组件传递 <code>disabled={true}</code> 属性。</li> <li><strong>优点：</strong> 界面响应非常快，用户能立刻看到自己无权访问某些区域。</li> <li><strong>缺点：</strong> 这<strong>极其不安全</strong>。这只是“隐藏了门把手”，但门没有锁。如果用户知道 URL（例如，直接在浏览器地址栏输入 <code>/modelWorkbench/modelTrain</code>），他可以<strong>完全绕过</strong>这个 UI 守卫并直接访问页面。</li></ul></li> <li><strong>第 2 层：API 层的“数据守卫” (在 apiClient.js 和 AuthStores.js 中)</strong> <ul><li><strong>原理：</strong> 这是您的<strong>实际安全防线</strong>。当用户（如上所述）绕过 UI 守卫直接访问 <code>/modelWorkbench/modelTrain</code> 页面时：
<ol><li><code>modelTrain/page.jsx</code> 组件会加载。</li> <li>它的 <code>useEffect</code> 会调用 <code>getData()</code> 来获取数据。</li> <li><code>getData()</code> 使用 <code>apiClient</code> 发起请求。</li> <li>您的 <code>apiClient.js</code> 中的<strong>请求拦截器</strong> 会尝试从 <code>localStorage</code> 读取 &quot;authToken&quot;。</li> <li>由于用户未登录，<code>localStorage</code> 中没有 Token。</li> <li>后端 API 收到一个没有 <code>Authorization</code> 头的请求，并返回 <strong>401 Unauthorized</strong> 错误。</li> <li>您的 <code>AuthStore.js</code> 在 <code>initializeAuth</code> 或 <code>refreshUserInfo</code> 的 <code>catch</code> 块中捕获到这个 401 错误，并调用 <code>this.logout()</code>。</li> <li><code>logout()</code> 会清空状态，<code>isLoggedIn</code> 变为 <code>false</code>，<code>layout.jsx</code> 监听到变化，将顶部的 <code>PersonalCenter</code> 切换为“登录/注册”按钮，从而在<em>事实上</em>将用户“踢”出了登录状态。</li></ol></li> <li><strong>优点：</strong> 提供了真正的安全兜底，未授权的 API 请求绝对不会成功。</li> <li><strong>缺点：</strong> <strong>用户体验极差</strong>。用户会先加载一个（可能是空的或显示加载中的）受保护页面，然后数据请求失败，最后 UI 才响应并“跳”回到未登录状态。这就是所谓的“页面闪烁”。</li></ul></li></ul></li> <li><p><strong>Next.js 的推荐方法</strong>：中间件 (Middleware)</p> <p>Next.js 推荐使用<strong>中间件（Middleware）</strong> 来实现真正、安全的路由拦截。这是在服务器端执行的，远在客户端 JavaScript 加载之前。</p> <ul><li><p><strong>原理：</strong></p> <ol><li><p>您需要在您的 <code>src/</code> 目录下创建一个文件，命名为 <code>middleware.js</code> (或 <code>.ts</code>)。</p></li> <li><p>在这个文件中，您可以导出一个 <code>config</code> 对象，其中包含一个 <code>matcher</code> 数组，用来定义哪些路由需要被这个中间件“拦截”。</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">matcher</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">'/modelWorkbench/:path*'</span><span class="token punctuation">,</span> <span class="token comment">// 拦截所有模型工作台的子路由</span>
    <span class="token string">'/personalCenter'</span><span class="token punctuation">,</span>       <span class="token comment">// 拦截个人中心</span>
    <span class="token comment">// ... 其他需要登录的路由</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>然后，您导出一个 <code>middleware(request)</code> 函数。这个函数会在<strong>服务器上</strong>（在边缘网络）运行，<strong>在您的页面（Page）或布局（Layout）开始渲染之前</strong>。</p></li> <li><p>在这个函数中，您可以检查请求中的 <strong>Cookie</strong>（Next.js 推荐使用 <code>httpOnly</code> Cookie 存储 Token，而不是 <code>localStorage</code>）。</p></li></ol></li> <li><p><strong>优点 (相比您当前的方法)：</strong></p> <ul><li><strong>绝对安全：</strong> 拦截发生在服务器端。未授权的用户<strong>永远不会</strong>收到受保护页面的任何 HTML 或 JavaScript。</li> <li><strong>无闪烁：</strong> 用户会被立即、干净地重定向到登录页，根本没有机会看到受保护页面的布局。</li> <li><strong>集中管理：</strong> 所有受保护的路由都在 <code>matcher</code> 中统一定义，而不是分散在各个组件的 <code>disabled</code> 属性中。</li> <li><strong>兼容 httpOnly Cookie：</strong> 这是最安全的存储 Token 方式，因为它无法被客户端的 JavaScript（XSS 攻击）读取，但中间件在服务器上可以读取它</li></ul></li></ul></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.f81cf313.js" defer></script><script src="/jiabinxu-blog/assets/js/3.bb87b8ff.js" defer></script><script src="/jiabinxu-blog/assets/js/2.180c3171.js" defer></script><script src="/jiabinxu-blog/assets/js/33.d10d4810.js" defer></script>
  </body>
</html>
