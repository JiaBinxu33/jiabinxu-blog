<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.f81cf313.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.bb87b8ff.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.180c3171.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/30.2e981bab.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.3c2a6c83.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.3c49b8de.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.91b5c8e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.ef4b17e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.23f5619b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.4bb3669d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.664e814e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.21ad7801.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.d4db7480.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.31141967.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.97e9a047.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.f04bcbc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.f5223a9d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.d58d5448.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.fb28f85b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.d10d4810.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.f89661dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.a2c20bce.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.edabae48.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.8f37da54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.86e08cd4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.3ff6f6b3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.42a528d4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.46dbe14a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.0b72d4b8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.7d892d86.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.164a4f16.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.5bc0d409.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.82b75b59.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.e959a5f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.cc983ac3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.ed08971b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.9cbc22ee.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.f9457251.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.63e6d8ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.51ebfdbe.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.2e948603.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1907287a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.2aca8e9e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.53572a11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.6c8d55a3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.7c01df11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.1df3a578.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.bf31f66a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.f2feff3d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.d36efdc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.824240b9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.6e5633db.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.0bc9c8bd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.b03cfd91.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.3a221345.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.23192d8d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.e15e8a6b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.d4fc17a1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.bdb98294.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.5b17ac84.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/73.3030d7e2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/74.3329104a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.c9879746.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/JavaScript/#闭包原理-优点-缺点-使用场景" class="sidebar-link">闭包原理/优点/缺点/使用场景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#promise" class="sidebar-link">promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#promise-async-await-以及两者区别" class="sidebar-link">promise async await 以及两者区别</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#设计模式-发布订阅模式-单例模式" class="sidebar-link">设计模式 - 发布订阅模式 - 单例模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#es6-新增了那些语法" class="sidebar-link">Es6 新增了那些语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#let-const-var-区别" class="sidebar-link">let const var 区别</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#箭头函数和普通函数有什么差异" class="sidebar-link">箭头函数和普通函数有什么差异？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#set-集合" class="sidebar-link">Set (集合)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#map-字典" class="sidebar-link">Map (字典)</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#异步解决方案有哪些-回调函数-callback-promise-generator" class="sidebar-link">异步解决方案有哪些？ - 回调函数 callback Promise Generator</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#什么是事件委托-什么是事件冒泡" class="sidebar-link">什么是事件委托 什么是事件冒泡</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#事件轮询" class="sidebar-link">事件轮询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#执行顺序-过程" class="sidebar-link">执行顺序/过程</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#本地存储-缓存" class="sidebar-link">本地存储 缓存</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#get-和-post-的区别" class="sidebar-link">get 和 post 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#http-请求过程" class="sidebar-link">http 请求过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#http-状态码" class="sidebar-link">http 状态码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#什么是跨域" class="sidebar-link">什么是跨域?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#null-和-undefined-区别" class="sidebar-link">null 和 undefined 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#数组去重的方法" class="sidebar-link">数组去重的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#类数组概念-怎么转换成真正的数组" class="sidebar-link">类数组概念 怎么转换成真正的数组？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-数据类型检测" class="sidebar-link">js 数据类型检测</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#this-指向哪里" class="sidebar-link">this 指向哪里</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#如何改变-this-指向" class="sidebar-link">如何改变 this 指向</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#call-apply-bind-区别" class="sidebar-link">call, apply, bind 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#常用的-git-命令" class="sidebar-link">常用的 git 命令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#git-克隆速度慢的解决办法及科学上网代理配置" class="sidebar-link">Git 克隆速度慢的解决办法及科学上网代理配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_1-问题现象" class="sidebar-link">1. 问题现象</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_2-解决办法-为-git-配置代理" class="sidebar-link">2. 解决办法：为 Git 配置代理</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_3-快速开启-关闭-git-代理-推荐-alias" class="sidebar-link">3. 快速开启/关闭 Git 代理（推荐 alias）</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_4-检查-git-代理状态" class="sidebar-link">4. 检查 Git 代理状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_5-其他说明" class="sidebar-link">5. 其他说明</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_6-参考资料" class="sidebar-link">6. 参考资料</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#垃圾回收机制" class="sidebar-link">垃圾回收机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#构造函数详解与总结" class="sidebar-link">构造函数详解与总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-的几种模块规范" class="sidebar-link">js 的几种模块规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#commonjs-和-es6-模块的区别" class="sidebar-link">CommonJS 和 ES6 模块的区别</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#防抖节流" class="sidebar-link">防抖节流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-实现继承的方式有哪些" class="sidebar-link">js 实现继承的方式有哪些</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#严格模式下有哪些限制-规则" class="sidebar-link">严格模式下有哪些限制（规则）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#函数缓存的方法" class="sidebar-link">函数缓存的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#内存泄漏是什么-内存泄露造成的原因" class="sidebar-link">内存泄漏是什么 内存泄露造成的原因</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#函数柯里化" class="sidebar-link">函数柯里化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#for-in-for-of-的区别" class="sidebar-link">for in. for of 的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#核心区别" class="sidebar-link">核心区别</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#详细对比" class="sidebar-link">详细对比</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#for-in-的主要缺点" class="sidebar-link">for...in 的主要缺点</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#性能优化" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#map-循环展示添加-key" class="sidebar-link">map 循环展示添加 key</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#路由懒加载-route-lazy-loading" class="sidebar-link">路由懒加载 (Route Lazy Loading)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#第三方插件按需引入" class="sidebar-link">第三方插件按需引入</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#使用-purecomponent-react-memo-scu" class="sidebar-link">使用 PureComponent/React.memo (SCU)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#使用-usememo-usecallback" class="sidebar-link">使用 useMemo/useCallback</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#图片和静态资源优化" class="sidebar-link">图片和静态资源优化</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#防抖节流-2" class="sidebar-link">防抖节流</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#启用-gzip-brotli-压缩" class="sidebar-link">启用 Gzip/Brotli 压缩</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#虚拟滚动" class="sidebar-link">虚拟滚动</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#浏览器缓存" class="sidebar-link">浏览器缓存</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#http1-http2-http3-的核心演进" class="sidebar-link">HTTP1, HTTP2, HTTP3 的核心演进</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#http-1-1" class="sidebar-link">HTTP/1.1</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#http-2-99-的现代网站" class="sidebar-link">HTTP/2 (99% 的现代网站)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#http-3" class="sidebar-link">HTTP/3</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h1> <h2 id="闭包原理-优点-缺点-使用场景"><a href="#闭包原理-优点-缺点-使用场景" class="header-anchor">#</a> 闭包原理/优点/缺点/使用场景</h2> <ol><li>什么是闭包（外层函数调用时，外层函数的函数作用域对象被内层函数引用着，无法释放，就形成了闭包。）
<ul><li>函数嵌套函数</li> <li>内层函数中使用了外层函数的变量或参数</li> <li>内层函数作为返回值返回到外部</li></ul></li> <li>优缺点
优点：
<ul><li>保护具有共享意义的变量</li> <li>隔离作用域 避免(全局)作用域污染</li> <li>为变量提供访问和操作的相关接口</li> <li>便于进行模块化开发</li> <li>减少形参个数，延长了形参的生命周期
缺点： 占用过多的资源(内存) 大量使用不利于代码优化 【解决方式：清除变量】</li></ul></li> <li>闭包的应用场景
<ul><li>通过循环给页面上多个 dom 节点绑定事件</li> <li>封装私有变量(计数器)</li> <li>延续局部变量的寿命</li> <li>高阶组件</li> <li><a href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81">函数防抖/节流</a></li> <li><a href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a></li></ul></li> <li>闭包原理
内层函数通过作用域链使用了外层函数的变量或参数，从而导致内存无法释放，需要手动设置为 null 进行清除
模块化就是以闭包为基础构建的;</li></ol> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h2> <ul><li>ES6-Promise(承诺)
Promise 异步编程的一种解决方案，比传统的解决方案（回调函数）更合理和更强大。
Promise 可以解决回调地狱的问题</li> <li>状态
Promise 对象代表一个异步操作，有三种状态：pending 进行中、fulfilled(resolve)成功、rejected 失败
Promise 一旦状态设定，就不会再变.
Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected,只要这两种情况发生，状态就凝固了。</li> <li>编写 promise</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//resolve 成功 reject 失败</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设定成功，找 promise 下面的 then 方法,resolve 传递参数值给 then</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设定失败，找 promise 下面的 catch 方法,reject 传递参数值给 catch</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>promise 原型下面两个方法</p> <ul><li>then 方法的作用：resolve 函数将 Promise 对象的状态从“未完成”变为“成功”，找 then 方法，将 resolve 函数的参数值传递给 then 方法。</li> <li>catch 方法的作用：reject 函数将 Promise 对象的状态从“ 未完成” 变为“ 失败”，找 catch 方法，将 reject 函数的参数值传递给 catch 方法。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;11111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;22222222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，所有的 promise 成功才成功，只要有一个失败了那就是失败 使用场景：发送多个请求并根据请求顺序获取和使用数据
Promise.race():是一个数组，返回一个新的 promise，第一个完成的状态就是结果状态</p> <ul><li>缺点：
一旦新建立即执行，无法中途取消
pending 状态时，无法知道当前处于哪一个状态，是开始还是结束
不设置回调，内部抛出的错误，不会反应到外部</li></ul> <h3 id="promise-async-await-以及两者区别"><a href="#promise-async-await-以及两者区别" class="header-anchor">#</a> promise async await 以及两者区别</h3> <ul><li>Promise 概念：
<ul><li>Promise 是用来做异步的，Promise 好比容器，里面存放着一些异步的事件的结果，而这些结果一旦生成是无法改变的</li> <li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题</li></ul></li> <li>async await 概念：
<ul><li>async await 也是异步编程的一种解决方案，拥有 promise 的风格，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，async 修饰过的函数也有 then 和 catch ⽅法，await 只能放在 async 中，只能修饰 promise 对象.它返回的是一个 Promise 对象。</li></ul></li> <li>两者的区别：
<ul><li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li> <li>async await 与 Promise 一样，是非阻塞的。</li> <li>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。</li></ul></li></ul> <h2 id="设计模式-发布订阅模式-单例模式"><a href="#设计模式-发布订阅模式-单例模式" class="header-anchor">#</a> 设计模式 - 发布订阅模式 - 单例模式</h2> <p>发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p> <p>发布订阅模式的基础实现</p> <div class="language-JS extra-class"><pre class="language-js"><code>  <span class="token comment">// 利用发布订阅模式实现自定义事件(买菜，买车，买房子...)</span>
  <span class="token comment">// 例如：买菜 - 买青菜，买白菜，买番茄.....</span>
  <span class="token comment">// this.message['买菜'] = [function(){买青菜},function(){买白菜}...]</span>
  <span class="token comment">// this.message['买车'] = [function(){买宝马},function(){买奔驰}...]</span>
  <span class="token comment">// this.message['买房'] = [function(){买别墅},function(){买大平层}...]</span>
  <span class="token comment">// 买菜：事件类型   +  事件处理函数</span>

  <span class="token comment">//利用Observer进行自定义事件的开发。</span>
  <span class="token comment">//添加事件 - on</span>
  <span class="token comment">//执行事件 - emit</span>
  <span class="token comment">//删除事件 - remove</span>
<span class="token keyword">class</span> <span class="token class-name">Ob</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录事件的记事本</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加事件 - on</span>
    <span class="token comment">// type:事件类型  fn:事件处理函数。 type事件类型存在追加，不存在创建。</span>
    <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//不存在创建</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//存在追加</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行事件 - emit</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//事件类型不存在，退出</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 删除事件 - remove - 事件类型，那个事件处理函数</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//事件类型不存在，退出</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//改变原数组</span>
          i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买奔驰&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买宝马&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买奥迪&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买白菜&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绑定事件</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;cai&quot;</span><span class="token punctuation">,</span> fn4<span class="token punctuation">)</span><span class="token punctuation">;</span>

  observer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除事件</span>

  observer<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行事件</span>
  observer<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;cai&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>单例模式
单例模式就是一个实例在整个网页的生命周期里只创建一次，后续再调用实例创建函数的时候，返回的仍是之前创建的实例。在实际开发中应用十分广泛，例如页面中的登录框，显示消息的提示窗</p> <h2 id="es6-新增了那些语法"><a href="#es6-新增了那些语法" class="header-anchor">#</a> Es6 新增了那些语法</h2> <ol><li>let 和 const</li> <li>解构赋值 let{一一对应} = {一一对应}</li> <li>扩展运算符... 将数组拆分成一个一个数字的形式</li> <li>模板字符串 ``</li> <li>箭头函数 ()=&gt;{}</li> <li>promise 概述和应用</li> <li>class 面向对象的一种写法 比原型+构造函数好</li> <li>模块化 - export/import/解构赋值</li> <li>async+await promise 的语法糖</li> <li>for...of... 最好的遍历方式 不能遍历对象 遍历对象用 for in</li> <li>对象的简写风格</li></ol> <ul><li>如果属性名和属性值名称相同，写一个。</li> <li>属性值是函数可以省略 function</li></ul> <h3 id="let-const-var-区别"><a href="#let-const-var-区别" class="header-anchor">#</a> let const var 区别</h3> <ul><li><p>let 关键字</p> <ul><li>块作用域，声明的变量绑定在这个区域里面。</li> <li>不存在变量提升(暂时性死区：使用 let 或 const 声明的变量，在代码执行到该声明语句之前，都处于一个无法被访问的“暂时性死区”，强行使用会引发 ReferenceError)。</li> <li>相同的作用域内不能重复声明(熟悉报错:Identifier 'a' has already been declared)</li></ul></li> <li><p>var 关键字</p> <ul><li>局部和全局作用域，函数内部是局部，函数外面是全局。</li> <li>变量提升</li> <li>相同的作用域内可以重复声明</li> <li>预解析(1.预编译 var,function 2.代码逐行执行)</li> <li>var 声明的变量也是 window 的属性</li></ul></li> <li><p>const 关键字</p> <ul><li>声明的常量值不能被改变</li> <li>对象的值不能改变，对象里面的属性可以改变的。</li> <li>使用场景(存储不变的值，存储函数，存储元素对象，存储对象)</li></ul></li></ul> <h3 id="箭头函数和普通函数有什么差异"><a href="#箭头函数和普通函数有什么差异" class="header-anchor">#</a> 箭头函数和普通函数有什么差异？</h3> <ul><li>相比普通函数更简洁的语法</li> <li>没有 this,捕获其所在上下文的 this 值，作为自己的 this 值</li> <li>不能使用 new,箭头函数作为匿名函数,是不能作为构造函数的,不能使用 new</li> <li>不绑定 arguments，用 rest 参数...解决
let test3=(...a)=&gt;{console.log(a[1])} //22</li> <li>使用 call()和 apply()调用:由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响：</li> <li>箭头函数没有原型属性</li> <li>不能简单返回对象字面量
let fun5 = ()=&gt;({ foo: x }) //如果 x =&gt; { foo: x } //则语法出错</li> <li>箭头函数不能当做 Generator 函数,不能使用 yield 关键字</li> <li>箭头函数不能换行<div class="language-JS extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">=&gt;</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//SyntaxError: Unexpected token =&gt;</span>
</code></pre></div></li> <li>使用箭头函数应该注意什么？
<ul><li>不要在对象里面定义函数，对象里面的行数应该用传统的函数方法</li> <li>不要在对原型对象上定义函数，在对象原型上定义函数也是遵循着一样的规则</li> <li>不要用箭头定义构造函数</li> <li>不要用箭头定义事件回调函数</li></ul></li></ul> <h3 id="set-集合"><a href="#set-集合" class="header-anchor">#</a> Set (集合)</h3> <ul><li><p><strong>“值”的集合：</strong> <code>Set</code> 是一种只存储“值”的集合。</p></li> <li><p><strong>唯一性：</strong> 它的核心特点是，<code>Set</code> 内部的<strong>所有值都是唯一的</strong>。它像一个“不能有重复项”的数组。</p></li> <li><p>作用</p> <ul><li><strong>保证数据唯一：</strong> 它的主要用途是存储一系列<strong>不需要重复</strong>的值。</li> <li><strong>数组去重：</strong> 在实践中，它最常被用来为“数组”进行快速去重。</li> <li><strong>快速查找：</strong> 用来快速检查一个“值”是否存在于某个集合中（<code>has</code> 操作）。</li></ul></li> <li><p>用法</p> <ul><li><strong>键值相同：</strong> 它的底层存储也是“键值对”的，但它的“键”和“值”是<strong>相同</strong>的。</li> <li><strong>核心操作：</strong> <ul><li><code>add</code> (添加)：添加一个新值。如果值已存在，则什么也不做。</li> <li><code>has</code> (检查)：检查一个值是否存在，返回 <code>true</code> 或 <code>false</code>。</li> <li><code>delete</code> (删除)：删除一个值。</li> <li><code>size</code> (大小)：获取集合中值的数量（类似数组的 <code>length</code>）。</li></ul></li></ul></li> <li><p>注意</p> <ul><li><strong>唯一性判断：</strong> <code>Set</code> 判断“值”是否相等，基本和 <code>===</code> (严格相等) 一致，但有一个<strong>例外</strong>。</li> <li><strong>NaN 的处理：</strong> <code>Set</code> 认为 <code>NaN</code> <strong>等于</strong> <code>NaN</code>。这意味着你向 <code>Set</code> 中 <code>add</code> 多个 <code>NaN</code>，最终只会保留一个。</li> <li><strong>对象引用：</strong> 如果存的是对象，<code>Set</code> 比较的是“内存地址”（引用）。两个内容相同的<strong>不同对象</strong>，在 <code>Set</code> 中被视为<strong>两个不同</strong>的值。</li> <li><strong>无索引：</strong> <code>Set</code> 是一个集合，<strong>没有“下标”</strong>（Index）。你不能通过 <code>set[0]</code> 这样的方式访问。</li> <li><strong>迭代顺序：</strong> <code>Set</code> 是<strong>有序的</strong>。它的迭代顺序（例如 <code>forEach</code>）就是<strong>插入顺序</strong>。</li></ul></li></ul> <hr> <h3 id="map-字典"><a href="#map-字典" class="header-anchor">#</a> Map (字典)</h3> <ul><li><p><strong>“键值对”的集合：</strong> <code>Map</code> 是一种存储“键值对”（Key-Value Pair）的集合。</p></li> <li><p><strong>“超级对象”：</strong> 它解决了 JavaScript 传统对象 (<code>Object</code>) 的一个核心限制。</p></li> <li><p>作用</p> <ul><li><strong>解决 Object 的限制：</strong> 传统 <code>Object</code> 的“键”<strong>只能是字符串</strong>或 <code>Symbol</code>。如果你尝试用一个“对象”作为键，它会被自动转成字符串（如 <code>[object Object]</code>）。</li> <li><strong>任意类型的键：</strong> <code>Map</code> 的“键”<strong>可以是任意数据类型</strong>，包括（但不限于）<code>Object</code>, <code>Array</code>, <code>Function</code>, <code>NaN</code>, <code>null</code> 等。</li></ul></li> <li><p><strong>核心操作：</strong></p> <ul><li><code>set</code> (设置)：设置一个键值对。</li> <li><code>get</code> (获取)：根据“键”来获取“值”。</li> <li><code>has</code> (检查)：检查一个“键”是否存在。</li> <li><code>delete</code> (删除)：删除一个键值对。</li> <li><code>size</code> (大小)：获取键值对的数量。</li></ul></li> <li><p>注意</p> <ul><li><strong>键的类型：</strong> <code>Map</code> 真正强大的地方在于它对“键”的包容性。</li> <li><strong>NaN 的处理：</strong> <code>Map</code> 也认为 <code>NaN</code> 键<strong>等于</strong> <code>NaN</code> 键。</li> <li><strong>迭代顺序：</strong> <code>Map</code> 也是<strong>有序的</strong>。它的迭代顺序就是<strong>插入顺序</strong>。</li> <li><strong>与 Object 的选择：</strong> <ul><li><strong>Object：</strong> 当你只需要简单的、键是“字符串”或 <code>Symbol</code> 的哈希表时，用 <code>Object</code>。</li> <li><strong>Map：</strong> 当你需要“非字符串”作为键，或者你需要保证“插入顺序”时，必须用 <code>Map</code>。</li></ul></li> <li><strong>内存陷阱（WeakMap）：</strong> <ul><li><code>Map</code> 会强引用（Strong Reference）它的“键”和“值”。</li> <li><strong>陷阱：</strong> 如果你用一个“对象”作为 <code>Map</code> 的键，只要这个 <code>Map</code> 存在，那个“对象”就<strong>永远不会</strong>被垃圾回收，这可能导致内存泄漏。</li> <li><strong>解决：</strong> 如果你只是想把“数据”临时“挂载”到某个对象上，并且希望该对象在别处被销毁时自动释放内存，应该使用 <code>WeakMap</code>。</li></ul></li></ul></li></ul> <hr> <h2 id="异步解决方案有哪些-回调函数-callback-promise-generator"><a href="#异步解决方案有哪些-回调函数-callback-promise-generator" class="header-anchor">#</a> 异步解决方案有哪些？ - 回调函数 callback Promise Generator</h2> <ul><li>回调函数 callback：回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。</li> <li>事件发布订阅:消耗内存，过度使用会使代码难以维护和理解</li> <li>Promise:无法取消 promise。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 Pending 状态时，无法得知目前进展到哪一个阶段</li> <li>Generator:Generator 是 es6 提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用 yield 语句。Generaotr 函数会返回一个遍历器，可以进行遍历操作执行每个中断点 yield,不能自动执行异步操作，需要写多个 next()方法.</li> <li>async/await:es2017 引入的异步操作解决方案，可以理解为 Generator 的语法糖，最重要的好处是同步编程风格,async 函数返回一个 Promise。内置执行器，比 Generator 操作更简单。async/await 比*yield 语义更清晰。返回值是 Promise 对象，可以用 then 指定下一步操作。代码更整洁。可以捕获同步和异步的错误。</li></ul> <h2 id="什么是事件委托-什么是事件冒泡"><a href="#什么是事件委托-什么是事件冒泡" class="header-anchor">#</a> 什么是事件委托 什么是事件冒泡</h2> <ul><li><p>事件流：事件流就是事件冒泡和事件捕获</p></li> <li><p>事件冒泡：事件开始时由最具体的元素接收(操作元素)，然后逐级向上传播到较为不具体的节点,一直到文档 document</p></li> <li><p>事件捕获：反过来从最不具体的到最具体的</p></li> <li><p>事件委托就是将自身要添加的事件委托给其他元素 从而实现相同的效果
原生 js 里面添加事件委托是 addEventListener 移出是 removeEventListener</p></li> <li><p>事件委托的优缺点：</p> <ul><li>优点：减少事件注册次数，节约内存，提升性能。</li> <li>缺点：所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</li></ul></li></ul> <h2 id="事件轮询"><a href="#事件轮询" class="header-anchor">#</a> 事件轮询</h2> <p><strong>核心定义：事件循环是主线程的工作基石</strong></p> <p>事件循环（Event Loop），也称消息循环（Message Loop），是浏览器渲染主线程的核心工作机制。其本质可以理解为一个永不停止的 for 循环，持续地从“任务队列”中取出任务来执行。其他线程（如处理定时器、网络请求的线程）负责在任务完成后，将相应的回调任务放入任务队列中，等待主线程的调度。</p> <ul><li><p>宏任务 (Macrotask):</p> <ul><li>JavaScript 的同步代码</li> <li>I/O 操作</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li> <li>requestAnimationFrame</li></ul></li> <li><p>微任务 (Microtask):</p> <ul><li>Promise (具体如 Promise.then, catch 和 finally)</li> <li>process.nextTick</li> <li>MutationObserver</li></ul></li></ul> <h3 id="执行顺序-过程"><a href="#执行顺序-过程" class="header-anchor">#</a> 执行顺序/过程</h3> <ol><li><p>执行同步代码（宏任务）： 事件循环开始，首先会执行主线程上的同步代码。比如 console.log('script start') 会被立即执行。</p></li> <li><p>分发异步任务： 在执行同步代码的过程中，如果遇到异步任务，主线程会把它们分发出去。</p> <ul><li>比如 setTimeout，它的回调会被放到一个“宏任务”（macrotask）队列中。</li> <li>比如 Promise.then，它的回调会被放到“微队列”（microtask queue）中。</li></ul></li> <li><p>同步代码执行完毕： 当主线程的同步代码（即当前的第一个宏任务）全部执行完毕后，主线程会立即检查微队列。</p></li> <li><p>清空微队列（Microtask Checkpoint）： 这是最关键的一步。主线程会查看微队列，如果里面有任务，主线程会一次性将微队列中的所有任务全部执行完毕。如果在执行微任务的过程中，又产生了新的微任务，那么这些新的微任务也会被加到微队列的末尾，并在这个同一个阶段被执行，直到微队列被彻底清空为止。</p></li> <li><p>执行下一个宏任务： 只有在微队列被完全清空之后，事件循环才会去宏任务队列中取出一个任务来执行。</p></li> <li><p>重复循环： 当这个宏任务（setTimeout 回调）执行完毕后，事件循环会再次重复第 4 步：立即检查微队列，清空所有微任务。然后再去执行第 5 步：取下一个宏任务。</p></li></ol> <p><strong>模型的演进：告别简单的“宏/微任务”二分法</strong></p> <p>过去常将任务队列简单地分为“宏队列”（Macrotask Queue）和“微队列”（Microtask Queue）。但在现代复杂的浏览器环境下，这种二分法已不再适用。现代浏览器采用了更灵活、精细的多队列任务处理模型。</p> <p><strong>现代 W3C 模型：多队列与优先级调度</strong></p> <p>根据 W3C 官方规范，现代事件循环的任务调度遵循以下原则：</p> <ul><li>浏览器内部存在多个任务队列，每个任务按类型（如用户交互、渲染、网络等）划分到不同队列。</li> <li>不同队列拥有不同优先级，由浏览器根据当前页面状态智能调度。</li> <li>微队列（Microtask Queue）拥有绝对最高优先级，在每次事件循环中只要微队列有任务，必须全部执行完后再处理其他队列任务。</li></ul> <p><strong>执行过程实例分析</strong></p> <p>下面用一个具体的例子，详细说明现代浏览器事件循环的执行过程：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;microtask1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;microtask2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行流程及输出分析：</p> <ol><li>首先同步执行主线程中的代码，输出：<div class="language- extra-class"><pre class="language-text"><code>script start
script end
</code></pre></div></li> <li><code>setTimeout</code> 的回调被放入 macrotask 队列。</li> <li><code>Promise.then</code> 的回调被加入微队列（microtask queue）。</li> <li>主线程同步任务执行完毕，事件循环开始下一个阶段。</li> <li>检查微队列，发现有两个微任务，按照顺序依次全部执行，输出：<div class="language- extra-class"><pre class="language-text"><code>microtask1
microtask2
</code></pre></div></li> <li>微队列执行完毕，事件循环继续处理 macrotask 队列中的任务，即 setTimeout 的回调，输出：<div class="language- extra-class"><pre class="language-text"><code>timeout
</code></pre></div></li></ol> <p>最终输出顺序为：</p> <div class="language- extra-class"><pre class="language-text"><code>script start
script end
microtask1
microtask2
timeout
</code></pre></div><p>这个例子清晰地展现了微队列在事件循环中的绝对优先级：只要微队列有任务，主线程会优先全部执行完微任务，然后再去处理其他类型的任务队列。这正是现代浏览器事件循环模型的核心特征。</p> <h2 id="本地存储-缓存"><a href="#本地存储-缓存" class="header-anchor">#</a> 本地存储 缓存</h2> <ul><li>存储大小
cookie 数据大小不能超过 4k。
sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li> <li>有效时间
localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage 数据在当前浏览器窗口关闭后自动删除。
cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li> <li>数据与服务器之间的交互方式
cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端
sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li></ul> <p>cookie 验证不安全易遭到 CSRF 攻击：
当你当前网站没有退出，而恰好漏洞网站又已你当前网站为漏洞，并添加转账信息或各种增删改查信息等，你的数据就会被篡改，导致不安全，CSRF 攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式。
方法：
通常使用 Anti CSRF Token 来防御 CSRF 攻击，同时要注意 Token 的保密性和随机性。</p> <ul><li>尽量使用 POST，限制 GET</li> <li>将 cookie 设置为 HttpOnly</li> <li>增加 token</li> <li>并且 CSRF 攻击问题一般是由服务端解决。</li></ul> <h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> get 和 post 的区别</h2> <ul><li>语义化：get 获取 post 传输</li> <li>数据长度：get 地址栏，地址栏仅能传输 2000 多个字符，post 理论上无限。</li> <li>安全性：get 不安全，地址栏显示，post 安全。</li> <li>传输数据：get 通过地址栏?和&amp; post 通过请求头和 send 方法</li> <li>缓存问题：get 有缓存，post 没有缓存。
清除缓存：浏览器设置 - 清除数据。 快捷方式：ctrl+h 左侧查看清除按钮</li></ul> <h2 id="http-请求过程"><a href="#http-请求过程" class="header-anchor">#</a> http 请求过程</h2> <p>用户输入网址 → 域名解析 → 建立连接 → 发送 HTTP 请求 → 服务器处理 → 返回响应 → 浏览器渲染
http 请求流程
浏览器端，客户端，前端</p> <ul><li>用户在浏览器地址栏输入域名
例如输入：https://www.taobao.com</li> <li>域名解析（DNS 解析）
浏览器首先检查本地缓存（浏览器 DNS 缓存、操作系统 DNS 缓存）是否有该域名的 IP 地址。
如果没有，则向本地 DNS 服务器发起请求，逐级递归或迭代查询，最终获取到 www.taobao.com 对应的 IP 地址。
域名和服务器的 IP 地址建立绑定关系。</li> <li>建立 TCP 连接（三次握手）
浏览器和目标服务器（如淘宝服务器）在目标端口（通常是 80/443）上建立 TCP 连接。
HTTPS 协议还会有 TLS/SSL 握手过程，协商加密方式和密钥。</li> <li>浏览器向服务器发送 HTTP 请求
包括请求方法（GET/POST 等）、请求头（headers）、请求体（body，POST 时有）等。
服务器处理请求，返回响应
服务器收到请求后，查找对应的资源，处理业务逻辑，并生成响应内容（HTML、CSS、JS、图片等）。</li> <li>浏览器接收响应，渲染页面
浏览器解析返回的 HTML，遇到 CSS、JS、图片等资源会继续发起新的 HTTP 请求。
解析和执行 CSS 样式、JavaScript 代码，最终渲染出完整的网页供用户交互。</li></ul> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> http 状态码</h2> <p>200：成功，所有数据都在响应主体中
300：有多个资源地址，选择要访问的资源便可链接过去
301:被请求的资源已经永久移动到新位置
302:请求的资源临时从不同的 url 响应请求
304：如果客户端发送了⼀个带条件的请求，请求被允许后⽂档内容却没有改变
400:请求参数错误
401:未授权，请登录
403:跨域拒绝访问
404:请求失败，请求的资源在服务器上没有被找到
408:请求超时
500：通常为服务器源代码出错⽽⽆法响应请求
501:error.message = 服务未实现;
502:网关错误;
503:服务不可用;
504:网关超时;</p> <h2 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域?</h2> <p>所谓的同源是指，域名、协议、端口均为相同。
所谓的跨域，不同的域名、协议、端口皆为不同域
一个域与另一个域名、协议或者端口不同的域的之间访问都叫跨域</p> <p><strong>解决跨域的方法和方案：</strong></p> <ul><li><p>配置本地开发环境（环境代理）</p> <ul><li><p><strong>原理</strong>：通过前端开发服务器（如 webpack-dev-server、Vite、create-react-app 等工具）配置 <code>proxy</code> 字段，将接口请求代理到后端服务器，实现“同源”效果，从而规避浏览器的同源策略限制。</p></li> <li><p><strong>特点</strong>：仅适用于本地开发环境，生产环境不可用。</p></li> <li><p><strong>示例</strong>（以 Vite 为例）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vite.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">server</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;/api&quot;</span><span class="token operator">:</span> <span class="token string">&quot;http://backend-server.com&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>JSONP 跨域</p> <ul><li><p><strong>原理</strong>：利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点，通过动态创建 <code>&lt;script&gt;</code> 标签，加载携带参数的请求，服务器返回一段 JavaScript 代码并调用事先定义好的回调函数实现数据传递。</p></li> <li><p><strong>实现步骤</strong>：</p> <ol><li>前端声明一个全局回调函数。</li> <li>动态创建 <code>&lt;script&gt;</code> 标签，将请求地址（带回调函数名参数）赋值给 <code>src</code> 属性。</li> <li>插入页面，触发请求，服务端返回形如 <code>callback(data)</code> 的 JS 代码，自动执行。</li></ol></li> <li><p><strong>注意事项</strong>：</p> <ul><li>仅支持 GET 请求，无法处理 POST、PUT 等。</li> <li>服务器需要支持 JSONP 格式的响应。</li> <li>返回内容会作为 JS 脚本执行，有一定安全隐患。</li></ul></li> <li><p><strong>示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://example.com/api?callback=handleResponse&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>CORS（跨域资源共享，Cross-Origin Resource Sharing）</p> <ul><li><p><strong>原理</strong>：服务器通过设置 <code>Access-Control-Allow-Origin</code> 等响应头，允许特定源的请求跨域访问资源。现代浏览器在发起跨域请求时会自动遵循 CORS 协议。</p></li> <li><p><strong>特点</strong>：</p> <ul><li>支持多种 HTTP 方法（GET、POST、PUT、DELETE 等）。</li> <li>对开发者而言，前端代码和同源 AJAX 通信基本一致。</li> <li>需要后端服务器配合设置响应头。</li></ul></li> <li><p><strong>常见配置</strong>（Node.js Express 示例）：</p> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许所有域名</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GET,POST,PUT,DELETE,OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Content-Type, Authorization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>Nginx 反向代理跨域</p> <ul><li><p><strong>原理</strong>：通过 Nginx 服务器配置反向代理，将前端请求转发到目标后端服务器，实现跨域资源访问。前端与 Nginx 同源，Nginx 代前端发起请求。</p></li> <li><p><strong>特点</strong>：</p> <ul><li>适用于生产环境，性能优良。</li> <li>不改变前端和后端代码，仅需配置 Nginx。</li></ul></li> <li><p><strong>示例配置</strong>：</p> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span> www.frontend.com</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">location</span> /api/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend-server.com/api/</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>其他常见的跨域解决方案</p> <ul><li><strong>后端中间件代理</strong>：如 Node.js 的 http-proxy-middleware，原理类似于 Nginx 代理。</li> <li><strong>WebSocket</strong>：WebSocket 协议本身不受同源策略的限制，可以进行跨域通信。</li> <li><strong>window.name、postMessage 跨域</strong>：适用于 iframe 或多窗口间通信。</li></ul></li></ul> <hr> <h2 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="header-anchor">#</a> null 和 undefined 区别</h2> <p><code>null</code> 和 <code>undefined</code> 都表示“空值”，但在 JavaScript 中，它们代表了两种不同的“空”状态。</p> <ol><li><p>核心含义和本质</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;"><code>undefined</code> (未定义)</th> <th style="text-align:left;"><code>null</code> (空值)</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>含义</strong></td> <td style="text-align:left;"><strong>变量已声明，但尚未赋值。</strong></td> <td style="text-align:left;"><strong>变量已被赋值，但该值是空的。</strong></td></tr> <tr><td style="text-align:left;"><strong>本质</strong></td> <td style="text-align:left;">表示<em>缺少</em>值 (A variable has been declared but not defined/assigned a value)。</td> <td style="text-align:left;">表示<em>故意</em>没有对象值 (A value that is intentionally set to be empty or non-existent)。</td></tr> <tr><td style="text-align:left;"><strong>产生者</strong></td> <td style="text-align:left;">JavaScript 引擎（系统）默认赋予。</td> <td style="text-align:left;">开发者必须手动赋值。</td></tr></tbody></table> <p><strong>记忆要点：</strong></p> <ul><li><strong><code>undefined</code></strong>：系统默认值，表示**“变量存在，值待定”**。</li> <li><strong><code>null</code></strong>：人为赋予值，表示**“变量存在，值为空/无对象”**。</li></ul></li> <li><p>类型检查 (<code>typeof</code>)</p> <p>使用 <code>typeof</code> 运算符进行检查时，它们的结果不同：</p> <table><thead><tr><th style="text-align:left;">表达式</th> <th style="text-align:left;">结果</th> <th style="text-align:left;">备注</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>typeof undefined</code></td> <td style="text-align:left;"><code>&quot;undefined&quot;</code></td> <td style="text-align:left;">自身类型。</td></tr> <tr><td style="text-align:left;"><code>typeof null</code></td> <td style="text-align:left;"><code>&quot;object&quot;</code></td> <td style="text-align:left;"><strong>⚠️ 注意：</strong> 这是一个历史遗留的 Bug，但实际进行类型检查时需记住此结果。</td></tr></tbody></table></li> <li><p>常见产生场景</p> <table><thead><tr><th style="text-align:left;"><code>undefined</code> 的常见场景</th> <th style="text-align:left;"><code>null</code> 的常见场景</th></tr></thead> <tbody><tr><td style="text-align:left;">1. <strong>未初始化的变量：</strong> <code>let x;</code></td> <td style="text-align:left;">1. <strong>手动清空变量：</strong> <code>let data = null;</code></td></tr> <tr><td style="text-align:left;">2. <strong>函数没有返回值：</strong> 函数体中没有 <code>return</code> 语句。</td> <td style="text-align:left;">2. <strong>DOM 查询没有匹配项：</strong> <code>document.getElementById()</code> 未找到元素。</td></tr> <tr><td style="text-align:left;">3. <strong>函数参数未传值：</strong> 调用函数时省略了参数。</td> <td style="text-align:left;">3. <strong>JSON 传输空值：</strong> 接口返回数据中表示值为空。</td></tr> <tr><td style="text-align:left;">4. <strong>对象中不存在的属性：</strong> <code>obj.nonExistentProperty</code></td> <td style="text-align:left;">4. <strong>原型链末端：</strong> <code>Object.getPrototypeOf(Object.prototype)</code> 的结果。</td></tr></tbody></table></li> <li><p>相等性比较</p> <p>在比较时，区分<strong>宽松相等</strong> (<code>==</code>) 和<strong>严格相等</strong> (<code>===</code>) 至关重要：</p> <table><thead><tr><th style="text-align:left;">比较方式</th> <th style="text-align:left;">表达式</th> <th style="text-align:left;">结果</th> <th style="text-align:left;">解释</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>严格相等</strong></td> <td style="text-align:left;"><code>null === undefined</code></td> <td style="text-align:left;"><code>false</code></td> <td style="text-align:left;">类型和值都不同。<strong>（推荐使用此方式）</strong></td></tr> <tr><td style="text-align:left;"><strong>宽松相等</strong></td> <td style="text-align:left;"><code>null == undefined</code></td> <td style="text-align:left;"><code>true</code></td> <td style="text-align:left;">宽松相等认为它们属于同一类“空值”，会进行隐式类型转换。</td></tr></tbody></table> <p>在实际开发中，<strong>始终推荐使用严格相等 (<code>===</code>)</strong>，因为它能更精确地判断值和类型的真实情况。</p></li></ol> <h2 id="数组去重的方法"><a href="#数组去重的方法" class="header-anchor">#</a> 数组去重的方法</h2> <ul><li>利用 set 数据结构里面没有重复的项的特点定义一个新数组用扩展运算符后面接一个 newSet 外面包一个[]在赋值给一个新数组 return 出去</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>遍历数组 并且把每一项 push 到新数组中去 push 的时候做判断 如果新数组中没有这项就 push 用 indexOf(item)=== -1 做判断</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  params<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newarr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newarr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用两层 for 循环 第一层直接遍历 第二层从 i+1 开始遍历 就是吧数组中的一项和数组中的每一项做对比 如果有一样的 那么就截取掉</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">three</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> params<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        j<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用 filter 筛选 筛选索引 如果 indexof(item)等于 index 原理是 indexOf 是从前往后找 找到了之后他就不找了 如果这时候做个比较 只有相等的时候满足条件就可以去重了</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">four</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> params<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> params<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>两层 for 循环 把数组中的一项和数组中的每一项做对比 重复的把 flag 赋值为 2 下面做个判断 当 flag 为 1 的时候才 push</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">five</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//去重后新的数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len1 <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//标记</span>
    <span class="token comment">//arr 的一项和所有的 newarr 里面的数组项进行比较</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len2 <span class="token operator">=</span> newarr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> newarr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//满足条件，新数组里面存在。不需要的</span>
        flag <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果到这里 flag=1,不满足上面的 if 判断，新数组不存在，需要的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newarr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对象数组去重原理第一层直接遍历 第二层从 i+1 开始遍历 就是吧把数组中的一项的 key 和数组中的每一项的 key 做对比 如果有一样的 那么就截取掉这一项</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">===</span> item<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        item<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        j<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="类数组概念-怎么转换成真正的数组"><a href="#类数组概念-怎么转换成真正的数组" class="header-anchor">#</a> 类数组概念 怎么转换成真正的数组？</h2> <p>也叫伪数组，在 js 中有一些对象它也拥有 length 属性，且拥有为非负整数的属性(索引)，但是它又不能调用数组的方法，这种对象被称为类数组对象</p> <p>常见的伪数组</p> <ul><li>DOM 方法返回的 NodeList（比如 document.querySelectorAll() 的结果）</li> <li>arguments 对象：让你在函数内部能访问到所有传递进来的参数，无论函数定义时声明了多少个形式参数。</li></ul> <p><strong>类数组转换成真正的数组</strong></p> <ol><li><p>let 定义一个类数组 把类数组拆分成一系列用逗号隔开的值 arr =[一系列用逗号隔开的值]</p></li> <li><p>Array.from()方法用于将对象转为真正的数组(类数组转数组)</p></li> <li><p>遍历类数组 将取到的每一项值添加到新数组</p></li></ol> <h2 id="js-数据类型检测"><a href="#js-数据类型检测" class="header-anchor">#</a> js 数据类型检测</h2> <ul><li>typeof 引用数据类型（如：Array）是不起作用的。</li> <li>instanceof 检测基本数据类型的话会返回 false 引用数据类型则会是 true 但是用 new 关键字 new 出来的基本数据类型是可以的</li> <li>constructor 声明了一个构造函数，并且把他的原型指向了其他类型的原型 这种情况下会失效</li> <li>Object.prototype.toString.call() - 最好的数据类/型检测方式</li></ul> <h2 id="this-指向哪里"><a href="#this-指向哪里" class="header-anchor">#</a> this 指向哪里</h2> <ul><li>普通函数的 this 指向调用这个函数的对象，默认是 window</li> <li>构造函数的 this 指向 new 出来的实例对象，而且优先级是最高的，不能被改变</li> <li>箭头函数的 this 指向的是它外面的第一个不是箭头函数的函数的 this， 在定义时就确定了，不能被改变</li> <li>事件处理函数的 this 指向事件对象</li></ul> <h2 id="如何改变-this-指向"><a href="#如何改变-this-指向" class="header-anchor">#</a> 如何改变 this 指向</h2> <ul><li>利用 call,apply,bind 改变 this 的指向。</li> <li>利用变量将正确的 this 存储为变量。</li> <li>new 关键字改变 this 的指向。</li> <li>箭头函数</li></ul> <h2 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="header-anchor">#</a> call, apply, bind 区别</h2> <ul><li>call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。</li> <li>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</li> <li>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。</li></ul> <h2 id="常用的-git-命令"><a href="#常用的-git-命令" class="header-anchor">#</a> 常用的 git 命令</h2> <p><strong>git</strong>
git 是目前世界上最先进分布式的版本控制系统</p> <div class="language-bash extra-class"><pre class="language-bash"><code>**配置**

- 仓库账号的用户名和邮箱
  <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">'远程仓库的账号'</span>
  <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">'远程仓库的邮箱'</span>
  **上传本地文件**
  <span class="token function">git</span> init
  初始化
  <span class="token function">git</span> <span class="token function">add</span> index.html 或者 <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  提交到暂存区
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'init index.html'</span>
  提交到本地仓库
  <span class="token function">git</span> status
  查看 <span class="token function">git</span> 的状态
  <span class="token function">git</span> <span class="token function">diff</span>
  查看版本的差别
  <span class="token function">git</span> log 或者 <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
  查看版本信息
  <span class="token function">git</span> reset HEAD^
  回退一个版本<span class="token punctuation">(</span>回退到的是暂存区的版本<span class="token punctuation">)</span>
  <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> cc56901
  回退到指定版本
  <span class="token function">git</span> reflog
  查看所有的历史版本
  **分支**
  <span class="token function">git</span> branch
  查看分支
  <span class="token function">git</span> branch dev
  创建分支
  <span class="token function">git</span> checkout dev 或者 <span class="token function">git</span> switch dev
  切换分支
  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> dev2
  创建并切换
  <span class="token function">git</span> merge dev2
  合并分支内容
  <span class="token function">git</span> branch <span class="token parameter variable">-d</span> dev2
  删除分支
  <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
  查看分支记录
  **关联远程仓库**
  生成密钥对
  ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">'pudge_wj@163.com'</span>
  创建项目
  <span class="token function">git</span> init
  <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'init'</span>
  <span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:pudge-w/taobao.git
  <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master
  邀请组员
  setting -<span class="token operator">&gt;</span> manage access
  组员开发
  不要在 master 做开发<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> zhengguo
  <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'xxx'</span>
  <span class="token function">git</span> pull
  <span class="token function">git</span> push
  组长
  <span class="token function">git</span> fetch <span class="token parameter variable">--all</span>
  <span class="token function">git</span> checkout zhengguo
  <span class="token function">git</span> pull
  <span class="token function">git</span> checkout master
  <span class="token function">git</span> merge zhengguo
  <span class="token function">git</span> push

</code></pre></div><h2 id="git-克隆速度慢的解决办法及科学上网代理配置"><a href="#git-克隆速度慢的解决办法及科学上网代理配置" class="header-anchor">#</a> Git 克隆速度慢的解决办法及科学上网代理配置</h2> <p>在中国大陆等地区，使用 <code>git clone</code> 从 GitHub 等国外仓库拉取代码时，常常会遇到速度较慢、甚至连接超时的问题。如果没有使用全局加速器（如全局 VPN），可以通过配置 Git 的代理端口，快速实现“科学上网”，显著提升 Git 操作速度。</p> <hr> <h3 id="_1-问题现象"><a href="#_1-问题现象" class="header-anchor">#</a> 1. 问题现象</h3> <ul><li><code>git clone</code>、<code>git fetch</code>、<code>git pull</code> 等指令速度极慢，甚至失败。</li> <li>原因：国内网络对 GitHub 等国外源访问受限，速度被大幅降低。</li> <li>解决思路：为 Git 单独配置代理端口，让其流量通过本地加速器的 HTTP(S) 代理端口转发。</li></ul> <hr> <h3 id="_2-解决办法-为-git-配置代理"><a href="#_2-解决办法-为-git-配置代理" class="header-anchor">#</a> 2. 解决办法：为 Git 配置代理</h3> <h4 id="_2-1-选择合适的本地代理端口"><a href="#_2-1-选择合适的本地代理端口" class="header-anchor">#</a> 2.1 选择合适的本地代理端口</h4> <ul><li>常见的科学上网工具（如 Clash、V2RayN、Surfboard 等）都支持本地 HTTP(S) 代理，端口号一般为 <code>7890</code>、<code>7897</code>、<code>1080</code> 等（以实际工具配置为准）。</li> <li>例如 Clash 默认 HTTP 代理端口为 <code>7890</code>，部分工具自定义端口为 <code>7897</code>。</li></ul> <h4 id="_2-2-全局配置-git-代理"><a href="#_2-2-全局配置-git-代理" class="header-anchor">#</a> 2.2 全局配置 Git 代理</h4> <p>可以直接在命令行设置：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy http://127.0.0.1:7897
<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy http://127.0.0.1:7897
</code></pre></div><ul><li>这样配置后，所有 Git 操作都会通过本地的 7897 端口进行 HTTP/HTTPS 请求，实现加速。</li></ul> <h4 id="_2-3-取消-git-代理"><a href="#_2-3-取消-git-代理" class="header-anchor">#</a> 2.3 取消 Git 代理</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> http.proxy
<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> https.proxy
</code></pre></div><hr> <h3 id="_3-快速开启-关闭-git-代理-推荐-alias"><a href="#_3-快速开启-关闭-git-代理-推荐-alias" class="header-anchor">#</a> 3. 快速开启/关闭 Git 代理（推荐 alias）</h3> <p>为了方便日常切换，可以将开启和关闭代理的操作写成 shell alias：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 快速开启 Git 科学上网代理</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">proxy_on</span><span class="token operator">=</span><span class="token string">&quot;git config --global http.proxy http://127.0.0.1:7897 &amp;&amp; git config --global https.proxy http://127.0.0.1:7897 &amp;&amp; echo 'Git proxy has been turned ON.'&quot;</span>

<span class="token comment"># 快速关闭 Git 科学上网代理</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">proxy_off</span><span class="token operator">=</span><span class="token string">&quot;git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy &amp;&amp; echo 'Git proxy has been turned OFF.'&quot;</span>
</code></pre></div><blockquote><p><strong>提示</strong>：可以将上述 alias 写入 <code>~/.bashrc</code>、<code>~/.zshrc</code> 等 shell 配置文件中，重开终端即可生效。</p> <ul><li>之后只需运行 <code>proxy_on</code> 即可开启代理，<code>proxy_off</code> 关闭代理。</li></ul></blockquote> <hr> <h3 id="_4-检查-git-代理状态"><a href="#_4-检查-git-代理状态" class="header-anchor">#</a> 4. 检查 Git 代理状态</h3> <p>可以通过以下命令查看当前 git 的代理配置：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--get</span> http.proxy
<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--get</span> https.proxy
</code></pre></div><p>如果返回为空，则说明当前未配置代理。</p> <hr> <h3 id="_5-其他说明"><a href="#_5-其他说明" class="header-anchor">#</a> 5. 其他说明</h3> <ul><li>该方法仅影响 Git 命令（不影响其它终端流量）。</li> <li>记得本地代理工具必须已启动并监听对应端口，否则配置后 Git 会连接失败。</li> <li>若使用 SSH 协议（如 <code>git@github.com:xxx</code>），本配置<strong>无效</strong>，建议改用 HTTPS 协议（如 <code>https://github.com/xxx</code>）克隆仓库。</li> <li>若需临时代理（只对单条命令生效），可用如下方式：<div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> <span class="token parameter variable">-c</span> <span class="token assign-left variable">http.proxy</span><span class="token operator">=</span>http://127.0.0.1:7897 <span class="token parameter variable">-c</span> <span class="token assign-left variable">https.proxy</span><span class="token operator">=</span>http://127.0.0.1:7897 clone https://github.com/xxx/xxx.git
</code></pre></div></li></ul> <hr> <h3 id="_6-参考资料"><a href="#_6-参考资料" class="header-anchor">#</a> 6. 参考资料</h3> <ul><li><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener noreferrer">Git 官方文档：git-config<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.cfw.lbyczf.com/contents/proxy.html" target="_blank" rel="noopener noreferrer">Clash 使用说明<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904186715285512" target="_blank" rel="noopener noreferrer">提高 GitHub 访问速度的几种方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="header-anchor">#</a> 垃圾回收机制</h2> <p>垃圾回收方式</p> <ul><li><p>标记清除
工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p></li> <li><p>引用计数
工作原理：跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。</p></li> <li><p>致命缺陷：
用计数无法处理循环引用。比如，对象 A 引用了对象 B，同时对象 B 也引用了对象 A (A.b = B; B.a = A;)。即使这两个对象从程序的其他任何地方都不可达了（比如没有任何根对象能访问到它们），它们的引用计数永远不会变为 0（因为它们互相引用着）。这就导致它们占用的内存永远无法被回收，造成内存泄漏。标记清除算法则可以正确处理这种情况，因为它只关心对象是否从根可达。</p></li> <li><p>内存管理
什么时候触发垃圾回收？
垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。</p> <ul><li>合理的 GC 方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。</li> <li>GC 缺陷： (1)、停止响应其他操作；</li> <li>GC 优化策略： (1)、分代回收（Generation GC）;(2)、增量 GC</li></ul></li></ul> <h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <ul><li>浅拷贝,拷贝一级，如果是对象里面还有对象,无法解决
<ol><li>for… in… 循环</li> <li>Object.assgin() 缺点：非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable</li> <li>...扩展运算符</li></ol></li> <li>深拷贝
<ol><li>JSON.parse(JSON.stringify( )) 缺点：当对象的 value 是函数 或者 undefined 时会失效</li> <li>用 for…in…+递归</li></ol></li> <li>递归实现深拷贝代码
思路：</li></ul> <ol><li>创建一个空对象 一个 if 条件判断一下这个传进来的是不是个对象</li> <li>然后遍历对象 用一个 obj.hasOwnProperty(key)判断这个 key 是不是自身的属性</li> <li>如果 obj[key]还是一个对象就递归调用这个函数 如果不是对象就把他赋值给新对象</li></ol> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> objArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//定义空数组或者空对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//判断是否是对象</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//遍历数组或者对象e</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//判断当前key是不是对象自身的属性。不包括原型链</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            objArray<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            objArray<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> objArray<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="构造函数详解与总结"><a href="#构造函数详解与总结" class="header-anchor">#</a> 构造函数详解与总结</h2> <p><strong>什么是构造函数？</strong></p> <p>构造函数（Constructor Function）是 JavaScript 中用于创建对象的一种特殊函数。它主要用于在实例化对象时，初始化对象的属性和方法。</p> <ul><li>构造函数通常<strong>首字母大写</strong>，以示区别于普通函数。</li> <li>构造函数需要与 <code>new</code> 关键字一起使用。</li></ul> <p><strong>构造函数的执行流程</strong></p> <p>当使用 <code>new</code> 关键字调用构造函数时，执行过程如下：</p> <ol><li>在内存中创建一个新的空对象。</li> <li>将构造函数内部的 <code>this</code> 指向这个新对象。</li> <li>执行构造函数内的代码（给新对象添加属性和方法）。</li> <li>返回新对象（如果构造函数没有显式返回对象，则返回步骤 1 创建的对象）。</li></ol> <p><strong>构造函数的示例</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, I am &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hello, I am Alice</span>
</code></pre></div><p><strong>注意事项</strong></p> <ul><li>构造函数必须和 <code>new</code> 一起使用，否则 <code>this</code> 指向全局对象（在严格模式下为 undefined）。</li> <li>构造函数可以不用 <code>return</code> 返回值；如果返回的是非对象类型，仍然返回新对象本身；如果返回的是对象，则返回该对象。</li> <li>通过构造函数创建的多个对象实例，<strong>各自拥有独立的属性和方法</strong>。</li></ul> <p><strong>构造函数和普通函数的区别</strong></p> <table><thead><tr><th>区别</th> <th>构造函数</th> <th>普通函数</th></tr></thead> <tbody><tr><td>命名</td> <td>通常首字母大写</td> <td>通常首字母小写</td></tr> <tr><td>调用方式</td> <td>必须用 <code>new</code> 关键字调用</td> <td>直接调用</td></tr> <tr><td>this 指向</td> <td>指向新创建的对象</td> <td>由调用方式决定</td></tr> <tr><td>返回值</td> <td>默认返回新对象</td> <td>默认返回 undefined</td></tr></tbody></table> <p><strong>总结</strong></p> <ul><li>构造函数本质上就是一个普通函数，但用来创建对象实例。</li> <li>使用 <code>new</code> 关键字调用构造函数可以自动完成对象的创建和初始化。</li> <li>合理使用构造函数可以提高代码的复用性和可维护性，是 JS 面向对象编程的基础。</li></ul> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p><strong>原型（prototype）的概念</strong></p> <ul><li><p><strong>每一个函数都有一个 prototype 属性</strong></p> <ul><li>这个属性指向一个对象，称为“原型对象”。</li> <li>当函数作为构造函数（即用 <code>new</code> 创建对象）时，新创建的对象会自动拥有对这个原型对象的引用。</li></ul></li> <li><p><strong>原型对象的作用</strong></p> <ul><li>所有定义在 prototype 上的属性和方法，都会被该构造函数的实例继承和共享。</li> <li>适合将不变（公用）的属性和方法定义在 prototype 上，节省内存，提高复用性。</li></ul></li> <li><p><strong>this 的指向</strong></p> <ul><li>在构造函数内部，<code>this</code> 指向实例对象。</li> <li>在原型对象内部，<code>this</code> 也指向调用该方法的实例对象。</li></ul></li> <li><p><strong>示例代码</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, I am &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hello, I am Alice</span>
</code></pre></div></li></ul> <hr> <p><strong>原型链的概念</strong></p> <ul><li><p><strong>什么是原型链？</strong></p> <ul><li>原型链是 JavaScript 实现继承的主要机制。</li> <li>每个对象都有一个内部属性 <code>__proto__</code>（标准写法为 [[Prototype]]），指向它的原型对象。</li> <li>多个对象通过 <code>__proto__</code> 属性串联在一起，形成链状结构，称为“原型链”。</li></ul></li> <li><p><strong>查找规则</strong></p> <ul><li>当访问一个对象的属性或方法时，如果对象本身没有，就会去它的原型对象（即 <code>__proto__</code> 指向的对象）查找。</li> <li>如果原型对象也没有，再继续沿着它的 <code>__proto__</code> 查找，直到找到 <code>Object.prototype</code>，其 <code>__proto__</code> 为 <code>null</code>，原型链到此结束。</li></ul></li> <li><p><strong>原型链结构图</strong></p> <div class="language- extra-class"><pre class="language-text"><code>实例对象  ——&gt;  构造函数.prototype  ——&gt;  Object.prototype  ——&gt;  null
    |                |                     |
    |__proto__       |__proto__            |__proto__
</code></pre></div></li> <li><p><strong>示例代码</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;eating&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bark</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;bark&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bark</span>
dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eating</span>
</code></pre></div></li></ul> <hr> <p><strong>核心要点总结</strong></p> <ul><li>每个函数都有 prototype 属性，每个对象（除 null）都有 <strong>proto</strong> 属性。</li> <li>构造函数的 prototype 上定义的方法和属性，会被所有实例共享。</li> <li>原型链让对象可以“继承”到上层原型对象的属性和方法。</li> <li>属性/方法的查找顺序：对象本身 → 原型对象 → 原型链上一层... → Object.prototype → null</li></ul> <h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="header-anchor">#</a> js 的几种模块规范</h2> <p><strong>ES Module（ESM，ES6 模块规范）</strong></p> <ul><li><p><strong>应用场景</strong>：现代浏览器和 Node.js（支持 .mjs 或 &quot;type&quot;: &quot;module&quot;）。</p></li> <li><p><strong>核心思想</strong>：JavaScript 官方标准的模块系统，静态分析，编译时确定依赖关系。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>使用 <code>export</code> 导出，<code>import</code> 导入。</p></li> <li><p>支持异步和静态引入，最适合前端工程化。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./a.js&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 'bar'</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>CommonJS</strong></p> <ul><li><p><strong>应用场景</strong>：主要用于 Node.js 服务器端开发。</p></li> <li><p><strong>核心思想</strong>：每个文件就是一个模块，模块内部通过 <code>module.exports</code> 导出成员，通过 <code>require</code> 导入模块。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>同步加载模块（适合服务器，文件都在本地）。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./a.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 'bar'</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>AMD（Asynchronous Module Definition）</strong></p> <ul><li><p><strong>应用场景</strong>：主要用于浏览器端，代表库有 RequireJS。</p></li> <li><p><strong>核心思想</strong>：异步加载模块，适合浏览器环境。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>使用 <code>define</code> 定义模块，<code>require</code> 加载模块。</p></li> <li><p>支持依赖前置，异步加载。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;dep1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dep2&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">dep1<span class="token punctuation">,</span> dep2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用模块</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;moduleA&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">moduleA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  moduleA<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>CMD（Common Module Definition）</strong></p> <ul><li><strong>应用场景</strong>：主要用于浏览器端，代表库有 SeaJS（国内较流行）。</li> <li><strong>核心思想</strong>：按需加载（延迟执行），依赖就近。</li> <li><strong>特点</strong>：
<ul><li>使用 <code>define</code> 定义模块，<code>require</code> 加载模块。</li> <li>依赖可以写在使用的地方，延迟执行。</li> <li>代码示例：<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;jquery&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  exports<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>总结</strong></p> <ul><li><strong>ESM</strong>：ES6 官方标准，现代浏览器和 Node.js 推荐使用。</li> <li><strong>CommonJS</strong>：服务端 Node.js 标准，同步加载。</li> <li><strong>AMD/CMD</strong>：浏览器端异步加载，前者依赖前置，后者依赖就近。</li></ul> <h3 id="commonjs-和-es6-模块的区别"><a href="#commonjs-和-es6-模块的区别" class="header-anchor">#</a> CommonJS 和 ES6 模块的区别</h3> <p><strong>加载方式</strong></p> <ul><li><strong>CommonJS</strong>：同步加载模块，适用于服务器端（如 Node.js），因为本地文件读取速度快。</li> <li><strong>ES6 Module</strong>：静态分析，编译时加载，支持异步和静态引入，适合浏览器和现代前端工程</li></ul> <p><strong>导入导出语法</strong></p> <ul><li><p><strong>CommonJS</strong></p> <ul><li>导出：<code>module.exports = ...</code> 或 <code>exports.xxx = ...</code></li> <li>导入：<code>const xxx = require('...')</code></li></ul></li> <li><p><strong>ES6 Module</strong></p> <ul><li>导出：<code>export</code> 或 <code>export default</code></li> <li>导入：<code>import { xxx } from '...'</code> 或 <code>import xxx from '...'</code></li></ul></li></ul> <p><strong>导出本质</strong></p> <ul><li><strong>CommonJS</strong>：导出的是值的<strong>拷贝</strong>（require 时会执行一遍，被缓存；后续 require 拿到缓存的对象）。</li> <li><strong>ES6 Module</strong>：导出的是<strong>引用</strong>（export 的变量和 import 的变量实时绑定，动态更新）。</li></ul> <p><strong>语法特性</strong></p> <ul><li><p><strong>CommonJS</strong></p> <ul><li>动态语法，可以在运行时任意位置调用 <code>require</code>。</li> <li>导出可以是任意类型的数据（对象、函数、字符串等）。</li></ul></li> <li><p><strong>ES6 Module</strong></p> <ul><li>静态语法，<code>import</code> 和 <code>export</code> 必须写在顶层，不能放在逻辑块或函数内部。</li> <li>支持静态分析和 Tree Shaking（按需打包）。</li></ul></li></ul> <p><strong>执行时机</strong></p> <ul><li><strong>CommonJS</strong>：模块是<strong>运行时加载</strong>，require 时同步读取、立即执行一遍。</li> <li><strong>ES6 Module</strong>：模块是<strong>编译时解析</strong>，提前确定依赖关系，提升性能。</li></ul> <p><strong>总结</strong></p> <table><thead><tr><th>对比点</th> <th>CommonJS</th> <th>ES6 Module</th></tr></thead> <tbody><tr><td>加载方式</td> <td>同步</td> <td>静态、异步支持</td></tr> <tr><td>导入导出</td> <td>require/module.exports</td> <td>import/export</td></tr> <tr><td>导出本质</td> <td>值的拷贝</td> <td>引用绑定</td></tr> <tr><td>执行时机</td> <td>运行时</td> <td>编译时</td></tr> <tr><td>this</td> <td>指向 exports</td> <td>undefined</td></tr> <tr><td>兼容性</td> <td>Node.js（服务端）</td> <td>浏览器+Node.js</td></tr></tbody></table> <h2 id="防抖节流"><a href="#防抖节流" class="header-anchor">#</a> 防抖节流</h2> <p><strong>函数的防抖（Debounce）</strong></p> <ul><li><p><strong>定义</strong>：当事件被触发后，等待一段指定时间再执行回调。如果在等待时间内事件再次被触发，则重新计时，只有最后一次触发后等待时间到了才执行。</p></li> <li><p><strong>应用场景</strong>：输入框实时搜索、窗口大小变化、滚动加载等频繁触发场景，减少无效调用。</p></li> <li><p><strong>实现示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用方式</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span>
  <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;窗口大小变化&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <p><strong>函数节流（Throttle）</strong></p> <ul><li><p><strong>定义</strong>：在指定的时间间隔内，不管事件被触发多少次，只会执行一次回调函数。</p></li> <li><p><strong>应用场景</strong>：页面滚动、按钮点击、窗口缩放等高频事件，控制函数的执行频率，提升性能。</p></li> <li><p><strong>实现示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">&gt;</span> interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用方式</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span>
  <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;页面滚动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="js-实现继承的方式有哪些"><a href="#js-实现继承的方式有哪些" class="header-anchor">#</a> js 实现继承的方式有哪些</h2> <ul><li>构造函数继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li> <li>原型链继承-----核心： 将父类的实例作为子类的原型**</li> <li>组合（混合）继承----核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li> <li>class 继承----核心：class 是 ES6 新增的语法 直接 class 创建一个类，使用 extends 来继承</li> <li>实例继承----核心：为父类实例添加新特性，作为子类实例返回</li> <li>拷贝继承-----核心：Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</li> <li>寄生组合继承----核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li></ul> <h2 id="严格模式下有哪些限制-规则"><a href="#严格模式下有哪些限制-规则" class="header-anchor">#</a> 严格模式下有哪些限制（规则）</h2> <ul><li>变量必须声明后再使用</li> <li>函数的参数不能有同名属性，否则报错</li> <li>不能使用 with 语句</li> <li>不能对只读属性赋值，否则报错</li> <li>不能使用前缀 0 表示八进制数，否则报错</li> <li>不能删除不可删除的属性，否则报错</li> <li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li> <li>eval 不会在它的外层作用域引入变量</li> <li>eval 和 arguments 不能被重新赋值</li> <li>arguments 不会自动反映函数参数的变化</li> <li>不能使用 arguments.callee</li> <li>不能使用 arguments.caller</li> <li>禁止 this 指向全局对象</li> <li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li> <li>增加了保留字（比如 protected、static 和 interface）</li></ul> <h2 id="函数缓存的方法"><a href="#函数缓存的方法" class="header-anchor">#</a> 函数缓存的方法</h2> <p><strong>基本思想</strong></p> <ul><li>当函数被调用时，先检查传入的参数是否有对应的结果已被缓存。</li> <li>如果有，直接返回缓存的结果。</li> <li>如果没有，执行计算，把结果缓存起来，下次遇到相同参数直接取用。</li></ul> <p><strong>常见实现方式</strong></p> <ul><li><p>闭包实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例：斐波那契数列</span>
<span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> memoFibonacci <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">memoFibonacci</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比直接递归快得多</span>
</code></pre></div></li></ul> <p><strong>Map 实现（更适合复杂参数）</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>应用场景</strong></p> <ul><li>递归函数（如斐波那契数列、阶乘等）</li> <li>重复计算但参数不变的复杂运算</li> <li>前端数据转换、过滤等纯函数操作</li></ul> <p><strong>注意事项</strong></p> <ul><li>适用于“纯函数”（相同参数总是返回相同结果，无副作用）</li> <li>参数复杂时需要设计好缓存 key，避免缓存污染或内存泄漏</li> <li>不适合缓存大量或不断变化的数据</li></ul> <p><strong>相关扩展</strong></p> <ul><li>Lodash 等第三方库提供了 <code>_.memoize</code> 方法</li> <li>ES6 WeakMap 可用于缓存对象参数，避免内存泄漏</li></ul> <h2 id="内存泄漏是什么-内存泄露造成的原因"><a href="#内存泄漏是什么-内存泄露造成的原因" class="header-anchor">#</a> 内存泄漏是什么 内存泄露造成的原因</h2> <p>内存泄漏也称作&quot;存储渗漏&quot;，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束
简单来说就是该内存空间使用完毕后未回收</p> <p><strong><em>内存泄露造成的原因</em></strong></p> <ol><li><p>单例模式（如果持有过多状态或引用）</p></li> <li><p>静态集合类（比如 Map, Set，如果不及时清理）</p></li> <li><p>资源未关闭（比如 WebSocket 连接、文件句柄）</p></li> <li><p>改变哈希值（可能影响 Map/Set 的查找和删除）</p></li> <li><p>缓存泄漏（缓存数据不断增长且没有清除策略）</p></li> <li><p>监听器和回调：
当你为一个 DOM 元素或其他对象（比如事件发射器）添加了事件监听器（addEventListener）或注册了回调函数后，如果这个监听器/回调函数或者它内部引用的变量（通过闭包）持有对该 DOM 元素或其他不再需要的对象的引用，并且你忘记在适当的时候移除这个监听器/回调，就会发生内存泄漏</p></li> <li><p>不合理使用闭包（我们之前讨论过）</p></li> <li><p>函数柯里化（如果创建过多中间函数且未被释放）</p></li></ol> <h2 id="函数柯里化"><a href="#函数柯里化" class="header-anchor">#</a> 函数柯里化</h2> <p>柯里化（Currying）
柯里化（Currying）是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。</p> <p>柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。</p> <p>柯里化不会调用函数。它只是对函数进行转换。</p> <p>让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。</p> <p>我们将创建一个辅助函数 curry(f)，该函数将对两个参数的函数 f 执行柯里化。换句话说，对于两个参数的函数 f(a, b) 执行 curry(f) 会将其转换为以 f(a)(b) 形式运行的函数：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// curry(f) 执行柯里化转换</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用法</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><p>正如你所看到的，实现非常简单：只有两个包装器（wrapper）。</p> <p>curry(func) 的结果就是一个包装器 function(a)。
当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。
然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。
柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用来自 lodash 库的 _.curry</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3，仍可正常调用</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3，以偏函数的方式调用</span>
</code></pre></div><p>柯里化？目的是什么？
要了解它的好处，我们需要一个实际中的例子。</p> <p>例如，我们有一个用于格式化和输出信息的日志（logging）函数 log(date, importance, message)。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 alert：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">date<span class="token punctuation">,</span> importance<span class="token punctuation">,</span> message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>date<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>date<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] [</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>importance<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//让我们将它柯里化！</span>

log <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 柯里化之后，log 仍正常运行：</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;some debug&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// log(a, b, c)</span>

<span class="token comment">// ……但是也可以以柯里化形式运行：</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;some debug&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// log(a)(b)(c)</span>

<span class="token comment">// 现在，我们可以轻松地为当前日志创建便捷函数：</span>

<span class="token comment">// logNow 会是带有固定第一个参数的日志的偏函数</span>
<span class="token keyword">let</span> logNow <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用它</span>
<span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&quot;INFO&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] INFO message</span>

<span class="token comment">// 现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。</span>

<span class="token comment">// 我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：</span>

<span class="token keyword">let</span> debugNow <span class="token operator">=</span> <span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">debugNow</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] DEBUG message</span>
</code></pre></div><p>所以：</p> <p>柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。
我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。
高级柯里化实现
如果你想了解更多细节，下面是用于多参数函数的“高级”柯里化实现，我们也可以把它用于上面的示例。</p> <p>它非常短：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> func<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// 用例：</span>

<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，仍然可以被正常调用</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，对第一个参数的柯里化</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，全柯里化</span>

<span class="token comment">// 新的 curry 可能看上去有点复杂，但是它很容易理解。</span>

<span class="token comment">// curry(func) 调用的结果是如下所示的包装器 curried：</span>

<span class="token comment">// func 是要转换的函数</span>
<span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> func<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (1)</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (2)</span>
      <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当我们运行它时，这里有两个 if 执行分支：</p> <p>如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，那么只需要使用 func.apply 将调用传递给它即可。
否则，获取一个偏函数：我们目前还没调用 func。取而代之的是，返回另一个包装器 pass，它将重新应用 curried，将之前传入的参数与新的参数一起传入。
然后，如果我们再次调用它，我们将得到一个新的偏函数（如果没有足够的参数），或者最终的结果。</p> <p>只允许确定参数长度的函数</p> <p>柯里化要求函数具有固定数量的参数。</p> <p>使用 rest 参数的函数，例如 f(...args)，不能以这种方式进行柯里化。</p> <p>比柯里化多一点</p> <p>根据定义，柯里化应该将 sum(a, b, c) 转换为 sum(a)(b)(c)。</p> <p>但是，如前所述，JavaScript 中大多数的柯里化实现都是高级版的：它们使得函数可以被多参数变体调用。</p> <p>总结
柯里化 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。</p> <p>柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。</p> <h2 id="for-in-for-of-的区别"><a href="#for-in-for-of-的区别" class="header-anchor">#</a> for in. for of 的区别</h2> <h3 id="核心区别"><a href="#核心区别" class="header-anchor">#</a> 核心区别</h3> <ul><li><strong>for...in</strong> 是为<strong>遍历对象</strong>而设计的，它遍历的是对象的**“键”（key）**（并且是字符串类型）。</li> <li><strong>for...of</strong> (ES6 新增) 是为<strong>遍历可迭代对象</strong>（如数组、Map、Set、String）而设计的，它遍历的是**“值”（value）**。</li></ul> <hr> <h3 id="详细对比"><a href="#详细对比" class="header-anchor">#</a> 详细对比</h3> <table><thead><tr><th><strong>特性</strong></th> <th><strong>for...in</strong></th> <th><strong>for...of</strong></th></tr></thead> <tbody><tr><td><strong>遍历目标</strong></td> <td>对象的<strong>可枚举属性键 (key)</strong></td> <td><strong>可迭代对象</strong>的<strong>值 (value)</strong></td></tr> <tr><td><strong>返回值</strong></td> <td><code>string</code> (属性名或数组索引)</td> <td>元素的值 (任意类型)</td></tr> <tr><td><strong>适用对象</strong></td> <td>任何对象 (最常用于普通 <code>Object</code>)</td> <td><strong>可迭代对象</strong> (如 <code>Array</code>, <code>String</code>, <code>Map</code>, <code>Set</code>)</td></tr> <tr><td><strong>原型链</strong></td> <td><strong>会</strong> 遍历原型链上的属性</td> <td><strong>不会</strong> 遍历原型链</td></tr> <tr><td><strong>迭代顺序</strong></td> <td>不保证顺序 (尤其对对象)</td> <td>按迭代器定义的顺序 (如数组索引)</td></tr></tbody></table> <hr> <h3 id="for-in-的主要缺点"><a href="#for-in-的主要缺点" class="header-anchor">#</a> for...in 的主要缺点</h3> <h4 id="_1-它会遍历原型链-最致命的缺点"><a href="#_1-它会遍历原型链-最致命的缺点" class="header-anchor">#</a> 1. 它会遍历原型链 (最致命的缺点)</h4> <p>这是 <code>for...in</code> 最大的问题。它不仅会遍历对象<strong>自身</strong>的属性，还会遍历其<strong>原型链</strong>上所有可枚举的属性。</p> <p><strong>示例：</strong></p> <p>JavaScript</p> <div class="language- extra-class"><pre class="language-text"><code>// 修改所有 Object 的原型
Object.prototype.iAmOnThePrototype = &quot;Hello&quot;;

const myObject = { a: 1, b: 2 };

for (const key in myObject) {
  console.log(key); // 会输出: 'a', 'b', 'iAmOnThePrototype'
}
</code></pre></div><p>如何修复：</p> <p>为了避免这个问题，当（且仅当）你必须使用 for...in 遍历一个普通对象时，必须在循环体内部使用 Object.prototype.hasOwnProperty.call() 或 myObject.hasOwnProperty() 来过滤掉原型链上的属性。</p> <p>JavaScript</p> <div class="language- extra-class"><pre class="language-text"><code>for (const key in myObject) {
  if (Object.prototype.hasOwnProperty.call(myObject, key)) {
    console.log(key); // 只会输出: 'a', 'b'
  }
}
</code></pre></div><h4 id="_2-返回的键-索引-是字符串类型"><a href="#_2-返回的键-索引-是字符串类型" class="header-anchor">#</a> 2. 返回的键（索引）是字符串类型</h4> <p>当 <code>for...in</code> 用于遍历数组时，它返回的索引 <code>i</code> 是<strong>字符串</strong> <code>'0'</code>, <code>'1'</code>, <code>'2'</code>... 这在进行数学运算时会导致错误。</p> <p><strong>示例：</strong></p> <p>JavaScript</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [10, 20, 30];
for (const i in arr) {
  console.log(i + 1); // 会输出: '01', '11', '21' (字符串拼接)
}

// for...of (或 forEach) 就没有这个问题
for (const value of arr) {
  console.log(value + 1); // 会输出: 11, 21, 31 (数学运算)
}
</code></pre></div><h4 id="_3-不保证迭代顺序"><a href="#_3-不保证迭代顺序" class="header-anchor">#</a> 3. 不保证迭代顺序</h4> <p>规范没有保证 <code>for...in</code> 会按特定顺序（如数字索引顺序或属性插入顺序）返回键。虽然大多数现代浏览器会按顺序遍历数组索引，但在遍历普通对象时，顺序是不可靠的。</p> <p><strong>因此，它绝对不应该被用来遍历数组。</strong></p> <hr> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li><strong>用 for...in</strong>： <strong>只用于</strong>遍历一个普通的、非数组的 <code>Object</code>，目的是获取它的<strong>键 (key)</strong>，并且<strong>必须</strong>配合 <code>hasOwnProperty</code> 使用。</li> <li><strong>用 for...of</strong>： 用于遍历<strong>可迭代对象</strong>（<code>Array</code>, <code>String</code>, <code>Map</code>, <code>Set</code>, <code>NodeList</code> 等）的<strong>值 (value)</strong>。这是遍历数组最现代、最推荐的方式（如果您不使用 <code>.forEach()</code> 或 <code>.map()</code> 的话）。</li></ul> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <h3 id="map-循环展示添加-key"><a href="#map-循环展示添加-key" class="header-anchor">#</a> map 循环展示添加 key</h3> <ul><li><strong>原理：</strong> <code>key</code> 是 React 用来追踪同级元素列表（list）中各个元素的“身份证”。在数据更新、列表发生变化时，React 的 Diff 算法会使用 <code>key</code> 来“匹配”新旧两个列表中的元素，以最小化 DOM 操作。</li> <li><strong>优点：</strong> 提供了高效的 DOM-Diff。通过 <code>key</code>，React 可以准确地知道哪些元素是新增的、删除的、还是仅仅移动了位置。这避免了不必要的 DOM 重建（unmount/mount），保证了更新效率，并能正确保留组件的状态（如 <code>input</code> 框的输入内容）。</li> <li><strong>缺点：</strong> 最大的“缺点”来自于<strong>错误使用</strong>。如果使用不稳定的 <code>key</code>（如 <code>Math.random()</code>）会导致性能更差。如果使用数组的 <code>index</code> 作为 <code>key</code>，在列表项顺序会改变（如排序、在中间插入/删除）的场景下，会导致 Diff 错乱，引发 Bug 和性能问题。</li></ul> <h3 id="路由懒加载-route-lazy-loading"><a href="#路由懒加载-route-lazy-loading" class="header-anchor">#</a> 路由懒加载 (Route Lazy Loading)</h3> <ul><li><strong>原理：</strong> 这是一种<strong>代码切割 (Code Splitting)</strong> 的核心应用。它利用了 ES 模块的<strong>动态导入 import()</strong> 语法。构建工具（如 Webpack/Vite）在打包时，会把动态导入的模块（即路由组件）分离成一个独立的 JS &quot;chunk&quot; 文件。</li> <li><strong>优点：</strong> 显著减小了<strong>主包（main bundle）的体积</strong>。用户首次访问时，只需下载主包和当前路由的 JS 文件，无需一次性加载整个应用的所有页面代码，这使得<strong>首屏加载速度（FCP/LCP）</strong> 极大提升。</li> <li><strong>缺点：</strong> 会带来一个微小的**“切换”成本**。当用户第一次跳转到某个懒加载的路由时，需要临时去网络请求该路由的 JS chunk，这会有一个短暂的加载延迟（通常会用 loading 动画覆盖）。</li></ul> <h3 id="第三方插件按需引入"><a href="#第三方插件按需引入" class="header-anchor">#</a> 第三方插件按需引入</h3> <ul><li><strong>原理：</strong> 现代前端库（如 Ant Design, ECharts, Lodash）通常会提供 ES Module (ESM) 规范的构建产物。按需引入（或称“摇树优化”，Tree Shaking）依赖于 ESM 的<strong>静态分析</strong>特性。构建工具在打包时，会分析 <code>import</code>/<code>export</code> 语句，只把代码中<strong>实际使用到</strong>的函数或模块打包进来，未被引用的代码（Dead Code）则会被删除。</li> <li><strong>优点：</strong> 极大减少了打包体积，特别是对于大型的 UI 库或工具库。例如，只 import 一个 <code>Button</code> 组件，就无需打包整个 UI 库的其他几十个组件，性能提升明显。</li> <li><strong>缺点：</strong> 这种优化<strong>强依赖于库本身的支持</strong>。如果一个库不是用 ESM 编写的，或者其代码有“副作用”（side effects），构建工具就很难安全地进行 Tree Shaking，导致优化失败。</li></ul> <h3 id="使用-purecomponent-react-memo-scu"><a href="#使用-purecomponent-react-memo-scu" class="header-anchor">#</a> 使用 PureComponent/React.memo (SCU)</h3> <ul><li><strong>原理：</strong> 这是 React 性能优化中的**“渲染节流”<strong>手段。当父组件重新渲染时，默认会“递归”渲染其所有子组件。PureComponent (用于 Class) 和 React.memo (用于函数组件) 会在组件渲染前，自动对其新旧 props 进行一次</strong>浅比较（Shallow Compare）**。</li> <li><strong>优点：</strong> 如果浅比较发现所有 <code>props</code> 都没有变化，React 就会<strong>跳过（Skip）</strong> 这个组件的本次渲染（re-render）及其所有子树的渲染，从而避免了大量不必要的 VDOM-Diff 和 DOM 操作，是提升复杂应用响应速度的关键。</li> <li><strong>缺点：</strong> <strong>浅比较本身是有成本的</strong>。如果一个组件的 <code>props</code> 总是会变化，或者组件本身非常轻量，使用它们反而会增加“比较”这一步的额外开销。同时，它只能“浅比较”，如果 <code>props</code> 传递了复杂对象，并且父组件中总是创建新对象（即使内容相同），会导致 <code>memo</code> 优化失效。</li></ul> <h3 id="使用-usememo-usecallback"><a href="#使用-usememo-usecallback" class="header-anchor">#</a> 使用 useMemo/useCallback</h3> <ul><li><strong>原理：</strong> <code>useMemo</code> 和 <code>useCallback</code> 是 React Hooks 中实现**“记忆化”<strong>的工具。useMemo 缓存一个</strong>计算结果**（值），<code>useCallback</code> 缓存一个<strong>函数实例</strong>。它们都接受一个依赖项数组，只有当依赖项变化时，才会重新计算值或创建新的函数实例。</li> <li><strong>优点：</strong> 主要用于配合 <code>React.memo</code>。当把一个函数（<code>useCallback</code>）或一个对象（<code>useMemo</code>）作为 <code>prop</code> 传递给一个被 <code>memo</code> 的子组件时，它可以保证在父组件重渲染时，传递给子组件的 <code>prop</code> 引用地址不变，从而<strong>命中 memo 的浅比较</strong>，防止子组件不必要的重渲染。<code>useMemo</code> 也可以用于跳过昂贵的计算。</li> <li><strong>缺点：</strong> <strong>滥用会导致性能下降和代码复杂化</strong>。Memoization 本身需要占用内存来“缓存”结果，并且每次渲染都要检查依赖项数组。如果无脑地把所有函数都用 <code>useCallback</code> 包裹，会增加不必要的开销，并可能因为错误的依赖项数组导致“闭包陷阱”或数据陈旧（Stale Data）的 Bug。</li></ul> <h3 id="图片和静态资源优化"><a href="#图片和静态资源优化" class="header-anchor">#</a> 图片和静态资源优化</h3> <ul><li><strong>原理：</strong> 图片资源通常是 Web 页面上“最重”的资产。此优化包含：
<ol><li><strong>格式选择</strong>（使用 <code>WebP</code> 或 <code>AVIF</code> 等现代格式）。</li> <li><strong>压缩</strong>（在不严重损失画质的前提下减小文件体积）。</li> <li><strong>懒加载</strong>（使用 <code>loading=&quot;lazy&quot;</code> 属性，使视口外的图片在滚动到时才加载）。</li> <li><strong>使用 srcset</strong> 提供不同分辨率的图片以适配不同设备。</li></ol></li> <li><strong>优点：</strong> 极大降低页面总的加载字节数，显著提升加载速度，并节省用户流量。</li> <li><strong>缺点：</strong> 懒加载可能导致图片在滚动时“突然出现”，需要配合占位符或骨架屏来优化体验。图片压缩需要找到质量和体积的平衡点。</li></ul> <h3 id="防抖节流-2"><a href="#防抖节流-2" class="header-anchor">#</a> 防抖节流</h3> <ul><li><strong>原理：</strong> 针对高频触发的事件（如 <code>resize</code>, <code>scroll</code>, <code>input</code>）进行函数执行频率的控制。<strong>防抖 (Debounce)</strong> 指的是“触发事件后，在 N 秒内没有再次触发，才执行”，常用于搜索框输入。<strong>节流 (Throttle)</strong> 指的是“在 N 秒内，最多只执行一次”，常用于滚动事件监听。</li> <li><strong>优点：</strong> 极大地减少了高频事件处理函数的执行次数，避免了在短时间内大量计算或发送 API 请求，防止了页面卡顿 (Jank) 和资源浪费。</li> <li><strong>缺点：</strong> 会引入轻微的“延迟”感。例如，防抖必须等待用户停止输入，而节流则会“舍弃”掉在时间间隔内的某些事件点，选择合适的延迟时间非常关键。</li></ul> <h3 id="启用-gzip-brotli-压缩"><a href="#启用-gzip-brotli-压缩" class="header-anchor">#</a> 启用 Gzip/Brotli 压缩</h3> <ul><li><strong>原理：</strong> 这是一种 <strong>HTTP 传输层</strong>的优化。客户端（浏览器）在请求头中声明 <code>Accept-Encoding: gzip, brotli</code>，如果服务器（如 Nginx）配置了压缩，它会在响应前，将文本类资源（JS, CSS, HTML）使用 Gzip 或 Brotli 算法进行压缩，生成一个体积小得多的文件。浏览器接收后再解压。</li> <li><strong>优点：</strong> Brotli 通常比 Gzip 有更高的压缩率（体积更小）。这种方式可以显著减少 60%-80% 的文本资源下载体积，极大提升下载速度。</li> <li><strong>缺点：</strong> 压缩和解压<strong>会消耗少量的 CPU 资源</strong>（服务器的压缩成本和浏览器的解压成本）。但这点消耗相比于网络传输时间的减少几乎可以忽略不计。它只对文本文件有效，对图片、视频等已压缩过的二进制文件无效。</li></ul> <h3 id="虚拟滚动"><a href="#虚拟滚动" class="header-anchor">#</a> 虚拟滚动</h3> <ul><li><strong>原理：</strong> 当需要渲染一个超长列表（如几千条、几万条数据）时，不把所有列表项全部渲染到 DOM 中。虚拟滚动技术只渲染<strong>当前视口（Viewport）中可见</strong>的列表项（以及上下几条作为缓冲区）。当用户滚动时，它会动态计算并替换视口中的 DOM 元素，模拟出滚动的效果。</li> <li><strong>优点：</strong> 使得渲染“无限”长列表成为可能。无论列表多长，DOM 中始终只有少量（如几十个）节点，保持了极高的渲染性能和内存占用，避免页面崩溃。</li> <li><strong>缺点：</strong> 实现起来相对复杂，需要精确计算项目高度、滚动位置等。如果列表项高度不固定，计算会更复杂。同时，可能会影响页面的“查找”（Ctrl+F）功能和滚动条的准确性（需要用库如 <code>react-window</code> 来解决）。</li></ul> <h3 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h3> <ul><li><strong>原理：</strong> 通过配置 HTTP 响应头（Response Headers），指示浏览器如何缓存资源。分为<strong>强缓存</strong>（<code>Cache-Control: max-age=...</code>）和<strong>协商缓存</strong>（<code>ETag</code> / <code>Last-Modified</code>）。</li> <li><strong>优点：</strong> 对于强缓存的资源（如带 hash 的 JS/CSS），浏览器在缓存有效期内<strong>完全不会发送网络请求</strong>，直接从本地磁盘读取，速度最快。对于协商缓存的资源（如 <code>index.html</code>），浏览器会发送请求，但如果服务器判断资源未变（304 Not Modified），浏览器也只需使用本地副本，节省了下载时间。</li> <li><strong>缺点：</strong> 缓存配置是优化的“双刃剑”。如果配置不当（例如，对入口 <code>index.html</code> 设置了过长的强缓存），会导致<strong>应用发布新版后，用户无法及时更新</strong>，看到的是旧的页面或资源错乱。</li></ul> <h2 id="http1-http2-http3-的核心演进"><a href="#http1-http2-http3-的核心演进" class="header-anchor">#</a> HTTP1, HTTP2, HTTP3 的核心演进</h2> <p>这是一个“解决问题”的演进史，核心目标始终是：<strong>更快、更高效</strong>。</p> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP/1.1</h3> <ul><li><strong>核心思想：</strong> 基于文本的“请求-响应”模式。</li> <li><strong>工作机制：</strong> <ul><li>浏览器为了并发，会“被迫”开启 6-8 个 TCP 连接。</li> <li><strong>关键问题 (应用层队头阻塞)：</strong> 在<strong>同一个 TCP 连接</strong>上，请求必须“排队”。如果第一个请求（比如一个大图片）非常慢，那么这个连接上的后续请求（比如 CSS/JS）就<strong>必须等待</strong>，即使它们很小。</li></ul></li> <li><strong>目的/作用：</strong> 这是 Web 发展的基础，但它“慢”且“浪费”连接。</li></ul> <h3 id="http-2-99-的现代网站"><a href="#http-2-99-的现代网站" class="header-anchor">#</a> HTTP/2 (99% 的现代网站)</h3> <ul><li><strong>核心思想：</strong> 解决 HTTP/1.1 的“排队”问题。</li> <li><strong>工作机制：</strong> <ul><li><strong>多路复用：</strong> <strong>所有请求</strong>都运行在<strong>一个 TCP 连接</strong>上。</li> <li><strong>二进制“流”：</strong> 请求被拆分成“帧”，交错地在同一个连接上传输。</li> <li><strong>头部压缩 (HPACK)：</strong> 大幅减少重复的 Header。</li></ul></li> <li><strong>目的/作用 (解决的问题)：</strong> <ul><li>它完美解决了 HTTP/1.1 的**“应用层”**队头阻塞。100 个请求可以同时发出，互不排队。</li></ul></li> <li><strong>关键点/陷阱 (暴露的新问题)：</strong> <ul><li>它暴露了更底层的**“TCP 传输层”队头阻塞**。</li> <li>因为所有“流”都跑在<strong>一个</strong> TCP 连接上，而 TCP 协议本身要求<strong>严格保序</strong>。如果网络中<strong>丢失了一个 TCP 数据包</strong>，TCP 协议会<strong>强制“暂停”所有流</strong>，等待那个丢失的包被重传。</li> <li>结果：一个丢包（比如来自图片的流）会卡住所有其他流（比如 JS 和 CSS）。</li></ul></li></ul> <h3 id="http-3"><a href="#http-3" class="header-anchor">#</a> HTTP/3</h3> <ul><li><strong>核心思想：</strong> 彻底解决“TCP 传输层”的队头阻塞。</li> <li><strong>工作机制：</strong> <ul><li><strong>抛弃 TCP：</strong> 它不再使用 TCP，而是基于 <strong>UDP</strong> 协议，并在其上构建了一个新的可靠协议：<strong>QUIC</strong>。</li> <li><strong>QUIC 内置了“流”：</strong> QUIC 的“流”是<strong>真正独立</strong>的。</li> <li><strong>连接迁移：</strong> 内置加密 (TLS 1.3)，握手更快 (0-RTT)；并且不依赖 IP，切换 WiFi/4G 时连接<strong>不会断</strong>。</li></ul></li> <li><strong>目的/作用 (解决的问题)：</strong> <ul><li><strong>彻底解决了队头阻塞</strong>。</li> <li><strong>场景：</strong> 如果一个“流”（图片）的数据包丢失了，它<strong>只会</strong>阻塞那一个流。其他流（JS, CSS）的数据包可以被正常接收和处理，<strong>完全不受影响</strong>。</li></ul></li> <li><strong>关键点/陷阱：</strong> QUIC 运行在 UDP 上，这可能在一些老的网络防火墙上遇到支持问题（但这个问题正被快速解决）。</li></ul> <hr></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.f81cf313.js" defer></script><script src="/jiabinxu-blog/assets/js/3.bb87b8ff.js" defer></script><script src="/jiabinxu-blog/assets/js/2.180c3171.js" defer></script><script src="/jiabinxu-blog/assets/js/30.2e981bab.js" defer></script>
  </body>
</html>
