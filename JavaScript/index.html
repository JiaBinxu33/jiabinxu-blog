<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.ec81c2a4.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.c5fdad7d.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.34d20650.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/32.8f6a39a4.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.90fb1753.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.b39679df.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.8187523c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.0bc8e462.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.ccfaad73.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.cec46538.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.380c784d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.bfab453a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.6516dd9c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.52e99ec1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.33ab9282.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.20d5488c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.da345bbd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.306efef7.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.257df29b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.b9965851.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.da12a983.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.94ca7cf0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.629923f3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.eb4c3c24.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.189b8eea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.309f3546.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.8ebea494.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.e84b982a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.e9872d14.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.13bfd9fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.d36e48f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.44ec783e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.e5568ed9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.04437602.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.05896a6c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.77566d25.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.771b0795.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.4f5d6672.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.80005314.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.13eb153e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.81101b31.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1111d26e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.4e36f15a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.426d3a06.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.0cddb7d0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.3b97796b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.ca777a9f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.8d56997f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.53a63991.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.c37f8662.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.85309368.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.e90aa37c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.37829d64.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.42652f54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.9a0bab4a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.605d1390.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.c655efdc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.f71f155e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.fe87e7ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.3e9861fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.987510dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/JavaScript/#闭包原理-优点-缺点-使用场景" class="sidebar-link">闭包原理/优点/缺点/使用场景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#promise" class="sidebar-link">promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#promise-async-await-以及两者区别" class="sidebar-link">promise async await 以及两者区别</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#设计模式-发布订阅模式-单例模式" class="sidebar-link">设计模式 - 发布订阅模式 - 单例模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#es6-新增了那些语法" class="sidebar-link">Es6 新增了那些语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#let-const-var-区别" class="sidebar-link">let const var 区别</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#箭头函数和普通函数有什么差异" class="sidebar-link">箭头函数和普通函数有什么差异？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#for-in-for-of-的区别" class="sidebar-link">for in. for of 的区别</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#异步解决方案有哪些-回调函数-callback-promise-generator" class="sidebar-link">异步解决方案有哪些？ - 回调函数 callback Promise Generator</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#什么是事件委托-什么是事件冒泡" class="sidebar-link">什么是事件委托 什么是事件冒泡</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#事件轮询" class="sidebar-link">事件轮询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#执行顺序-过程" class="sidebar-link">执行顺序/过程</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#本地存储-缓存" class="sidebar-link">本地存储 缓存</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#get-和-post-的区别" class="sidebar-link">get 和 post 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#http-请求过程" class="sidebar-link">http 请求过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#http-状态码" class="sidebar-link">http 状态码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#什么是跨域" class="sidebar-link">什么是跨域?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#null-和-undefined-区别" class="sidebar-link">null 和 undefined 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#数组去重的方法" class="sidebar-link">数组去重的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#类数组概念-怎么转换成真正的数组" class="sidebar-link">类数组概念 怎么转换成真正的数组？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-数据类型检测" class="sidebar-link">js 数据类型检测</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#this-指向哪里" class="sidebar-link">this 指向哪里</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#如何改变-this-指向" class="sidebar-link">如何改变 this 指向</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#call-apply-bind-区别" class="sidebar-link">call, apply, bind 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#常用的-git-命令" class="sidebar-link">常用的 git 命令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#git-克隆速度慢的解决办法及科学上网代理配置" class="sidebar-link">Git 克隆速度慢的解决办法及科学上网代理配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_1-问题现象" class="sidebar-link">1. 问题现象</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_2-解决办法-为-git-配置代理" class="sidebar-link">2. 解决办法：为 Git 配置代理</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_3-快速开启-关闭-git-代理-推荐-alias" class="sidebar-link">3. 快速开启/关闭 Git 代理（推荐 alias）</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_4-检查-git-代理状态" class="sidebar-link">4. 检查 Git 代理状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_5-其他说明" class="sidebar-link">5. 其他说明</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#_6-参考资料" class="sidebar-link">6. 参考资料</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#垃圾回收机制" class="sidebar-link">垃圾回收机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#构造函数详解与总结" class="sidebar-link">构造函数详解与总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-的几种模块规范" class="sidebar-link">js 的几种模块规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/JavaScript/#commonjs-和-es6-模块的区别" class="sidebar-link">CommonJS 和 ES6 模块的区别</a></li></ul></li><li><a href="/jiabinxu-blog/JavaScript/#防抖节流" class="sidebar-link">防抖节流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#js-实现继承的方式有哪些" class="sidebar-link">js 实现继承的方式有哪些</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#严格模式下有哪些限制-规则" class="sidebar-link">严格模式下有哪些限制（规则）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#函数缓存的方法" class="sidebar-link">函数缓存的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#内存泄漏是什么-内存泄露造成的原因" class="sidebar-link">内存泄漏是什么 内存泄露造成的原因</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/JavaScript/#函数柯里化" class="sidebar-link">函数柯里化</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h1> <h2 id="闭包原理-优点-缺点-使用场景"><a href="#闭包原理-优点-缺点-使用场景" class="header-anchor">#</a> 闭包原理/优点/缺点/使用场景</h2> <ol><li>什么是闭包（外层函数调用时，外层函数的函数作用域对象被内层函数引用着，无法释放，就形成了闭包。）
<ul><li>函数嵌套函数</li> <li>内层函数中使用了外层函数的变量或参数</li> <li>内层函数作为返回值返回到外部</li></ul></li> <li>优缺点
优点：
<ul><li>保护具有共享意义的变量</li> <li>隔离作用域 避免(全局)作用域污染</li> <li>为变量提供访问和操作的相关接口</li> <li>便于进行模块化开发</li> <li>减少形参个数，延长了形参的生命周期
缺点： 占用过多的资源(内存) 大量使用不利于代码优化 【解决方式：清除变量】</li></ul></li> <li>闭包的应用场景
<ul><li>通过循环给页面上多个 dom 节点绑定事件</li> <li>封装私有变量(计数器)</li> <li>延续局部变量的寿命</li> <li>高阶组件</li> <li><a href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81">函数防抖/节流</a></li> <li><a href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a></li></ul></li> <li>闭包原理
内层函数通过作用域链使用了外层函数的变量或参数，从而导致内存无法释放，需要手动设置为 null 进行清除
模块化就是以闭包为基础构建的;</li></ol> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h2> <ul><li>ES6-Promise(承诺)
Promise 异步编程的一种解决方案，比传统的解决方案（回调函数）更合理和更强大。
Promise 可以解决回调地狱的问题</li> <li>状态
Promise 对象代表一个异步操作，有三种状态：pending 进行中、fulfilled(resolve)成功、rejected 失败
Promise 一旦状态设定，就不会再变.
Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected,只要这两种情况发生，状态就凝固了。</li> <li>编写 promise</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//resolve 成功 reject 失败</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设定成功，找 promise 下面的 then 方法,resolve 传递参数值给 then</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设定失败，找 promise 下面的 catch 方法,reject 传递参数值给 catch</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>promise 原型下面两个方法</p> <ul><li>then 方法的作用：resolve 函数将 Promise 对象的状态从“未完成”变为“成功”，找 then 方法，将 resolve 函数的参数值传递给 then 方法。</li> <li>catch 方法的作用：reject 函数将 Promise 对象的状态从“ 未完成” 变为“ 失败”，找 catch 方法，将 reject 函数的参数值传递给 catch 方法。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;11111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;22222222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，所有的 promise 成功才成功，只要有一个失败了那就是失败 使用场景：发送多个请求并根据请求顺序获取和使用数据
Promise.race():是一个数组，返回一个新的 promise，第一个完成的状态就是结果状态</p> <ul><li>缺点：
一旦新建立即执行，无法中途取消
pending 状态时，无法知道当前处于哪一个状态，是开始还是结束
不设置回调，内部抛出的错误，不会反应到外部</li></ul> <h3 id="promise-async-await-以及两者区别"><a href="#promise-async-await-以及两者区别" class="header-anchor">#</a> promise async await 以及两者区别</h3> <ul><li>Promise 概念：
<ul><li>Promise 是用来做异步的，Promise 好比容器，里面存放着一些异步的事件的结果，而这些结果一旦生成是无法改变的</li> <li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题</li></ul></li> <li>async await 概念：
<ul><li>async await 也是异步编程的一种解决方案，拥有 promise 的风格，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，async 修饰过的函数也有 then 和 catch ⽅法，await 只能放在 async 中，只能修饰 promise 对象.它返回的是一个 Promise 对象。</li></ul></li> <li>两者的区别：
<ul><li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li> <li>async await 与 Promise 一样，是非阻塞的。</li> <li>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。</li></ul></li></ul> <h2 id="设计模式-发布订阅模式-单例模式"><a href="#设计模式-发布订阅模式-单例模式" class="header-anchor">#</a> 设计模式 - 发布订阅模式 - 单例模式</h2> <p>发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p> <p>发布订阅模式的基础实现</p> <div class="language-JS extra-class"><pre class="language-js"><code>  <span class="token comment">// 利用发布订阅模式实现自定义事件(买菜，买车，买房子...)</span>
  <span class="token comment">// 例如：买菜 - 买青菜，买白菜，买番茄.....</span>
  <span class="token comment">// this.message['买菜'] = [function(){买青菜},function(){买白菜}...]</span>
  <span class="token comment">// this.message['买车'] = [function(){买宝马},function(){买奔驰}...]</span>
  <span class="token comment">// this.message['买房'] = [function(){买别墅},function(){买大平层}...]</span>
  <span class="token comment">// 买菜：事件类型   +  事件处理函数</span>

  <span class="token comment">//利用Observer进行自定义事件的开发。</span>
  <span class="token comment">//添加事件 - on</span>
  <span class="token comment">//执行事件 - emit</span>
  <span class="token comment">//删除事件 - remove</span>
<span class="token keyword">class</span> <span class="token class-name">Ob</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录事件的记事本</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加事件 - on</span>
    <span class="token comment">// type:事件类型  fn:事件处理函数。 type事件类型存在追加，不存在创建。</span>
    <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//不存在创建</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//存在追加</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 执行事件 - emit</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//事件类型不存在，退出</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 删除事件 - remove - 事件类型，那个事件处理函数</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//事件类型不存在，退出</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//改变原数组</span>
          i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买奔驰&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买宝马&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买奥迪&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">fn4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;买白菜&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绑定事件</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  observer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;cai&quot;</span><span class="token punctuation">,</span> fn4<span class="token punctuation">)</span><span class="token punctuation">;</span>

  observer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除事件</span>

  observer<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;买车&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行事件</span>
  observer<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;cai&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>单例模式
单例模式就是一个实例在整个网页的生命周期里只创建一次，后续再调用实例创建函数的时候，返回的仍是之前创建的实例。在实际开发中应用十分广泛，例如页面中的登录框，显示消息的提示窗</p> <h2 id="es6-新增了那些语法"><a href="#es6-新增了那些语法" class="header-anchor">#</a> Es6 新增了那些语法</h2> <ol><li>let 和 const</li> <li>解构赋值 let{一一对应} = {一一对应}</li> <li>扩展运算符... 将数组拆分成一个一个数字的形式</li> <li>模板字符串 ``</li> <li>箭头函数 ()=&gt;{}</li> <li>promise 概述和应用</li> <li>class 面向对象的一种写法 比原型+构造函数好</li> <li>模块化 - export/import/解构赋值</li> <li>async+await promise 的语法糖</li> <li>for...of... 最好的遍历方式 不能遍历对象 遍历对象用 for in</li> <li>对象的简写风格</li></ol> <ul><li>如果属性名和属性值名称相同，写一个。</li> <li>属性值是函数可以省略 function</li></ul> <h3 id="let-const-var-区别"><a href="#let-const-var-区别" class="header-anchor">#</a> let const var 区别</h3> <ul><li><p>let 关键字</p> <ul><li>块作用域，声明的变量绑定在这个区域里面。</li> <li>不存在变量提升(暂时性死区：先声明再使用)。</li> <li>相同的作用域内不能重复声明(熟悉报错:Identifier 'a' has already been declared)</li></ul></li> <li><p>var 关键字</p> <ul><li>局部和全局作用域，函数内部是局部，函数外面是全局。</li> <li>变量提升</li> <li>相同的作用域内可以重复声明</li> <li>预解析(1.预编译 var,function 2.代码逐行执行)</li> <li>var 声明的变量也是 window 的属性</li></ul></li> <li><p>const 关键字</p> <ul><li>声明的常量值不能被改变</li> <li>对象的值不能改变，对象里面的属性可以改变的。</li> <li>使用场景(存储不变的值，存储函数，存储元素对象，存储对象)</li></ul></li></ul> <h3 id="箭头函数和普通函数有什么差异"><a href="#箭头函数和普通函数有什么差异" class="header-anchor">#</a> 箭头函数和普通函数有什么差异？</h3> <ul><li>相比普通函数更简洁的语法</li> <li>没有 this,捕获其所在上下文的 this 值，作为自己的 this 值</li> <li>不能使用 new,箭头函数作为匿名函数,是不能作为构造函数的,不能使用 new</li> <li>不绑定 arguments，用 rest 参数...解决
let test3=(...a)=&gt;{console.log(a[1])} //22</li> <li>使用 call()和 apply()调用:由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响：</li> <li>箭头函数没有原型属性</li> <li>不能简单返回对象字面量
let fun5 = ()=&gt;({ foo: x }) //如果 x =&gt; { foo: x } //则语法出错</li> <li>箭头函数不能当做 Generator 函数,不能使用 yield 关键字</li> <li>箭头函数不能换行<div class="language-JS extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">=&gt;</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//SyntaxError: Unexpected token =&gt;</span>
</code></pre></div></li> <li>使用箭头函数应该注意什么？
<ul><li>不要在对象里面定义函数，对象里面的行数应该用传统的函数方法</li> <li>不要在对原型对象上定义函数，在对象原型上定义函数也是遵循着一样的规则</li> <li>不要用箭头定义构造函数</li> <li>不要用箭头定义事件回调函数</li></ul></li></ul> <h3 id="for-in-for-of-的区别"><a href="#for-in-for-of-的区别" class="header-anchor">#</a> for in. for of 的区别</h3> <ol><li>for...in 循环：只能获得对象的键名，不能获得键值，for...of 循环：允许遍历获得键值</li> <li>对于普通对象，没有部署原生的 iterator 接口，直接使用 for...of 会报错，可以使用 for...in 循环遍历键名</li> <li>for...in 循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键。for...of 则不会这样</li> <li>无论是 for...in 还是 for...of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法</li></ol> <h2 id="异步解决方案有哪些-回调函数-callback-promise-generator"><a href="#异步解决方案有哪些-回调函数-callback-promise-generator" class="header-anchor">#</a> 异步解决方案有哪些？ - 回调函数 callback Promise Generator</h2> <ul><li>回调函数 callback：回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。</li> <li>事件发布订阅:消耗内存，过度使用会使代码难以维护和理解</li> <li>Promise:无法取消 promise。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 Pending 状态时，无法得知目前进展到哪一个阶段</li> <li>Generator:Generator 是 es6 提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用 yield 语句。Generaotr 函数会返回一个遍历器，可以进行遍历操作执行每个中断点 yield,不能自动执行异步操作，需要写多个 next()方法.</li> <li>async/await:es2017 引入的异步操作解决方案，可以理解为 Generator 的语法糖，最重要的好处是同步编程风格,async 函数返回一个 Promise。内置执行器，比 Generator 操作更简单。async/await 比*yield 语义更清晰。返回值是 Promise 对象，可以用 then 指定下一步操作。代码更整洁。可以捕获同步和异步的错误。</li></ul> <h2 id="什么是事件委托-什么是事件冒泡"><a href="#什么是事件委托-什么是事件冒泡" class="header-anchor">#</a> 什么是事件委托 什么是事件冒泡</h2> <ul><li><p>事件流：事件流就是事件冒泡和事件捕获</p></li> <li><p>事件冒泡：事件开始时由最具体的元素接收(操作元素)，然后逐级向上传播到较为不具体的节点,一直到文档 document</p></li> <li><p>事件捕获：反过来从最不具体的到最具体的</p></li> <li><p>事件委托就是将自身要添加的事件委托给其他元素 从而实现相同的效果
原生 js 里面添加事件委托是 addEventListener 移出是 removeEventListener</p></li> <li><p>事件委托的优缺点：</p> <ul><li>优点：减少事件注册次数，节约内存，提升性能。</li> <li>缺点：所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</li></ul></li></ul> <h2 id="事件轮询"><a href="#事件轮询" class="header-anchor">#</a> 事件轮询</h2> <p><strong>核心定义：事件循环是主线程的工作基石</strong></p> <p>事件循环（Event Loop），也称消息循环（Message Loop），是浏览器渲染主线程的核心工作机制。其本质可以理解为一个永不停止的 for 循环，持续地从“任务队列”中取出任务来执行。其他线程（如处理定时器、网络请求的线程）负责在任务完成后，将相应的回调任务放入任务队列中，等待主线程的调度。</p> <ul><li><p>宏任务 (Macrotask):</p> <ul><li>JavaScript 的同步代码</li> <li>I/O 操作</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li> <li>requestAnimationFrame</li></ul></li> <li><p>微任务 (Microtask):</p> <ul><li>Promise (具体如 Promise.then, catch 和 finally)</li> <li>process.nextTick</li> <li>MutationObserver</li></ul></li></ul> <h3 id="执行顺序-过程"><a href="#执行顺序-过程" class="header-anchor">#</a> 执行顺序/过程</h3> <ol><li><p>执行同步代码（宏任务）： 事件循环开始，首先会执行主线程上的同步代码。比如 console.log('script start') 会被立即执行。</p></li> <li><p>分发异步任务： 在执行同步代码的过程中，如果遇到异步任务，主线程会把它们分发出去。</p> <ul><li>比如 setTimeout，它的回调会被放到一个“宏任务”（macrotask）队列中。</li> <li>比如 Promise.then，它的回调会被放到“微队列”（microtask queue）中。</li></ul></li> <li><p>同步代码执行完毕： 当主线程的同步代码（即当前的第一个宏任务）全部执行完毕后，主线程会立即检查微队列。</p></li> <li><p>清空微队列（Microtask Checkpoint）： 这是最关键的一步。主线程会查看微队列，如果里面有任务，主线程会一次性将微队列中的所有任务全部执行完毕。如果在执行微任务的过程中，又产生了新的微任务，那么这些新的微任务也会被加到微队列的末尾，并在这个同一个阶段被执行，直到微队列被彻底清空为止。</p></li> <li><p>执行下一个宏任务： 只有在微队列被完全清空之后，事件循环才会去宏任务队列中取出一个任务来执行。</p></li> <li><p>重复循环： 当这个宏任务（setTimeout 回调）执行完毕后，事件循环会再次重复第 4 步：立即检查微队列，清空所有微任务。然后再去执行第 5 步：取下一个宏任务。</p></li></ol> <p><strong>模型的演进：告别简单的“宏/微任务”二分法</strong></p> <p>过去常将任务队列简单地分为“宏队列”（Macrotask Queue）和“微队列”（Microtask Queue）。但在现代复杂的浏览器环境下，这种二分法已不再适用。现代浏览器采用了更灵活、精细的多队列任务处理模型。</p> <p><strong>现代 W3C 模型：多队列与优先级调度</strong></p> <p>根据 W3C 官方规范，现代事件循环的任务调度遵循以下原则：</p> <ul><li>浏览器内部存在多个任务队列，每个任务按类型（如用户交互、渲染、网络等）划分到不同队列。</li> <li>不同队列拥有不同优先级，由浏览器根据当前页面状态智能调度。</li> <li>微队列（Microtask Queue）拥有绝对最高优先级，在每次事件循环中只要微队列有任务，必须全部执行完后再处理其他队列任务。</li></ul> <p><strong>执行过程实例分析</strong></p> <p>下面用一个具体的例子，详细说明现代浏览器事件循环的执行过程：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;microtask1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;microtask2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行流程及输出分析：</p> <ol><li>首先同步执行主线程中的代码，输出：<div class="language- extra-class"><pre class="language-text"><code>script start
script end
</code></pre></div></li> <li><code>setTimeout</code> 的回调被放入 macrotask 队列。</li> <li><code>Promise.then</code> 的回调被加入微队列（microtask queue）。</li> <li>主线程同步任务执行完毕，事件循环开始下一个阶段。</li> <li>检查微队列，发现有两个微任务，按照顺序依次全部执行，输出：<div class="language- extra-class"><pre class="language-text"><code>microtask1
microtask2
</code></pre></div></li> <li>微队列执行完毕，事件循环继续处理 macrotask 队列中的任务，即 setTimeout 的回调，输出：<div class="language- extra-class"><pre class="language-text"><code>timeout
</code></pre></div></li></ol> <p>最终输出顺序为：</p> <div class="language- extra-class"><pre class="language-text"><code>script start
script end
microtask1
microtask2
timeout
</code></pre></div><p>这个例子清晰地展现了微队列在事件循环中的绝对优先级：只要微队列有任务，主线程会优先全部执行完微任务，然后再去处理其他类型的任务队列。这正是现代浏览器事件循环模型的核心特征。</p> <h2 id="本地存储-缓存"><a href="#本地存储-缓存" class="header-anchor">#</a> 本地存储 缓存</h2> <ul><li>存储大小
cookie 数据大小不能超过 4k。
sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li> <li>有效时间
localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage 数据在当前浏览器窗口关闭后自动删除。
cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li> <li>数据与服务器之间的交互方式
cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端
sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li></ul> <p>cookie 验证不安全易遭到 CSRF 攻击：
当你当前网站没有退出，而恰好漏洞网站又已你当前网站为漏洞，并添加转账信息或各种增删改查信息等，你的数据就会被篡改，导致不安全，CSRF 攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式。
方法：
通常使用 Anti CSRF Token 来防御 CSRF 攻击，同时要注意 Token 的保密性和随机性。</p> <ul><li>尽量使用 POST，限制 GET</li> <li>将 cookie 设置为 HttpOnly</li> <li>增加 token</li> <li>并且 CSRF 攻击问题一般是由服务端解决。</li></ul> <h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> get 和 post 的区别</h2> <ul><li>语义化：get 获取 post 传输</li> <li>数据长度：get 地址栏，地址栏仅能传输 2000 多个字符，post 理论上无限。</li> <li>安全性：get 不安全，地址栏显示，post 安全。</li> <li>传输数据：get 通过地址栏?和&amp; post 通过请求头和 send 方法</li> <li>缓存问题：get 有缓存，post 没有缓存。
清除缓存：浏览器设置 - 清除数据。 快捷方式：ctrl+h 左侧查看清除按钮</li></ul> <h2 id="http-请求过程"><a href="#http-请求过程" class="header-anchor">#</a> http 请求过程</h2> <p>用户输入网址 → 域名解析 → 建立连接 → 发送 HTTP 请求 → 服务器处理 → 返回响应 → 浏览器渲染
http 请求流程
浏览器端，客户端，前端</p> <ul><li>用户在浏览器地址栏输入域名
例如输入：https://www.taobao.com</li> <li>域名解析（DNS 解析）
浏览器首先检查本地缓存（浏览器 DNS 缓存、操作系统 DNS 缓存）是否有该域名的 IP 地址。
如果没有，则向本地 DNS 服务器发起请求，逐级递归或迭代查询，最终获取到 www.taobao.com 对应的 IP 地址。
域名和服务器的 IP 地址建立绑定关系。</li> <li>建立 TCP 连接（三次握手）
浏览器和目标服务器（如淘宝服务器）在目标端口（通常是 80/443）上建立 TCP 连接。
HTTPS 协议还会有 TLS/SSL 握手过程，协商加密方式和密钥。</li> <li>浏览器向服务器发送 HTTP 请求
包括请求方法（GET/POST 等）、请求头（headers）、请求体（body，POST 时有）等。
服务器处理请求，返回响应
服务器收到请求后，查找对应的资源，处理业务逻辑，并生成响应内容（HTML、CSS、JS、图片等）。</li> <li>浏览器接收响应，渲染页面
浏览器解析返回的 HTML，遇到 CSS、JS、图片等资源会继续发起新的 HTTP 请求。
解析和执行 CSS 样式、JavaScript 代码，最终渲染出完整的网页供用户交互。</li></ul> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> http 状态码</h2> <p>200：成功，所有数据都在响应主体中
300：有多个资源地址，选择要访问的资源便可链接过去
301:被请求的资源已经永久移动到新位置
302:请求的资源临时从不同的 url 响应请求
304：如果客户端发送了⼀个带条件的请求，请求被允许后⽂档内容却没有改变
400:请求参数错误
401:未授权，请登录
403:跨域拒绝访问
404:请求失败，请求的资源在服务器上没有被找到
408:请求超时
500：通常为服务器源代码出错⽽⽆法响应请求
501:error.message = 服务未实现;
502:网关错误;
503:服务不可用;
504:网关超时;</p> <h2 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域?</h2> <p>所谓的同源是指，域名、协议、端口均为相同。
所谓的跨域，不同的域名、协议、端口皆为不同域
一个域与另一个域名、协议或者端口不同的域的之间访问都叫跨域</p> <p><strong>解决跨域的方法和方案：</strong></p> <ul><li><p>配置本地开发环境（环境代理）</p> <ul><li><p><strong>原理</strong>：通过前端开发服务器（如 webpack-dev-server、Vite、create-react-app 等工具）配置 <code>proxy</code> 字段，将接口请求代理到后端服务器，实现“同源”效果，从而规避浏览器的同源策略限制。</p></li> <li><p><strong>特点</strong>：仅适用于本地开发环境，生产环境不可用。</p></li> <li><p><strong>示例</strong>（以 Vite 为例）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vite.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">server</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;/api&quot;</span><span class="token operator">:</span> <span class="token string">&quot;http://backend-server.com&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>JSONP 跨域</p> <ul><li><p><strong>原理</strong>：利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点，通过动态创建 <code>&lt;script&gt;</code> 标签，加载携带参数的请求，服务器返回一段 JavaScript 代码并调用事先定义好的回调函数实现数据传递。</p></li> <li><p><strong>实现步骤</strong>：</p> <ol><li>前端声明一个全局回调函数。</li> <li>动态创建 <code>&lt;script&gt;</code> 标签，将请求地址（带回调函数名参数）赋值给 <code>src</code> 属性。</li> <li>插入页面，触发请求，服务端返回形如 <code>callback(data)</code> 的 JS 代码，自动执行。</li></ol></li> <li><p><strong>注意事项</strong>：</p> <ul><li>仅支持 GET 请求，无法处理 POST、PUT 等。</li> <li>服务器需要支持 JSONP 格式的响应。</li> <li>返回内容会作为 JS 脚本执行，有一定安全隐患。</li></ul></li> <li><p><strong>示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://example.com/api?callback=handleResponse&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>CORS（跨域资源共享，Cross-Origin Resource Sharing）</p> <ul><li><p><strong>原理</strong>：服务器通过设置 <code>Access-Control-Allow-Origin</code> 等响应头，允许特定源的请求跨域访问资源。现代浏览器在发起跨域请求时会自动遵循 CORS 协议。</p></li> <li><p><strong>特点</strong>：</p> <ul><li>支持多种 HTTP 方法（GET、POST、PUT、DELETE 等）。</li> <li>对开发者而言，前端代码和同源 AJAX 通信基本一致。</li> <li>需要后端服务器配合设置响应头。</li></ul></li> <li><p><strong>常见配置</strong>（Node.js Express 示例）：</p> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许所有域名</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GET,POST,PUT,DELETE,OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Content-Type, Authorization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>Nginx 反向代理跨域</p> <ul><li><p><strong>原理</strong>：通过 Nginx 服务器配置反向代理，将前端请求转发到目标后端服务器，实现跨域资源访问。前端与 Nginx 同源，Nginx 代前端发起请求。</p></li> <li><p><strong>特点</strong>：</p> <ul><li>适用于生产环境，性能优良。</li> <li>不改变前端和后端代码，仅需配置 Nginx。</li></ul></li> <li><p><strong>示例配置</strong>：</p> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span> www.frontend.com</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">location</span> /api/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend-server.com/api/</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <hr> <ul><li><p>其他常见的跨域解决方案</p> <ul><li><strong>后端中间件代理</strong>：如 Node.js 的 http-proxy-middleware，原理类似于 Nginx 代理。</li> <li><strong>WebSocket</strong>：WebSocket 协议本身不受同源策略的限制，可以进行跨域通信。</li> <li><strong>window.name、postMessage 跨域</strong>：适用于 iframe 或多窗口间通信。</li></ul></li></ul> <hr> <h2 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="header-anchor">#</a> null 和 undefined 区别</h2> <p><code>null</code> 和 <code>undefined</code> 都表示“空值”，但在 JavaScript 中，它们代表了两种不同的“空”状态。</p> <ol><li><p>核心含义和本质</p> <table><thead><tr><th style="text-align:left;">属性</th> <th style="text-align:left;"><code>undefined</code> (未定义)</th> <th style="text-align:left;"><code>null</code> (空值)</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>含义</strong></td> <td style="text-align:left;"><strong>变量已声明，但尚未赋值。</strong></td> <td style="text-align:left;"><strong>变量已被赋值，但该值是空的。</strong></td></tr> <tr><td style="text-align:left;"><strong>本质</strong></td> <td style="text-align:left;">表示<em>缺少</em>值 (A variable has been declared but not defined/assigned a value)。</td> <td style="text-align:left;">表示<em>故意</em>没有对象值 (A value that is intentionally set to be empty or non-existent)。</td></tr> <tr><td style="text-align:left;"><strong>产生者</strong></td> <td style="text-align:left;">JavaScript 引擎（系统）默认赋予。</td> <td style="text-align:left;">开发者必须手动赋值。</td></tr></tbody></table> <p><strong>记忆要点：</strong></p> <ul><li><strong><code>undefined</code></strong>：系统默认值，表示**“变量存在，值待定”**。</li> <li><strong><code>null</code></strong>：人为赋予值，表示**“变量存在，值为空/无对象”**。</li></ul></li> <li><p>类型检查 (<code>typeof</code>)</p> <p>使用 <code>typeof</code> 运算符进行检查时，它们的结果不同：</p> <table><thead><tr><th style="text-align:left;">表达式</th> <th style="text-align:left;">结果</th> <th style="text-align:left;">备注</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>typeof undefined</code></td> <td style="text-align:left;"><code>&quot;undefined&quot;</code></td> <td style="text-align:left;">自身类型。</td></tr> <tr><td style="text-align:left;"><code>typeof null</code></td> <td style="text-align:left;"><code>&quot;object&quot;</code></td> <td style="text-align:left;"><strong>⚠️ 注意：</strong> 这是一个历史遗留的 Bug，但实际进行类型检查时需记住此结果。</td></tr></tbody></table></li> <li><p>常见产生场景</p> <table><thead><tr><th style="text-align:left;"><code>undefined</code> 的常见场景</th> <th style="text-align:left;"><code>null</code> 的常见场景</th></tr></thead> <tbody><tr><td style="text-align:left;">1. <strong>未初始化的变量：</strong> <code>let x;</code></td> <td style="text-align:left;">1. <strong>手动清空变量：</strong> <code>let data = null;</code></td></tr> <tr><td style="text-align:left;">2. <strong>函数没有返回值：</strong> 函数体中没有 <code>return</code> 语句。</td> <td style="text-align:left;">2. <strong>DOM 查询没有匹配项：</strong> <code>document.getElementById()</code> 未找到元素。</td></tr> <tr><td style="text-align:left;">3. <strong>函数参数未传值：</strong> 调用函数时省略了参数。</td> <td style="text-align:left;">3. <strong>JSON 传输空值：</strong> 接口返回数据中表示值为空。</td></tr> <tr><td style="text-align:left;">4. <strong>对象中不存在的属性：</strong> <code>obj.nonExistentProperty</code></td> <td style="text-align:left;">4. <strong>原型链末端：</strong> <code>Object.getPrototypeOf(Object.prototype)</code> 的结果。</td></tr></tbody></table></li> <li><p>相等性比较</p> <p>在比较时，区分<strong>宽松相等</strong> (<code>==</code>) 和<strong>严格相等</strong> (<code>===</code>) 至关重要：</p> <table><thead><tr><th style="text-align:left;">比较方式</th> <th style="text-align:left;">表达式</th> <th style="text-align:left;">结果</th> <th style="text-align:left;">解释</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>严格相等</strong></td> <td style="text-align:left;"><code>null === undefined</code></td> <td style="text-align:left;"><code>false</code></td> <td style="text-align:left;">类型和值都不同。<strong>（推荐使用此方式）</strong></td></tr> <tr><td style="text-align:left;"><strong>宽松相等</strong></td> <td style="text-align:left;"><code>null == undefined</code></td> <td style="text-align:left;"><code>true</code></td> <td style="text-align:left;">宽松相等认为它们属于同一类“空值”，会进行隐式类型转换。</td></tr></tbody></table> <p>在实际开发中，<strong>始终推荐使用严格相等 (<code>===</code>)</strong>，因为它能更精确地判断值和类型的真实情况。</p></li></ol> <h2 id="数组去重的方法"><a href="#数组去重的方法" class="header-anchor">#</a> 数组去重的方法</h2> <ul><li>利用 set 数据结构里面没有重复的项的特点定义一个新数组用扩展运算符后面接一个 newSet 外面包一个[]在赋值给一个新数组 return 出去</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>遍历数组 并且把每一项 push 到新数组中去 push 的时候做判断 如果新数组中没有这项就 push 用 indexOf(item)=== -1 做判断</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  params<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newarr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newarr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用两层 for 循环 第一层直接遍历 第二层从 i+1 开始遍历 就是吧数组中的一项和数组中的每一项做对比 如果有一样的 那么就截取掉</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">three</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> params<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        j<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用 filter 筛选 筛选索引 如果 indexof(item)等于 index 原理是 indexOf 是从前往后找 找到了之后他就不找了 如果这时候做个比较 只有相等的时候满足条件就可以去重了</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">four</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> params<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> params<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>两层 for 循环 把数组中的一项和数组中的每一项做对比 重复的把 flag 赋值为 2 下面做个判断 当 flag 为 1 的时候才 push</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">five</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//去重后新的数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len1 <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//标记</span>
    <span class="token comment">//arr 的一项和所有的 newarr 里面的数组项进行比较</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len2 <span class="token operator">=</span> newarr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> newarr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//满足条件，新数组里面存在。不需要的</span>
        flag <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果到这里 flag=1,不满足上面的 if 判断，新数组不存在，需要的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newarr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newarr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对象数组去重原理第一层直接遍历 第二层从 i+1 开始遍历 就是吧把数组中的一项的 key 和数组中的每一项的 key 做对比 如果有一样的 那么就截取掉这一项</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">===</span> item<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        item<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        j<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="类数组概念-怎么转换成真正的数组"><a href="#类数组概念-怎么转换成真正的数组" class="header-anchor">#</a> 类数组概念 怎么转换成真正的数组？</h2> <p>也叫伪数组，在 js 中有一些对象它也拥有 length 属性，且拥有为非负整数的属性(索引)，但是它又不能调用数组的方法，这种对象被称为类数组对象</p> <p>常见的伪数组</p> <ul><li>DOM 方法返回的 NodeList（比如 document.querySelectorAll() 的结果）</li> <li>arguments 对象</li></ul> <p><strong>类数组转换成真正的数组</strong></p> <ol><li><p>let 定义一个类数组 把类数组拆分成一系列用逗号隔开的值 arr =[一系列用逗号隔开的值]</p></li> <li><p>Array.from()方法用于将对象转为真正的数组(类数组转数组)</p></li> <li><p>遍历类数组 将取到的每一项值添加到新数组</p></li></ol> <h2 id="js-数据类型检测"><a href="#js-数据类型检测" class="header-anchor">#</a> js 数据类型检测</h2> <ul><li>typeof 引用数据类型（如：Array）是不起作用的。</li> <li>instanceof 检测基本数据类型的话会返回 false 引用数据类型则会是 true 但是用 new 关键字 new 出来的基本数据类型是可以的</li> <li>constructor 声明了一个构造函数，并且把他的原型指向了其他类型的原型 这种情况下会失效</li> <li>Object.prototype.toString.call() - 最好的数据类/型检测方式</li></ul> <h2 id="this-指向哪里"><a href="#this-指向哪里" class="header-anchor">#</a> this 指向哪里</h2> <ul><li>普通函数的 this 指向调用这个函数的对象，默认是 window</li> <li>构造函数的 this 指向 new 出来的实例对象，而且优先级是最高的，不能被改变</li> <li>箭头函数的 this 指向的是它外面的第一个不是箭头函数的函数的 this， 在定义时就确定了，不能被改变</li> <li>事件处理函数的 this 指向事件对象</li></ul> <h2 id="如何改变-this-指向"><a href="#如何改变-this-指向" class="header-anchor">#</a> 如何改变 this 指向</h2> <ul><li>利用 call,apply,bind 改变 this 的指向。</li> <li>利用变量将正确的 this 存储为变量。</li> <li>new 关键字改变 this 的指向。</li> <li>箭头函数</li></ul> <h2 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="header-anchor">#</a> call, apply, bind 区别</h2> <ul><li>call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。</li> <li>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</li> <li>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。</li></ul> <h2 id="常用的-git-命令"><a href="#常用的-git-命令" class="header-anchor">#</a> 常用的 git 命令</h2> <p><strong>git</strong>
git 是目前世界上最先进分布式的版本控制系统</p> <div class="language-bash extra-class"><pre class="language-bash"><code>**配置**

- 仓库账号的用户名和邮箱
  <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">'远程仓库的账号'</span>
  <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">'远程仓库的邮箱'</span>
  **上传本地文件**
  <span class="token function">git</span> init
  初始化
  <span class="token function">git</span> <span class="token function">add</span> index.html 或者 <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  提交到暂存区
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'init index.html'</span>
  提交到本地仓库
  <span class="token function">git</span> status
  查看 <span class="token function">git</span> 的状态
  <span class="token function">git</span> <span class="token function">diff</span>
  查看版本的差别
  <span class="token function">git</span> log 或者 <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
  查看版本信息
  <span class="token function">git</span> reset HEAD^
  回退一个版本<span class="token punctuation">(</span>回退到的是暂存区的版本<span class="token punctuation">)</span>
  <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> cc56901
  回退到指定版本
  <span class="token function">git</span> reflog
  查看所有的历史版本
  **分支**
  <span class="token function">git</span> branch
  查看分支
  <span class="token function">git</span> branch dev
  创建分支
  <span class="token function">git</span> checkout dev 或者 <span class="token function">git</span> switch dev
  切换分支
  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> dev2
  创建并切换
  <span class="token function">git</span> merge dev2
  合并分支内容
  <span class="token function">git</span> branch <span class="token parameter variable">-d</span> dev2
  删除分支
  <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
  查看分支记录
  **关联远程仓库**
  生成密钥对
  ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">'pudge_wj@163.com'</span>
  创建项目
  <span class="token function">git</span> init
  <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'init'</span>
  <span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:pudge-w/taobao.git
  <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master
  邀请组员
  setting -<span class="token operator">&gt;</span> manage access
  组员开发
  不要在 master 做开发<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
  <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> zhengguo
  <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">'xxx'</span>
  <span class="token function">git</span> pull
  <span class="token function">git</span> push
  组长
  <span class="token function">git</span> fetch <span class="token parameter variable">--all</span>
  <span class="token function">git</span> checkout zhengguo
  <span class="token function">git</span> pull
  <span class="token function">git</span> checkout master
  <span class="token function">git</span> merge zhengguo
  <span class="token function">git</span> push

</code></pre></div><h2 id="git-克隆速度慢的解决办法及科学上网代理配置"><a href="#git-克隆速度慢的解决办法及科学上网代理配置" class="header-anchor">#</a> Git 克隆速度慢的解决办法及科学上网代理配置</h2> <p>在中国大陆等地区，使用 <code>git clone</code> 从 GitHub 等国外仓库拉取代码时，常常会遇到速度较慢、甚至连接超时的问题。如果没有使用全局加速器（如全局 VPN），可以通过配置 Git 的代理端口，快速实现“科学上网”，显著提升 Git 操作速度。</p> <hr> <h3 id="_1-问题现象"><a href="#_1-问题现象" class="header-anchor">#</a> 1. 问题现象</h3> <ul><li><code>git clone</code>、<code>git fetch</code>、<code>git pull</code> 等指令速度极慢，甚至失败。</li> <li>原因：国内网络对 GitHub 等国外源访问受限，速度被大幅降低。</li> <li>解决思路：为 Git 单独配置代理端口，让其流量通过本地加速器的 HTTP(S) 代理端口转发。</li></ul> <hr> <h3 id="_2-解决办法-为-git-配置代理"><a href="#_2-解决办法-为-git-配置代理" class="header-anchor">#</a> 2. 解决办法：为 Git 配置代理</h3> <h4 id="_2-1-选择合适的本地代理端口"><a href="#_2-1-选择合适的本地代理端口" class="header-anchor">#</a> 2.1 选择合适的本地代理端口</h4> <ul><li>常见的科学上网工具（如 Clash、V2RayN、Surfboard 等）都支持本地 HTTP(S) 代理，端口号一般为 <code>7890</code>、<code>7897</code>、<code>1080</code> 等（以实际工具配置为准）。</li> <li>例如 Clash 默认 HTTP 代理端口为 <code>7890</code>，部分工具自定义端口为 <code>7897</code>。</li></ul> <h4 id="_2-2-全局配置-git-代理"><a href="#_2-2-全局配置-git-代理" class="header-anchor">#</a> 2.2 全局配置 Git 代理</h4> <p>可以直接在命令行设置：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy http://127.0.0.1:7897
<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy http://127.0.0.1:7897
</code></pre></div><ul><li>这样配置后，所有 Git 操作都会通过本地的 7897 端口进行 HTTP/HTTPS 请求，实现加速。</li></ul> <h4 id="_2-3-取消-git-代理"><a href="#_2-3-取消-git-代理" class="header-anchor">#</a> 2.3 取消 Git 代理</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> http.proxy
<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> https.proxy
</code></pre></div><hr> <h3 id="_3-快速开启-关闭-git-代理-推荐-alias"><a href="#_3-快速开启-关闭-git-代理-推荐-alias" class="header-anchor">#</a> 3. 快速开启/关闭 Git 代理（推荐 alias）</h3> <p>为了方便日常切换，可以将开启和关闭代理的操作写成 shell alias：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 快速开启 Git 科学上网代理</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">proxy_on</span><span class="token operator">=</span><span class="token string">&quot;git config --global http.proxy http://127.0.0.1:7897 &amp;&amp; git config --global https.proxy http://127.0.0.1:7897 &amp;&amp; echo 'Git proxy has been turned ON.'&quot;</span>

<span class="token comment"># 快速关闭 Git 科学上网代理</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">proxy_off</span><span class="token operator">=</span><span class="token string">&quot;git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy &amp;&amp; echo 'Git proxy has been turned OFF.'&quot;</span>
</code></pre></div><blockquote><p><strong>提示</strong>：可以将上述 alias 写入 <code>~/.bashrc</code>、<code>~/.zshrc</code> 等 shell 配置文件中，重开终端即可生效。</p> <ul><li>之后只需运行 <code>proxy_on</code> 即可开启代理，<code>proxy_off</code> 关闭代理。</li></ul></blockquote> <hr> <h3 id="_4-检查-git-代理状态"><a href="#_4-检查-git-代理状态" class="header-anchor">#</a> 4. 检查 Git 代理状态</h3> <p>可以通过以下命令查看当前 git 的代理配置：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--get</span> http.proxy
<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--get</span> https.proxy
</code></pre></div><p>如果返回为空，则说明当前未配置代理。</p> <hr> <h3 id="_5-其他说明"><a href="#_5-其他说明" class="header-anchor">#</a> 5. 其他说明</h3> <ul><li>该方法仅影响 Git 命令（不影响其它终端流量）。</li> <li>记得本地代理工具必须已启动并监听对应端口，否则配置后 Git 会连接失败。</li> <li>若使用 SSH 协议（如 <code>git@github.com:xxx</code>），本配置<strong>无效</strong>，建议改用 HTTPS 协议（如 <code>https://github.com/xxx</code>）克隆仓库。</li> <li>若需临时代理（只对单条命令生效），可用如下方式：<div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> <span class="token parameter variable">-c</span> <span class="token assign-left variable">http.proxy</span><span class="token operator">=</span>http://127.0.0.1:7897 <span class="token parameter variable">-c</span> <span class="token assign-left variable">https.proxy</span><span class="token operator">=</span>http://127.0.0.1:7897 clone https://github.com/xxx/xxx.git
</code></pre></div></li></ul> <hr> <h3 id="_6-参考资料"><a href="#_6-参考资料" class="header-anchor">#</a> 6. 参考资料</h3> <ul><li><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener noreferrer">Git 官方文档：git-config<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.cfw.lbyczf.com/contents/proxy.html" target="_blank" rel="noopener noreferrer">Clash 使用说明<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904186715285512" target="_blank" rel="noopener noreferrer">提高 GitHub 访问速度的几种方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="header-anchor">#</a> 垃圾回收机制</h2> <p>垃圾回收方式</p> <ul><li>标记清除
工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</li> <li>引用计数
工作原理：跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。</li> <li>内存管理
什么时候触发垃圾回收？
垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。
<ul><li>合理的 GC 方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。</li> <li>GC 缺陷： (1)、停止响应其他操作；</li> <li>GC 优化策略： (1)、分代回收（Generation GC）;(2)、增量 GC</li></ul></li></ul> <h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <ul><li>浅拷贝,拷贝一级，如果是对象里面还有对象,无法解决
<ol><li>for… in… 循环</li> <li>Object.assgin() 缺点：非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable</li> <li>...扩展运算符</li></ol></li> <li>深拷贝
<ol><li>JSON.parse(JSON.stringify( )) 缺点：当对象的 value 是函数 或者 undefined 时会失效</li> <li>用 for…in…+递归</li></ol></li> <li>递归实现深拷贝代码
思路：</li></ul> <ol><li>创建一个空对象 一个 if 条件判断一下这个传进来的是不是个对象</li> <li>然后遍历对象 用一个 obj.hasOwnProperty(key)判断这个 key 是不是自身的属性</li> <li>如果 obj[key]还是一个对象就递归调用这个函数 如果不是对象就把他赋值给新对象</li></ol> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> objArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//定义空数组或者空对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//判断是否是对象</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//遍历数组或者对象e</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//判断当前key是不是对象自身的属性。不包括原型链</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            objArray<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            objArray<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> objArray<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="构造函数详解与总结"><a href="#构造函数详解与总结" class="header-anchor">#</a> 构造函数详解与总结</h2> <p><strong>什么是构造函数？</strong></p> <p>构造函数（Constructor Function）是 JavaScript 中用于创建对象的一种特殊函数。它主要用于在实例化对象时，初始化对象的属性和方法。</p> <ul><li>构造函数通常<strong>首字母大写</strong>，以示区别于普通函数。</li> <li>构造函数需要与 <code>new</code> 关键字一起使用。</li></ul> <p><strong>构造函数的执行流程</strong></p> <p>当使用 <code>new</code> 关键字调用构造函数时，执行过程如下：</p> <ol><li>在内存中创建一个新的空对象。</li> <li>将构造函数内部的 <code>this</code> 指向这个新对象。</li> <li>执行构造函数内的代码（给新对象添加属性和方法）。</li> <li>返回新对象（如果构造函数没有显式返回对象，则返回步骤 1 创建的对象）。</li></ol> <p><strong>构造函数的示例</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, I am &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hello, I am Alice</span>
</code></pre></div><p><strong>注意事项</strong></p> <ul><li>构造函数必须和 <code>new</code> 一起使用，否则 <code>this</code> 指向全局对象（在严格模式下为 undefined）。</li> <li>构造函数可以不用 <code>return</code> 返回值；如果返回的是非对象类型，仍然返回新对象本身；如果返回的是对象，则返回该对象。</li> <li>通过构造函数创建的多个对象实例，<strong>各自拥有独立的属性和方法</strong>。</li></ul> <p><strong>构造函数和普通函数的区别</strong></p> <table><thead><tr><th>区别</th> <th>构造函数</th> <th>普通函数</th></tr></thead> <tbody><tr><td>命名</td> <td>通常首字母大写</td> <td>通常首字母小写</td></tr> <tr><td>调用方式</td> <td>必须用 <code>new</code> 关键字调用</td> <td>直接调用</td></tr> <tr><td>this 指向</td> <td>指向新创建的对象</td> <td>由调用方式决定</td></tr> <tr><td>返回值</td> <td>默认返回新对象</td> <td>默认返回 undefined</td></tr></tbody></table> <p><strong>总结</strong></p> <ul><li>构造函数本质上就是一个普通函数，但用来创建对象实例。</li> <li>使用 <code>new</code> 关键字调用构造函数可以自动完成对象的创建和初始化。</li> <li>合理使用构造函数可以提高代码的复用性和可维护性，是 JS 面向对象编程的基础。</li></ul> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p><strong>原型（prototype）的概念</strong></p> <ul><li><p><strong>每一个函数都有一个 prototype 属性</strong></p> <ul><li>这个属性指向一个对象，称为“原型对象”。</li> <li>当函数作为构造函数（即用 <code>new</code> 创建对象）时，新创建的对象会自动拥有对这个原型对象的引用。</li></ul></li> <li><p><strong>原型对象的作用</strong></p> <ul><li>所有定义在 prototype 上的属性和方法，都会被该构造函数的实例继承和共享。</li> <li>适合将不变（公用）的属性和方法定义在 prototype 上，节省内存，提高复用性。</li></ul></li> <li><p><strong>this 的指向</strong></p> <ul><li>在构造函数内部，<code>this</code> 指向实例对象。</li> <li>在原型对象内部，<code>this</code> 也指向调用该方法的实例对象。</li></ul></li> <li><p><strong>示例代码</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, I am &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hello, I am Alice</span>
</code></pre></div></li></ul> <hr> <p><strong>原型链的概念</strong></p> <ul><li><p><strong>什么是原型链？</strong></p> <ul><li>原型链是 JavaScript 实现继承的主要机制。</li> <li>每个对象都有一个内部属性 <code>__proto__</code>（标准写法为 [[Prototype]]），指向它的原型对象。</li> <li>多个对象通过 <code>__proto__</code> 属性串联在一起，形成链状结构，称为“原型链”。</li></ul></li> <li><p><strong>查找规则</strong></p> <ul><li>当访问一个对象的属性或方法时，如果对象本身没有，就会去它的原型对象（即 <code>__proto__</code> 指向的对象）查找。</li> <li>如果原型对象也没有，再继续沿着它的 <code>__proto__</code> 查找，直到找到 <code>Object.prototype</code>，其 <code>__proto__</code> 为 <code>null</code>，原型链到此结束。</li></ul></li> <li><p><strong>原型链结构图</strong></p> <div class="language- extra-class"><pre class="language-text"><code>实例对象  ——&gt;  构造函数.prototype  ——&gt;  Object.prototype  ——&gt;  null
    |                |                     |
    |__proto__       |__proto__            |__proto__
</code></pre></div></li> <li><p><strong>示例代码</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;eating&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bark</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;bark&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bark</span>
dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eating</span>
</code></pre></div></li></ul> <hr> <p><strong>核心要点总结</strong></p> <ul><li>每个函数都有 prototype 属性，每个对象（除 null）都有 <strong>proto</strong> 属性。</li> <li>构造函数的 prototype 上定义的方法和属性，会被所有实例共享。</li> <li>原型链让对象可以“继承”到上层原型对象的属性和方法。</li> <li>属性/方法的查找顺序：对象本身 → 原型对象 → 原型链上一层... → Object.prototype → null</li></ul> <h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="header-anchor">#</a> js 的几种模块规范</h2> <p><strong>ES Module（ESM，ES6 模块规范）</strong></p> <ul><li><p><strong>应用场景</strong>：现代浏览器和 Node.js（支持 .mjs 或 &quot;type&quot;: &quot;module&quot;）。</p></li> <li><p><strong>核心思想</strong>：JavaScript 官方标准的模块系统，静态分析，编译时确定依赖关系。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>使用 <code>export</code> 导出，<code>import</code> 导入。</p></li> <li><p>支持异步和静态引入，最适合前端工程化。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./a.js&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 'bar'</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>CommonJS</strong></p> <ul><li><p><strong>应用场景</strong>：主要用于 Node.js 服务器端开发。</p></li> <li><p><strong>核心思想</strong>：每个文件就是一个模块，模块内部通过 <code>module.exports</code> 导出成员，通过 <code>require</code> 导入模块。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>同步加载模块（适合服务器，文件都在本地）。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// b.js</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./a.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 'bar'</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>AMD（Asynchronous Module Definition）</strong></p> <ul><li><p><strong>应用场景</strong>：主要用于浏览器端，代表库有 RequireJS。</p></li> <li><p><strong>核心思想</strong>：异步加载模块，适合浏览器环境。</p></li> <li><p><strong>特点</strong>：</p> <ul><li><p>使用 <code>define</code> 定义模块，<code>require</code> 加载模块。</p></li> <li><p>支持依赖前置，异步加载。</p></li> <li><p>代码示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;dep1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dep2&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">dep1<span class="token punctuation">,</span> dep2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用模块</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;moduleA&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">moduleA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  moduleA<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>CMD（Common Module Definition）</strong></p> <ul><li><strong>应用场景</strong>：主要用于浏览器端，代表库有 SeaJS（国内较流行）。</li> <li><strong>核心思想</strong>：按需加载（延迟执行），依赖就近。</li> <li><strong>特点</strong>：
<ul><li>使用 <code>define</code> 定义模块，<code>require</code> 加载模块。</li> <li>依赖可以写在使用的地方，延迟执行。</li> <li>代码示例：<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;jquery&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  exports<span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <hr> <p><strong>总结</strong></p> <ul><li><strong>ESM</strong>：ES6 官方标准，现代浏览器和 Node.js 推荐使用。</li> <li><strong>CommonJS</strong>：服务端 Node.js 标准，同步加载。</li> <li><strong>AMD/CMD</strong>：浏览器端异步加载，前者依赖前置，后者依赖就近。</li></ul> <h3 id="commonjs-和-es6-模块的区别"><a href="#commonjs-和-es6-模块的区别" class="header-anchor">#</a> CommonJS 和 ES6 模块的区别</h3> <p><strong>加载方式</strong></p> <ul><li><strong>CommonJS</strong>：同步加载模块，适用于服务器端（如 Node.js），因为本地文件读取速度快。</li> <li><strong>ES6 Module</strong>：静态分析，编译时加载，支持异步和静态引入，适合浏览器和现代前端工程</li></ul> <p><strong>导入导出语法</strong></p> <ul><li><p><strong>CommonJS</strong></p> <ul><li>导出：<code>module.exports = ...</code> 或 <code>exports.xxx = ...</code></li> <li>导入：<code>const xxx = require('...')</code></li></ul></li> <li><p><strong>ES6 Module</strong></p> <ul><li>导出：<code>export</code> 或 <code>export default</code></li> <li>导入：<code>import { xxx } from '...'</code> 或 <code>import xxx from '...'</code></li></ul></li></ul> <p><strong>导出本质</strong></p> <ul><li><strong>CommonJS</strong>：导出的是值的<strong>拷贝</strong>（require 时会执行一遍，被缓存；后续 require 拿到缓存的对象）。</li> <li><strong>ES6 Module</strong>：导出的是<strong>引用</strong>（export 的变量和 import 的变量实时绑定，动态更新）。</li></ul> <p><strong>语法特性</strong></p> <ul><li><p><strong>CommonJS</strong></p> <ul><li>动态语法，可以在运行时任意位置调用 <code>require</code>。</li> <li>导出可以是任意类型的数据（对象、函数、字符串等）。</li></ul></li> <li><p><strong>ES6 Module</strong></p> <ul><li>静态语法，<code>import</code> 和 <code>export</code> 必须写在顶层，不能放在逻辑块或函数内部。</li> <li>支持静态分析和 Tree Shaking（按需打包）。</li></ul></li></ul> <p><strong>执行时机</strong></p> <ul><li><strong>CommonJS</strong>：模块是<strong>运行时加载</strong>，require 时同步读取、立即执行一遍。</li> <li><strong>ES6 Module</strong>：模块是<strong>编译时解析</strong>，提前确定依赖关系，提升性能。</li></ul> <p><strong>总结</strong></p> <table><thead><tr><th>对比点</th> <th>CommonJS</th> <th>ES6 Module</th></tr></thead> <tbody><tr><td>加载方式</td> <td>同步</td> <td>静态、异步支持</td></tr> <tr><td>导入导出</td> <td>require/module.exports</td> <td>import/export</td></tr> <tr><td>导出本质</td> <td>值的拷贝</td> <td>引用绑定</td></tr> <tr><td>执行时机</td> <td>运行时</td> <td>编译时</td></tr> <tr><td>this</td> <td>指向 exports</td> <td>undefined</td></tr> <tr><td>兼容性</td> <td>Node.js（服务端）</td> <td>浏览器+Node.js</td></tr></tbody></table> <h2 id="防抖节流"><a href="#防抖节流" class="header-anchor">#</a> 防抖节流</h2> <p><strong>函数的防抖（Debounce）</strong></p> <ul><li><p><strong>定义</strong>：当事件被触发后，等待一段指定时间再执行回调。如果在等待时间内事件再次被触发，则重新计时，只有最后一次触发后等待时间到了才执行。</p></li> <li><p><strong>应用场景</strong>：输入框实时搜索、窗口大小变化、滚动加载等频繁触发场景，减少无效调用。</p></li> <li><p><strong>实现示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用方式</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span>
  <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;窗口大小变化&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <p><strong>函数节流（Throttle）</strong></p> <ul><li><p><strong>定义</strong>：在指定的时间间隔内，不管事件被触发多少次，只会执行一次回调函数。</p></li> <li><p><strong>应用场景</strong>：页面滚动、按钮点击、窗口缩放等高频事件，控制函数的执行频率，提升性能。</p></li> <li><p><strong>实现示例</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">&gt;</span> interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用方式</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;scroll&quot;</span><span class="token punctuation">,</span>
  <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;页面滚动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="js-实现继承的方式有哪些"><a href="#js-实现继承的方式有哪些" class="header-anchor">#</a> js 实现继承的方式有哪些</h2> <ul><li>构造函数继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li> <li>原型链继承-----核心： 将父类的实例作为子类的原型**</li> <li>组合（混合）继承----核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li> <li>class 继承----核心：class 是 ES6 新增的语法 直接 class 创建一个类，使用 extends 来继承</li> <li>实例继承----核心：为父类实例添加新特性，作为子类实例返回</li> <li>拷贝继承-----核心：Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</li> <li>寄生组合继承----核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li></ul> <h2 id="严格模式下有哪些限制-规则"><a href="#严格模式下有哪些限制-规则" class="header-anchor">#</a> 严格模式下有哪些限制（规则）</h2> <ul><li>变量必须声明后再使用</li> <li>函数的参数不能有同名属性，否则报错</li> <li>不能使用 with 语句</li> <li>不能对只读属性赋值，否则报错</li> <li>不能使用前缀 0 表示八进制数，否则报错</li> <li>不能删除不可删除的属性，否则报错</li> <li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li> <li>eval 不会在它的外层作用域引入变量</li> <li>eval 和 arguments 不能被重新赋值</li> <li>arguments 不会自动反映函数参数的变化</li> <li>不能使用 arguments.callee</li> <li>不能使用 arguments.caller</li> <li>禁止 this 指向全局对象</li> <li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li> <li>增加了保留字（比如 protected、static 和 interface）</li></ul> <h2 id="函数缓存的方法"><a href="#函数缓存的方法" class="header-anchor">#</a> 函数缓存的方法</h2> <p><strong>基本思想</strong></p> <ul><li>当函数被调用时，先检查传入的参数是否有对应的结果已被缓存。</li> <li>如果有，直接返回缓存的结果。</li> <li>如果没有，执行计算，把结果缓存起来，下次遇到相同参数直接取用。</li></ul> <p><strong>常见实现方式</strong></p> <ul><li><p>闭包实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例：斐波那契数列</span>
<span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> memoFibonacci <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">memoFibonacci</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比直接递归快得多</span>
</code></pre></div></li></ul> <p><strong>Map 实现（更适合复杂参数）</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>应用场景</strong></p> <ul><li>递归函数（如斐波那契数列、阶乘等）</li> <li>重复计算但参数不变的复杂运算</li> <li>前端数据转换、过滤等纯函数操作</li></ul> <p><strong>注意事项</strong></p> <ul><li>适用于“纯函数”（相同参数总是返回相同结果，无副作用）</li> <li>参数复杂时需要设计好缓存 key，避免缓存污染或内存泄漏</li> <li>不适合缓存大量或不断变化的数据</li></ul> <p><strong>相关扩展</strong></p> <ul><li>Lodash 等第三方库提供了 <code>_.memoize</code> 方法</li> <li>ES6 WeakMap 可用于缓存对象参数，避免内存泄漏</li></ul> <h2 id="内存泄漏是什么-内存泄露造成的原因"><a href="#内存泄漏是什么-内存泄露造成的原因" class="header-anchor">#</a> 内存泄漏是什么 内存泄露造成的原因</h2> <p>内存泄漏也称作&quot;存储渗漏&quot;，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束
简单来说就是该内存空间使用完毕后未回收</p> <p><strong><em>内存泄露造成的原因</em></strong></p> <ol><li>单例造成的内存泄漏</li> <li>静态集合类</li> <li>资源未关闭造成的内存泄漏</li> <li>改变哈希值</li> <li>缓存泄露</li> <li>监听器和回调</li> <li>不合理的使用闭包</li></ol> <h2 id="函数柯里化"><a href="#函数柯里化" class="header-anchor">#</a> 函数柯里化</h2> <p>柯里化（Currying）
柯里化（Currying）是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。</p> <p>柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。</p> <p>柯里化不会调用函数。它只是对函数进行转换。</p> <p>让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。</p> <p>我们将创建一个辅助函数 curry(f)，该函数将对两个参数的函数 f 执行柯里化。换句话说，对于两个参数的函数 f(a, b) 执行 curry(f) 会将其转换为以 f(a)(b) 形式运行的函数：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// curry(f) 执行柯里化转换</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用法</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><p>正如你所看到的，实现非常简单：只有两个包装器（wrapper）。</p> <p>curry(func) 的结果就是一个包装器 function(a)。
当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。
然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。
柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用来自 lodash 库的 _.curry</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3，仍可正常调用</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3，以偏函数的方式调用</span>
</code></pre></div><p>柯里化？目的是什么？
要了解它的好处，我们需要一个实际中的例子。</p> <p>例如，我们有一个用于格式化和输出信息的日志（logging）函数 log(date, importance, message)。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 alert：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">date<span class="token punctuation">,</span> importance<span class="token punctuation">,</span> message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>date<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>date<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] [</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>importance<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//让我们将它柯里化！</span>

log <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 柯里化之后，log 仍正常运行：</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;some debug&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// log(a, b, c)</span>

<span class="token comment">// ……但是也可以以柯里化形式运行：</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;some debug&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// log(a)(b)(c)</span>

<span class="token comment">// 现在，我们可以轻松地为当前日志创建便捷函数：</span>

<span class="token comment">// logNow 会是带有固定第一个参数的日志的偏函数</span>
<span class="token keyword">let</span> logNow <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用它</span>
<span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&quot;INFO&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] INFO message</span>

<span class="token comment">// 现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。</span>

<span class="token comment">// 我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：</span>

<span class="token keyword">let</span> debugNow <span class="token operator">=</span> <span class="token function">logNow</span><span class="token punctuation">(</span><span class="token string">&quot;DEBUG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">debugNow</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [HH:mm] DEBUG message</span>
</code></pre></div><p>所以：</p> <p>柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。
我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。
高级柯里化实现
如果你想了解更多细节，下面是用于多参数函数的“高级”柯里化实现，我们也可以把它用于上面的示例。</p> <p>它非常短：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> func<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// 用例：</span>

<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> curriedSum <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，仍然可以被正常调用</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，对第一个参数的柯里化</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">curriedSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6，全柯里化</span>

<span class="token comment">// 新的 curry 可能看上去有点复杂，但是它很容易理解。</span>

<span class="token comment">// curry(func) 调用的结果是如下所示的包装器 curried：</span>

<span class="token comment">// func 是要转换的函数</span>
<span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> func<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (1)</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (2)</span>
      <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当我们运行它时，这里有两个 if 执行分支：</p> <p>如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，那么只需要使用 func.apply 将调用传递给它即可。
否则，获取一个偏函数：我们目前还没调用 func。取而代之的是，返回另一个包装器 pass，它将重新应用 curried，将之前传入的参数与新的参数一起传入。
然后，如果我们再次调用它，我们将得到一个新的偏函数（如果没有足够的参数），或者最终的结果。</p> <p>只允许确定参数长度的函数</p> <p>柯里化要求函数具有固定数量的参数。</p> <p>使用 rest 参数的函数，例如 f(...args)，不能以这种方式进行柯里化。</p> <p>比柯里化多一点</p> <p>根据定义，柯里化应该将 sum(a, b, c) 转换为 sum(a)(b)(c)。</p> <p>但是，如前所述，JavaScript 中大多数的柯里化实现都是高级版的：它们使得函数可以被多参数变体调用。</p> <p>总结
柯里化 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。</p> <p>柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.ec81c2a4.js" defer></script><script src="/jiabinxu-blog/assets/js/3.c5fdad7d.js" defer></script><script src="/jiabinxu-blog/assets/js/2.34d20650.js" defer></script><script src="/jiabinxu-blog/assets/js/32.8f6a39a4.js" defer></script>
  </body>
</html>
