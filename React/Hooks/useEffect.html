<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>useEffect | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.f81cf313.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.bb87b8ff.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.180c3171.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/40.42a528d4.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.3c2a6c83.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.3c49b8de.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.91b5c8e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.ef4b17e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.23f5619b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.4bb3669d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.664e814e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.21ad7801.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.d4db7480.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.31141967.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.97e9a047.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.f04bcbc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.f5223a9d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.2e981bab.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.d58d5448.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.fb28f85b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.d10d4810.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.f89661dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.a2c20bce.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.edabae48.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.8f37da54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.86e08cd4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.3ff6f6b3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.46dbe14a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.0b72d4b8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.7d892d86.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.164a4f16.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.5bc0d409.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.82b75b59.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.e959a5f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.cc983ac3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.ed08971b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.9cbc22ee.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.f9457251.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.63e6d8ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.51ebfdbe.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.2e948603.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1907287a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.2aca8e9e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.53572a11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.6c8d55a3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.7c01df11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.1df3a578.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.bf31f66a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.f2feff3d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.d36efdc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.824240b9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.6e5633db.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.0bc9c8bd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.b03cfd91.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.3a221345.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.23192d8d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.e15e8a6b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.d4fc17a1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.bdb98294.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.5b17ac84.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/73.3030d7e2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/74.3329104a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.c9879746.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>useEffect</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/React/Hooks/useEffect.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#useeffect-setup-dependencies" class="sidebar-link">useEffect(setup, dependencies?)</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useEffect.html#第二个参数的三种用法" class="sidebar-link">第二个参数的三种用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#不填任何内容" class="sidebar-link">不填任何内容</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#依赖空数组" class="sidebar-link">依赖空数组</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#依赖一个值" class="sidebar-link">依赖一个值</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useEffect.html#用法" class="sidebar-link">用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#连接到外部系统" class="sidebar-link">连接到外部系统</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#自定义钩子中的封装-useeffect" class="sidebar-link">自定义钩子中的封装 useEffect</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#控制非-react-小部件" class="sidebar-link">控制非 React 小部件</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#使用-useeffect-请求数据" class="sidebar-link">使用 useEffect 请求数据</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#指定反应依赖" class="sidebar-link">指定反应依赖</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#根据-useeffect-的先前状态更新状态" class="sidebar-link">根据 useEffect 的先前状态更新状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#移除不必要的对象依赖" class="sidebar-link">移除不必要的对象依赖</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#删除不必要的函数依赖" class="sidebar-link">删除不必要的函数依赖</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useEffect.html#故障排除" class="sidebar-link">故障排除</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#我的-useeffect-在组件挂载时运行两次" class="sidebar-link">我的 useEffect 在组件挂载时运行两次</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#我的-useeffect-在每次重新渲染后运行" class="sidebar-link">我的 useEffect 在每次重新渲染后运行</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#我的-useeffect-在无限循环中不断重新运行" class="sidebar-link">我的 useEffect 在无限循环中不断重新运行</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#即使我的组件没有卸载-我的清理逻辑仍在运行" class="sidebar-link">即使我的组件没有卸载，我的清理逻辑仍在运行</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useEffect.html#我的-useeffect-做了一些视觉-useeffect-我在它运行前看到了闪烁" class="sidebar-link">我的 useEffect 做了一些视觉 useEffect，我在它运行前看到了闪烁</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h1> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <h3 id="useeffect-setup-dependencies"><a href="#useeffect-setup-dependencies" class="header-anchor">#</a> useEffect(setup, dependencies?)</h3> <p>在组件的顶层调用 useEffect 以声明一个 useEffect：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createConnection <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./chat.js&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> setServerUrl<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><a href="#%E7%94%A8%E6%B3%95">请参阅下面的更多示例。</a></p> <h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <ul><li><p>setup：具有 useEffect 逻辑的函数。你的设置函数也可以选择返回一个清理函数。当你的组件被添加到 DOM 时，React 将运行你的设置函数。在每次使用更改的依赖重新渲染后，React 将首先使用旧值运行清理函数（如果你提供了它），然后使用新值运行你的设置函数。在你的组件从 DOM 中移除后，React 将运行你的清理函数。</p></li> <li><p>可选 dependencies：setup 代码中引用的所有反应值的列表。反应值包括属性、状态以及直接在组件主体内声明的所有变量和函数。如果你的 linter 是 为 React 配置，它将验证每个反应值是否正确指定为依赖。依赖列表必须具有恒定数量的条目，并且像 [dep1, dep2, dep3] 一样写成内联。React 将使用 Object.is 比较将每个依赖与其先前的值进行比较。如果省略此参数，你的 useEffect 将在每次重新渲染组件后重新运行。查看传递依赖数组、空数组和完全不依赖之间的区别。</p></li></ul> <h4 id="返回"><a href="#返回" class="header-anchor">#</a> 返回</h4> <p>useEffect 返回 undefined。</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <ul><li><p>useEffect 是一个 Hook，所以你只能在你的组件的顶层或者你自己的钩子中调用它。你不能在循环或条件内调用它。如果需要，提取一个新组件并将状态移入其中。</p></li> <li><p>如果你不尝试与某些外部系统同步，你可能不需要 useEffect</p></li> <li><p>当严格模式打开时，React 将在第一次真正设置之前运行一个额外的仅开发设置+清理周期。这是一个压力测试，可确保你的清理逻辑 “mirrors” 你的设置逻辑，并确保它停止或撤消设置正在执行的任何操作。如果这导致问题，实现清理函数。</p></li> <li><p>如果你的某些依赖是在组件内部定义的对象或函数，则存在它们会导致 useEffect 重新运行频率超过所需频率的风险。要解决此问题，请删除不必要的 object 和 函数 依赖。你也可以在 useEffect 器之外进行 提取状态更新 和 非 React 性逻辑。</p></li> <li><p>如果你的 useEffect 不是由交互（如点击）引起的，React 通常会让浏览器在运行你的 useEffect 之前先绘制更新的屏幕。如果你的效果正在执行一些视觉操作（例如，定位工具提示），并且延迟很明显（例如，它闪烁），请将 useEffect 替换为 useLayoutEffect。</p></li> <li><p>如果你的效果是由交互（如点击）引起的，React 可能会在浏览器绘制更新的屏幕之前运行你的效果。这可确保事件系统可以观察到效果的结果。通常，这会按预期工作。但是，如果你必须将工作推迟到绘制之后，例如 alert()，则可以使用 setTimeout。有关更多信息，请参阅 reactwg/react-18/128。</p></li> <li><p>即使你的效果是由交互（如点击）引起的，React 也可能允许浏览器在处理效果内的状态更新之前重新绘制屏幕。通常，这会按预期工作。但是，如果必须阻止浏览器重新绘制屏幕，则需要将 useEffect 替换为 useLayoutEffect。</p></li> <li><p>useEffect 仅在客户端上运行。它们不会在服务器渲染期间运行。</p></li></ul> <h2 id="第二个参数的三种用法"><a href="#第二个参数的三种用法" class="header-anchor">#</a> 第二个参数的三种用法</h2> <h3 id="不填任何内容"><a href="#不填任何内容" class="header-anchor">#</a> 不填任何内容</h3> <p>在每一次渲染（包括首次）后都执行。</p> <h3 id="依赖空数组"><a href="#依赖空数组" class="header-anchor">#</a> 依赖空数组</h3> <p>[] (空数组) 仅在组件首次渲染（挂载）后执行 1 次。</p> <h3 id="依赖一个值"><a href="#依赖一个值" class="header-anchor">#</a> 依赖一个值</h3> <p>在首次渲染后执行，并且在 count 变量发生变化后的每一次渲染后执行。</p> <h2 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h2> <h3 id="连接到外部系统"><a href="#连接到外部系统" class="header-anchor">#</a> 连接到外部系统</h3> <p>有些组件在页面上显示时，需要与网络、某些浏览器 API 或第三方库保持连接。这些系统不受 React 控制，因此它们被称为外部系统。</p> <p>要在组件的顶层调用 将你的组件连接到某个外部系统，请调用 useEffect：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createConnection <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./chat.js&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> setServerUrl<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>你需要将两个参数传递给 useEffect：
<ol><li>具有连接到该系统的 setup code 的设置函数。
<ul><li>它应该返回一个清理函数，其中包含与该系统断开连接的 清理代码。</li></ul></li> <li>依赖列表，包括在这些函数中使用的组件中的每个值。</li></ol></li></ul> <p><strong>React 会在必要时调用你的设置和清理函数，这可能会发生多次：</strong></p> <ol><li><p>组件挂载时运行设置代码</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;设置代码运行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 组件挂载时执行</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;清理代码运行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>首次渲染：只有设置函数执行</p> <p>生产环境表现：组件添加到 DOM 后立即运行设置函数</p> <p>开发环境表现：在严格模式下，React 可能会先挂载 → 卸载 → 重新挂载组件来检测问题</p></li> <li><p>依赖项变化时的执行顺序</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;设置代码运行，当前count:&quot;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;清理代码运行，上一个count:&quot;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖count</span>
</code></pre></div><p>当 count 从 1 变为 2 时的执行顺序：</p> <p>清理阶段：使用旧值(1)运行清理函数</p> <p>设置阶段：使用新值(2)运行设置函数</p></li> <li><p>组件卸载时的清理</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 组件卸载时执行</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当组件从 DOM 移除时，React 会执行最后一次清理</p> <p>这是防止内存泄漏的关键机制</p></li></ol> <ul><li><p>实际场景示例
订阅数据源示例</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;订阅用户数据，ID:&quot;</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;取消订阅，ID:&quot;</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>userId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖 userId</span>
</code></pre></div><p>当 userId 变化时的执行流程：</p> <ol><li><p>用户 A(id=1)进入页面：</p> <p>输出：&quot;订阅用户数据，ID:1&quot;</p></li> <li><p>用户切换到用户 B(id=2)：</p> <p>输出：&quot;取消订阅，ID:1&quot; (清理旧订阅)</p> <p>输出：&quot;订阅用户数据，ID:2&quot; (设置新订阅)</p></li> <li><p>离开页面：</p> <p>输出：&quot;取消订阅，ID:2&quot; (最终清理)</p></li></ol></li> <li><p>为什么需要这种机制？
资源管理：避免内存泄漏(如未清除的定时器、订阅)</p> <p>状态一致性：确保 Effect 总是使用最新的 props 和 state</p> <p>竞态条件预防：清理函数可以取消旧的异步请求</p></li> <li><p>开发 vs 生产环境差异</p> <ul><li><p>开发环境：</p> <p>严格模式下会故意多次挂载/卸载组件</p> <p>帮助你发现忘记清理资源的问题</p></li> <li><p>生产环境：</p> <p>更直接的执行流程</p> <p>但基本机制保持不变</p></li></ul></li> <li><p>最佳实践
每个 Effect 只做一件事：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 好：分离关注点</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 订阅逻辑 */</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>userId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 动画逻辑 */</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>返回清理函数：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;resize&quot;</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>正确处理依赖：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 依赖所有用到的外部值</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> userId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>理解这种&quot;设置 → 清理 → 设置&quot;的循环模式，是掌握 React useEffect 管理的关键。这确保了资源被正确管理，应用行为可预测。</p></li></ul> <h3 id="自定义钩子中的封装-useeffect"><a href="#自定义钩子中的封装-useeffect" class="header-anchor">#</a> 自定义钩子中的封装 useEffect</h3> <p>useEffect 是一个 “应急方案”：，当你需要 “走出 React” 并且没有更好的内置解决方案适合你的用例时，你可以使用它们。如果你发现自己经常需要手动编写 useEffect，这通常表明你需要为组件所依赖的常见行为提取一些 自定义钩子。</p> <p>例如，这个 useChatRoom 自定义钩子 “hides” 你的 useEffect 的逻辑背后是一个更具声明性的 API：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">useChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> serverUrl<span class="token punctuation">,</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> serverUrl<span class="token punctuation">,</span>
      <span class="token literal-property property">roomId</span><span class="token operator">:</span> roomId<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">,</span> serverUrl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后你可以像这样从任何组件使用它：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> setServerUrl<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useChatRoom</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">roomId</span><span class="token operator">:</span> roomId<span class="token punctuation">,</span>
    <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> serverUrl<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
</code></pre></div><p>React 生态系统中还有许多优秀的自定义钩子可用于各种用途。</p> <h3 id="控制非-react-小部件"><a href="#控制非-react-小部件" class="header-anchor">#</a> 控制非 React 小部件</h3> <p>有时，你希望使外部系统与组件的某些属性或状态保持同步。</p> <p>例如，如果你有一个第三方地图小部件或一个没有使用 React 编写的视频播放器组件，你可以使用 useEffect 来调用它的方法，使其状态与你的 React 组件的当前状态相匹配。这个 useEffect 创建了一个在 map-widget.js 中定义的 MapWidget 类的实例。当你更改 Map 组件的 zoomLevel 属性时，useEffect 会调用类实例上的 setZoom() 以保持同步：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useRef<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> MapWidget <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./map-widget.js&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Map</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> zoomLevel <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> containerRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> mapRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapRef<span class="token punctuation">.</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      mapRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapWidget</span><span class="token punctuation">(</span>containerRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> map <span class="token operator">=</span> mapRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">setZoom</span><span class="token punctuation">(</span>zoomLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>zoomLevel<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">200</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>containerRef<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在此示例中，不需要清理函数，因为 MapWidget 类仅管理传递给它的 DOM 节点。从树中移除 Map React 组件后，DOM 节点和 MapWidget 类实例都会被浏览器 JavaScript 引擎自动垃圾回收。</p> <h3 id="使用-useeffect-请求数据"><a href="#使用-useeffect-请求数据" class="header-anchor">#</a> 使用 useEffect 请求数据</h3> <p>你可以使用 useEffect 为你的组件获取数据。请注意，使用框架的数据请求机制的 如果你使用框架， 将比手动编写 useEffect 更有效。
如果你想手动从 useEffect 中获取数据，你的代码可能如下所示：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> fetchBio <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./api.js'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>person<span class="token punctuation">,</span> setPerson<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>bio<span class="token punctuation">,</span> setBio<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ignore <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 1. 定义标志变量</span>
    <span class="token function">setBio</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 重置状态</span>

    <span class="token function">fetchBio</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 3. 发起请求</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 4. 检查标志</span>
        <span class="token function">setBio</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 5. 安全更新状态</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 6. 清理函数</span>
        ignore <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment">// 7. 标记为忽略</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>person<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 8. 依赖person变化</span>

  <span class="token comment">// ...</span>
</code></pre></div><ul><li><p>竞态条件问题说明
假设以下场景：</p> <p>快速切换 person 从&quot;Alice&quot;到&quot;Bob&quot;再到&quot;Charlie&quot;</p> <p>三个请求依次发出，但响应顺序可能是：</p> <p>Bob 的响应(慢)</p> <p>Alice 的响应(最慢)</p> <p>Charlie 的响应(最快)</p> <p>没有防护时，Alice 的响应可能最后到达，错误地覆盖了当前显示的 Charlie 的数据。</p> <ul><li><p>ignore 机制如何工作</p> <ul><li><p>组件挂载/更新时：
ignore 初始化为 false
发起新请求</p></li> <li><p>person 变化时(重新渲染)：</p> <ul><li><p>执行上一次 Effect 的清理函数，将旧请求的 ignore 设为 true</p></li> <li><p>新 Effect 运行，新的 ignore 变量(false)被创建</p></li></ul></li> <li><p>请求完成时：</p> <ul><li><p>只有 ignore 为 false 的响应会更新状态</p></li> <li><p>被&quot;忽略&quot;的请求响应到达时不会执行 setBio</p></li></ul></li></ul></li> <li><p>为什么这种模式有效
闭包机制：每个 Effect 调用都有自己的 ignore 变量</p> <p>执行顺序保证：React 总是先执行前一个 Effect 的清理，再运行新 Effect</p> <p>请求隔离：每个请求的响应处理只影响自己的渲染周期</p></li> <li><p>实际应用场景
搜索框输入：快速连续输入时，只显示最后输入的结果</p> <p>选项卡切换：快速切换时，只显示最后选中选项卡的内容</p> <p>分页数据：快速翻页时，确保显示正确的页面数据</p> <ul><li><p>现代替代方案
虽然这种模式有效，但现代 React 开发更推荐：</p> <ul><li>使用框架提供的数据获取：</li></ul> <p>Next.js 的 getServerSideProps/getStaticProps</p> <p>Remix 的 loader</p> <p>React Router 的 loader</p> <ul><li>使用数据获取库：</li></ul> <p>SWR</p> <p>React Query</p> <p>Apollo Client(GraphQL)</p></li></ul></li></ul></li></ul> <p>这些方案内置了竞态条件处理、缓存、重试等高级功能。</p> <h3 id="指定反应依赖"><a href="#指定反应依赖" class="header-anchor">#</a> 指定反应依赖</h3> <h4 id="依赖项必须完整声明"><a href="#依赖项必须完整声明" class="header-anchor">#</a> 依赖项必须完整声明</h4> <p>React 强调所有在 Effect 内部使用的响应式值（reactive values）都必须声明为依赖项。响应式值包括：</p> <ul><li><p>组件 props（如 roomId）</p></li> <li><p>组件 state（如 serverUrl）</p></li> <li><p>组件内部定义的变量和函数</p></li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// ✅ 正确：所有用到的响应式值都声明为依赖</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 必须包含所有依赖</span>
</code></pre></div><h4 id="不能选择性忽略依赖"><a href="#不能选择性忽略依赖" class="header-anchor">#</a> 不能选择性忽略依赖</h4> <p>开发者不能随意挑选依赖，必须完整声明所有用到的响应式值。如果遗漏依赖：</p> <ul><li><p>React 会在开发时通过 lint 规则报错</p></li> <li><p>可能导致 Effect 无法及时响应数据变化</p></li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 🔴 错误：遗漏了serverUrl依赖</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缺少serverUrl</span>
</code></pre></div><h4 id="减少依赖的合法方式"><a href="#减少依赖的合法方式" class="header-anchor">#</a> 减少依赖的合法方式</h4> <p>如果确实需要减少依赖，应该通过代码结构调整来实现，而不是忽略 lint 警告：</p> <ul><li><p>方式一：将值移出组件</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> serverUrl <span class="token operator">=</span> <span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 不再是响应式值</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 现在只需要roomId</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>方式二：使用 useMemo/useCallback</p></li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> <span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">,</span>
      roomId<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 依赖更简洁</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li>空依赖数组的特殊含义</li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这段代码只会在组件挂载时运行一次</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空数组表示不依赖任何响应式值</span>
</code></pre></div><p>空数组表示：</p> <p>Effect 不依赖于任何 props 或 state</p> <p>只在组件挂载时运行一次</p> <p>适合初始化非 React 相关的第三方库等场景</p> <p>当你的组件的任何属性或状态发生变化时，具有空依赖的 useEffect 不会重新运行。</p> <h4 id="不要压制-lint-警告"><a href="#不要压制-lint-警告" class="header-anchor">#</a> 不要压制 lint 警告</h4> <p>官方强烈反对这种写法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 🔴 危险！不要这样做</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>压制 lint 警告会导致：</p> <p>难以发现的 bug</p> <p>Effect 无法正确响应数据变化</p> <p>代码维护困难</p> <p>核心思想总结</p> <ul><li><p>诚实声明依赖：Effect 用到的所有响应式值都必须声明</p></li> <li><p>通过重构而非压制来优化：如果依赖过多，应该重构代码而非忽略警告</p></li> <li><p>依赖项决定 Effect 的执行时机：React 根据依赖变化决定是否重新执行 Effect</p></li> <li><p>空依赖数组有特殊含义：明确表示 Effect 不依赖任何响应式数据</p></li></ul> <h3 id="根据-useeffect-的先前状态更新状态"><a href="#根据-useeffect-的先前状态更新状态" class="header-anchor">#</a> 根据 useEffect 的先前状态更新状态</h3> <p>当你想根据 useEffect 的先前状态更新状态时，你可能会遇到问题：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// You want to increment the counter every second...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 ... but specifying `count` as a dependency always resets the interval.</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于 count 是一个反应值，因此必须在依赖列表中指定它。但是，这会导致每次 count 更改时重新执行 useEffect，从而导致 intervalId 的清除和重新设置。这并不理想。</p> <p>要解决此问题，通过 c =&gt; c + 1 状态更新器 到 setCount：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Pass a state updater</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ Now count is not a dependency</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="移除不必要的对象依赖"><a href="#移除不必要的对象依赖" class="header-anchor">#</a> 移除不必要的对象依赖</h3> <p>如果你的 useEffect 依赖于渲染期间创建的对象或函数，则它可能会运行得太频繁。例如，此 useEffect 在每次渲染后重新连接，因为 options 对象是 每个渲染都不同：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> serverUrl <span class="token operator">=</span> <span class="token string">'https://localhost:1234'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// 🚩 This object is created from scratch on every re-render</span>
    <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> serverUrl<span class="token punctuation">,</span>
    <span class="token literal-property property">roomId</span><span class="token operator">:</span> roomId
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// It's used inside the Effect</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 As a result, these dependencies are always different on a re-render</span>
  <span class="token comment">// ...</span>
</code></pre></div><p>修复后的代码，直接在 Effect 内部创建对象，依赖原始值</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> serverUrl <span class="token operator">=</span> <span class="token string">&quot;https://localhost:1234&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> serverUrl<span class="token punctuation">,</span>
      <span class="token literal-property property">roomId</span><span class="token operator">:</span> roomId<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ serverUrl是常量，不需要作为依赖</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除不必要的函数依赖"><a href="#删除不必要的函数依赖" class="header-anchor">#</a> 删除不必要的函数依赖</h3> <p>如果你的 useEffect 依赖于渲染期间创建的对象或函数，则它可能会运行得太频繁。例如，此 useEffect 在每次渲染后重新连接，因为 createOptions 函数是 每个渲染都不同：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ChatRoom</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">createOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 🚩 This function is created from scratch on every re-render</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">serverUrl</span><span class="token operator">:</span> serverUrl<span class="token punctuation">,</span>
      <span class="token literal-property property">roomId</span><span class="token operator">:</span> roomId
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">createOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// It's used inside the Effect</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>createOptions<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 As a result, these dependencies are always different on a re-render</span>
  <span class="token comment">// ...</span>
</code></pre></div><p>函数和对象都是引用类型，作为依赖有相同的问题。</p> <h2 id="故障排除"><a href="#故障排除" class="header-anchor">#</a> 故障排除</h2> <h3 id="我的-useeffect-在组件挂载时运行两次"><a href="#我的-useeffect-在组件挂载时运行两次" class="header-anchor">#</a> 我的 useEffect 在组件挂载时运行两次</h3> <p>当严格模式打开时，在开发中，React 在实际设置之前额外运行一次设置和清理。</p> <p>这是一个压力测试，用于验证你的 useEffect 逻辑是否正确实现。如果这导致可见问题，则说明你的清理函数缺少某些逻辑。清理函数应该停止或撤消设置函数正在做的任何事情。经验法则是用户不应该能够区分调用一次的设置（如在生产中）和设置 → 清理 → 设置序列（如在开发中）。</p> <h3 id="我的-useeffect-在每次重新渲染后运行"><a href="#我的-useeffect-在每次重新渲染后运行" class="header-anchor">#</a> 我的 useEffect 在每次重新渲染后运行</h3> <p>首先，检查你是否没有忘记指定依赖数组：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 No dependency array: re-runs after every render!</span>
</code></pre></div><p>如果你指定了依赖数组，但你的 useEffect 仍然在循环中重新运行，那是因为你的一个依赖在每次重新渲染时都不同。</p> <p>你可以通过手动将依赖记录到控制台来调试此问题：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后，你可以在控制台中右键单击来自不同重新渲染的数组，并为它们选择 “存储为全局变量”。假设第一个保存为 temp1，第二个保存为 temp2，那么你可以使用浏览器控制台检查两个数组中的每个依赖是否相同：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>temp1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Is the first dependency the same between the arrays?</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>temp1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Is the second dependency the same between the arrays?</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>temp1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ... and so on for every dependency ...</span>
</code></pre></div><ul><li><p><a href="#%E6%A0%B9%E6%8D%AEuseEffect%E7%9A%84%E5%85%88%E5%89%8D%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81">根据 useEffect 的先前状态更新状态</a></p></li> <li><p><a href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BE%9D%E8%B5%96">移除不必要的对象依赖</a></p></li> <li><p><a href="#%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">删除不必要的函数依赖</a></p></li></ul> <h3 id="我的-useeffect-在无限循环中不断重新运行"><a href="#我的-useeffect-在无限循环中不断重新运行" class="header-anchor">#</a> 我的 useEffect 在无限循环中不断重新运行</h3> <p>如果你的 useEffect 以无限循环运行，则以下两点必须为真：</p> <p>你的 useEffect 正在更新一些状态。</p> <p>该状态会导致重新渲染，从而导致 useEffect 的依赖发生变化。</p> <p>在开始解决问题之前，先问问自己 useEffect 是否连接到某个外部系统（如 DOM、网络、第三方小部件等）。为什么你的 useEffect 需要设置状态？它是否与该外部系统同步？或者你是否正在尝试使用它来管理应用的数据流？</p> <p>如果没有外部系统，请考虑 完全删除 useEffect 是否会简化你的逻辑。</p> <p>如果你真正与某个外部系统同步，请考虑你的 useEffect 应该更新状态的原因和条件。有什么改变影响了你的组件的视觉输出吗？如果你需要跟踪渲染未使用的某些数据，引用（不会触发重新渲染）可能更合适。验证你的 useEffect 不会比需要更多地更新状态（并触发重新渲染）。</p> <p>最后，如果你的 useEffect 在正确的时间更新状态，但仍然存在循环，那是因为该状态更新导致 useEffect 的依赖之一发生变化。阅读<a href="#%E6%88%91%E7%9A%84useEffect%E5%9C%A8%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%B8%8D%E6%96%AD%E9%87%8D%E6%96%B0%E8%BF%90%E8%A1%8C">如何调试依赖更改。</a></p> <h3 id="即使我的组件没有卸载-我的清理逻辑仍在运行"><a href="#即使我的组件没有卸载-我的清理逻辑仍在运行" class="header-anchor">#</a> 即使我的组件没有卸载，我的清理逻辑仍在运行</h3> <p>清理函数不仅在卸载期间运行，而且在每次重新渲染更改依赖之前运行。此外，在开发中，React 在组件挂载后立即额外运行一次设置+清理。</p> <p>如果你有清理代码而没有相应的设置代码，通常是代码味道（Code Smell）：
Code Smell:可能存在潜在问题或不良设计模式的警示信号</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 🔴 Avoid: Cleanup logic without corresponding setup logic</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你的清理逻辑应该是设置逻辑的 “symmetrical”，并且应该停止或撤消任何设置所做的事情：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  connection<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    connection<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="我的-useeffect-做了一些视觉-useeffect-我在它运行前看到了闪烁"><a href="#我的-useeffect-做了一些视觉-useeffect-我在它运行前看到了闪烁" class="header-anchor">#</a> 我的 useEffect 做了一些视觉 useEffect，我在它运行前看到了闪烁</h3> <p>如果你的 useEffect 必须阻止浏览器访问 绘画屏幕，请将 useEffect 替换为 useLayoutEffect。请注意，绝大多数效果都不需要这样做。仅当在浏览器绘制之前运行效果至关重要时，你才需要它：例如，在用户看到之前测量和定位工具提示。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.f81cf313.js" defer></script><script src="/jiabinxu-blog/assets/js/3.bb87b8ff.js" defer></script><script src="/jiabinxu-blog/assets/js/2.180c3171.js" defer></script><script src="/jiabinxu-blog/assets/js/40.42a528d4.js" defer></script>
  </body>
</html>
