<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>useState | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.ec81c2a4.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.c5fdad7d.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.34d20650.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/46.e5568ed9.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.90fb1753.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.b39679df.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.8187523c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.0bc8e462.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.ccfaad73.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.cec46538.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.380c784d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.bfab453a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.6516dd9c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.52e99ec1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.33ab9282.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.20d5488c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.da345bbd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.306efef7.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.257df29b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.8f6a39a4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.b9965851.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.da12a983.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.94ca7cf0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.629923f3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.eb4c3c24.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.189b8eea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.309f3546.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.8ebea494.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.e84b982a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.e9872d14.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.13bfd9fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.d36e48f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.44ec783e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.04437602.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.05896a6c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.77566d25.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.771b0795.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.4f5d6672.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.80005314.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.13eb153e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.81101b31.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1111d26e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.4e36f15a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.426d3a06.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.0cddb7d0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.3b97796b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.ca777a9f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.8d56997f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.53a63991.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.c37f8662.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.85309368.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.e90aa37c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.37829d64.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.42652f54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.9a0bab4a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.605d1390.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.c655efdc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.f71f155e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.fe87e7ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.3e9861fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.987510dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>useState</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/React/Hooks/useState.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#usestate-initialstate" class="sidebar-link">useState(initialState)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#set-函数与-setsomething-nextstate-类似" class="sidebar-link">set 函数与 setSomething(nextState)类似</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useState.html#用法" class="sidebar-link">用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#向组件添加状态" class="sidebar-link">向组件添加状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#根据之前的状态更新状态" class="sidebar-link">根据之前的状态更新状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#更新状态中的对象和数组" class="sidebar-link">更新状态中的对象和数组</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#使用键来重置状态" class="sidebar-link">使用键来重置状态</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#存储以前渲染的信息" class="sidebar-link">存储以前渲染的信息</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useState.html#故障排除" class="sidebar-link">故障排除</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#我更新了状态-但日志记录给了我旧值" class="sidebar-link">我更新了状态，但日志记录给了我旧值</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#我已经更新了状态-但是屏幕没有更新" class="sidebar-link">我已经更新了状态，但是屏幕没有更新</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#我收到错误-太多的重新渲染" class="sidebar-link">我收到错误：“太多的重新渲染”</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#我的初始化或更新函数运行两次" class="sidebar-link">我的初始化或更新函数运行两次</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/Hooks/useState.html#我正在尝试将状态设置为一个函数-但它被调用了" class="sidebar-link">我正在尝试将状态设置为一个函数，但它被调用了</a></li></ul></li><li><a href="/jiabinxu-blog/React/Hooks/useState.html#源码理解" class="sidebar-link">源码理解</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h1> <p>useState 是一个 React 钩子，可让你将 状态变量 添加到组件中。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <h3 id="usestate-initialstate"><a href="#usestate-initialstate" class="header-anchor">#</a> useState(initialState)</h3> <p>useState(initialState)
在组件的顶层调用 useState 以声明 状态变量。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Taylor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todos<span class="token punctuation">,</span> setTodos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createTodos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre></div><p>约定是使用 数组解构 命名状态变量，例如 [something, setSomething]。</p> <h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <p>initialState：你希望状态的初始值。它可以是任何类型的值，但函数有特殊的行为。这个参数在初始渲染后被忽略。</p> <p>如果你将函数作为 initialState 传递，它将被视为初始化函数。它应该是纯粹的，不带任何参数，并且应该返回任何类型的值。React 在初始化组件时会调用你的初始化函数，并将其返回值存储为初始状态。<a href="#%E7%94%A8%E6%B3%95">请参见下面的示例</a>。</p> <p>初始化参数的两种方式</p> <ul><li>普通初始化 useState(value) 每次渲染都会执行表达式，但只用第一次的结果 初始值简单</li> <li>惰性初始化 useState(() =&gt; value) 只在首次渲染时执行 初始值计算复杂</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通初始化</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>nums<span class="token punctuation">,</span> setNums<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每次渲染都执行一次 new Array...</span>

<span class="token comment">// 惰性初始化</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>nums<span class="token punctuation">,</span> setNums<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只有首次渲染才执行一次</span>
</code></pre></div><h4 id="返回"><a href="#返回" class="header-anchor">#</a> 返回</h4> <p>Returns</p> <p>useState 返回一个恰好包含两个值的数组：</p> <p>当前状态。在第一次渲染期间，它将与你传递的 initialState 相匹配。</p> <p>set 函数 允许你将状态更新为不同的值并触发重新渲染。</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <p>useState 是一个 Hook，所以你只能在你的组件的顶层或者你自己的钩子中调用它。你不能在循环或条件内调用它。如果需要，提取一个新组件并将状态移入其中。</p> <p>在严格模式下，React 将调用你的初始化函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的初始化函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。</p> <h3 id="set-函数与-setsomething-nextstate-类似"><a href="#set-函数与-setsomething-nextstate-类似" class="header-anchor">#</a> set 函数与 setSomething(nextState)类似</h3> <p>useState 返回的 set 函数允许你将状态更新为不同的值并触发重新渲染。你可以直接传递下一个状态，或从前一个状态计算它的函数：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Edward'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'Taylor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre></div><h4 id="参数-2"><a href="#参数-2" class="header-anchor">#</a> 参数</h4> <p>nextState：你希望状态成为的值。它可以是任何类型的值，但函数有特殊的行为。</p> <p>如果你将函数作为 nextState 传递，它将被视为更新函数。它必须是纯粹的，应该将挂起状态作为其唯一参数，并且应该返回下一个状态。React 会将你的更新程序函数放入队列中并重新渲染你的组件。在下一次渲染期间，React 将通过将所有排队的更新器应用于前一个状态来计算下一个状态。<a href="#%E6%A0%B9%E6%8D%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81">请参见下面的示例</a>。</p> <h4 id="返回-2"><a href="#返回-2" class="header-anchor">#</a> 返回</h4> <p>set 函数没有返回值。</p> <h4 id="注意事项-2"><a href="#注意事项-2" class="header-anchor">#</a> 注意事项</h4> <ul><li><p><strong>set 函数仅更新下一次渲染的状态变量</strong>。如果你在调用 set 函数后读取状态变量，则 <strong>你仍然会得到旧的值</strong> 在你调用之前显示在屏幕上。</p></li> <li><p>如果你提供的新值与当前的 state 相同（通过 Object.is 比较确定），React 将跳过重新渲染组件及其子组件。这是一个优化。尽管在某些情况下 React 可能仍需要在跳过子级之前调用你的组件，但这不应该影响你的代码。</p></li> <li><p>React 批量状态更新。 在所有事件处理程序运行并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在极少数情况下，你需要强制 React 提前更新屏幕，例如访问 DOM，你可以使用 flushSync。</p></li> <li><p>set 函数具有稳定的标识，因此你经常会看到它从副作用依赖中省略，但包含它不会导致副作用触发。如果 linter 允许你在没有错误的情况下省略依赖，那么这样做是安全的。详细了解如何删除副作用依赖。</p></li> <li><p>在渲染期间调用 set 函数只能从当前渲染组件中调用。React 将丢弃其输出并立即尝试使用新状态再次渲染它。这种模式很少需要，但你可以使用它来存储先前渲染的信息。<a href="#%E5%AD%98%E5%82%A8%E4%BB%A5%E5%89%8D%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BF%A1%E6%81%AF">请参见下面的示例</a>。</p></li> <li><p>在严格模式下，React 将调用你的更新程序函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的更新程序函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。</p></li></ul> <h2 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h2> <h3 id="向组件添加状态"><a href="#向组件添加状态" class="header-anchor">#</a> 向组件添加状态</h3> <p>在组件的顶层调用 useState 以声明一个或多个 状态变量。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'Taylor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
</code></pre></div><p>约定是使用 数组解构 命名状态变量，例如 [something, setSomething]。</p> <p>useState 返回一个恰好包含两项的数组：</p> <p>此状态变量的当前状态，初始设置为你提供的初始状态。</p> <p>set 函数 允许你将其更改为任何其他值以响应交互。</p> <p>要更新屏幕上的内容，请使用下一个状态调用 set 函数：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Robin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>React 将存储下一个状态，使用新值再次渲染你的组件，并更新 UI。</p> <h4 id="易犯错误"><a href="#易犯错误" class="header-anchor">#</a> 易犯错误</h4> <p>调用 set 函数 不会改变已经执行的代码中的当前状态：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Robin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Still &quot;Taylor&quot;!</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它只影响 useState 从下一次渲染开始返回的内容。</p> <h3 id="根据之前的状态更新状态"><a href="#根据之前的状态更新状态" class="header-anchor">#</a> 根据之前的状态更新状态</h3> <p>假设 age 是 42。此处理程序调用 setAge(age + 1) 三次：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(42 + 1)</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(42 + 1)</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(42 + 1)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，点击之后，age 只会变成 43，而不是 45！这是因为在已经运行的代码中调用 set 函数 不会更新 age 状态变量。所以每次 setAge(age + 1) 调用都变成 setAge(43)。</p> <p>为了解决这个问题，你可以将更新函数传递给 setAge 而不是下一个状态：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(42 =&gt; 43)</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(43 =&gt; 44)</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// setAge(44 =&gt; 45)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，a =&gt; a + 1 是你的更新函数。它采用 挂起状态 并从中计算出 下一个状态。</p> <p>React 将你的更新函数放到 队列 中。然后，在下一次渲染期间，它将以相同的顺序调用它们：</p> <p>a =&gt; a + 1 将接收 42 作为挂起状态，并返回 43 作为下一个状态。</p> <p>a =&gt; a + 1 将接收 43 作为挂起状态，并返回 44 作为下一个状态。</p> <p>a =&gt; a + 1 将接收 44 作为挂起状态，并返回 45 作为下一个状态。</p> <p>没有其他排队的更新，所以 React 最后会将 45 存储为当前状态。</p> <p>按照惯例，通常将状态变量名称的第一个字母命名为挂起状态参数，例如 a 代表 age。但是，你也可以将其称为 prevAge 或你认为更清楚的其他名称。</p> <p>React 可能在开发中 <a href="#%E6%88%91%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E4%B8%A4%E6%AC%A1">两次调用你的更新器</a> 以验证它们是 纯粹的。</p> <h3 id="更新状态中的对象和数组"><a href="#更新状态中的对象和数组" class="header-anchor">#</a> 更新状态中的对象和数组</h3> <p>你可以将对象和数组放入状态。在 React 中，状态被认为是只读的，因此你应该替换它而不是改变现有的对象。例如，如果你有一个状态为 form 的对象，不要改变它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 🚩 Don't mutate an object in state like this:</span>
form<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">&quot;Taylor&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>而是，通过创建一个新对象来替换整个对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ✅ Replace state with a new object</span>
<span class="token function">setForm</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>form<span class="token punctuation">,</span>
  <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">&quot;Taylor&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="使用键来重置状态"><a href="#使用键来重置状态" class="header-anchor">#</a> 使用键来重置状态</h3> <p>当 渲染列表 时，你会经常遇到 key 属性。但是，它还有另一个用途。</p> <p>你可以通过将不同的 key 传递给组件来重置组件的状态。在此示例中，“重置”按钮更改 version 状态变量，我们将其作为 key 传递给 Form。当 key 改变时，React 从头开始重新创建 Form 组件（及其所有子级），因此它的状态被重置。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>version<span class="token punctuation">,</span> setVersion<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setVersion</span><span class="token punctuation">(</span>version <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleReset<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Reset</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Form</span></span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>version<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Taylor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setName</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Hello, </span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token plain-text">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="存储以前渲染的信息"><a href="#存储以前渲染的信息" class="header-anchor">#</a> 存储以前渲染的信息</h3> <p>通常，你将在事件处理程序中更新状态。但是，在极少数情况下，你可能希望根据渲染调整状态 - 例如，你可能希望在属性更改时更改状态变量。</p> <p>在大多数情况下，你不需要这样：</p> <p>如果你需要的值可以完全根据当前的属性或其他状态计算出来，那么 完全删除该冗余状态。 如果你担心重新计算过于频繁，那么 useMemo 钩子 可以提供帮助。</p> <p>如果你想重置整个组件树的状态，将不同的 key 传递给你的组件。</p> <p>如果可以，请更新事件处理程序中的所有相关状态。</p> <p>在极少数情况下，这些都不适用，你可以使用一种模式根据目前已渲染的值更新状态，方法是在组件渲染时调用 set 函数。</p> <p>这是一个例子。这个 CountLabel 组件显示传递给它的 count 属性：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">CountLabel</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你这样使用那么将会造成页面无限渲染</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">InfiniteLoopComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 错误：无条件调用setState</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每次渲染都会触发状态更新</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Count: </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>组件首次渲染，count 初始化为 0</p> <p>执行 setCount(0 + 1)，计划将 count 更新为 1</p> <p>React 重新渲染组件</p> <p>再次执行 setCount(1 + 1)，计划将 count 更新为 2</p> <p>这个过程会无限继续下去</p> <h2 id="故障排除"><a href="#故障排除" class="header-anchor">#</a> 故障排除</h2> <h3 id="我更新了状态-但日志记录给了我旧值"><a href="#我更新了状态-但日志记录给了我旧值" class="header-anchor">#</a> 我更新了状态，但日志记录给了我旧值</h3> <p>调用 set 函数不会更改运行代码中的状态：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>

  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Request a re-render with 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Still 0!</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Also 0!</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是因为 状态的行为类似于快照。 更新状态请求另一个具有新状态值的渲染，但不会影响你已经运行的事件处理程序中的 count JavaScript 变量。</p> <p>如果需要使用下一个状态，可以将其保存在变量中，然后再传递给 set 函数：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> nextCount <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">setCount</span><span class="token punctuation">(</span>nextCount<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nextCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre></div><h3 id="我已经更新了状态-但是屏幕没有更新"><a href="#我已经更新了状态-但是屏幕没有更新" class="header-anchor">#</a> 我已经更新了状态，但是屏幕没有更新</h3> <p>如果下一个状态等于前一个状态（由 Object.is 比较确定），React 将忽略你的更新。当你直接更改状态中的对象或数组时，通常会发生这种情况：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 Wrong: mutating existing object</span>
<span class="token function">setObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🚩 Doesn't do anything</span>
</code></pre></div><p>你改变了一个现有的 obj 对象并将它传递回 setObj，所以 React 忽略了更新。要解决此问题，你需要确保你始终是 替换状态中的对象和数组而不是改变它们：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// ✅ Correct: creating a new object</span>
<span class="token function">setObj</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>obj<span class="token punctuation">,</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="我收到错误-太多的重新渲染"><a href="#我收到错误-太多的重新渲染" class="header-anchor">#</a> 我收到错误：“太多的重新渲染”</h3> <p>你可能会收到一条错误消息：Too many re-renders. React limits the number of renders to prevent an infinite loop. 通常，这意味着你在渲染期间无条件设置状态，因此你的组件进入循环：渲染、设置状态（导致渲染）、渲染、设置状态（导致渲染），以此类推。通常，这是由于指定事件处理程序的错误造成的：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 🚩 Wrong: calls the handler during render</span>
<span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>

<span class="token comment">// ✅ Correct: passes down the event handler</span>
<span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>

<span class="token comment">// ✅ Correct: passes down an inline function</span>
<span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handleClick</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
</code></pre></div><p>如果找不到此错误的原因，请单击控制台中错误旁边的箭头并查看 JavaScript 堆栈以查找导致错误的特定 set 函数调用。</p> <h3 id="我的初始化或更新函数运行两次"><a href="#我的初始化或更新函数运行两次" class="header-anchor">#</a> 我的初始化或更新函数运行两次</h3> <p>在 严格模式 中，React 将调用你的一些函数两次而不是一次：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">TodoList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This component function will run twice for every render.</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>todos<span class="token punctuation">,</span> setTodos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// This initializer function will run twice during initialization.</span>
    <span class="token keyword">return</span> <span class="token function">createTodos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTodos</span><span class="token punctuation">(</span><span class="token parameter">prevTodos</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// This updater function will run twice for every click.</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prevTodos<span class="token punctuation">,</span> <span class="token function">createTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
</code></pre></div><p>这是预期的，不应破坏你的代码。</p> <p>这种仅用于开发的行为可以帮助你 保持组件纯粹。 React 使用其中一个调用的结果，并忽略另一个调用的结果。只要你的组件、初始化器和更新器函数是纯函数，这就不会影响你的逻辑。但是，如果它们不小心不纯，这有助于你发现错误。</p> <p>例如，这个不纯的更新函数改变了状态数组：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">setTodos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevTodos</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 🚩 Mistake: mutating state</span>
  prevTodos<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">createTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为 React 两次调用你的更新函数，你会看到 todo 被添加了两次，所以你会知道有一个错误。在这个例子中，你可以通过 替换数组而不是改变它 来修复错误：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token function">setTodos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevTodos</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ Correct: replacing with new state</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prevTodos<span class="token punctuation">,</span> <span class="token function">createTodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>既然这个更新函数是纯粹的，额外调用它不会对行为产生影响。这就是为什么 React 调用它两次可以帮助你发现错误。只有组件、初始化器和更新器函数需要是纯函数。事件处理程序不需要是纯粹的，因此 React 永远不会调用你的事件处理程序两次。</p> <h3 id="我正在尝试将状态设置为一个函数-但它被调用了"><a href="#我正在尝试将状态设置为一个函数-但它被调用了" class="header-anchor">#</a> 我正在尝试将状态设置为一个函数，但它被调用了</h3> <p>你不能像这样将函数置于状态：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>fn<span class="token punctuation">,</span> setFn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>someFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setFn</span><span class="token punctuation">(</span>someOtherFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为你正在传递一个函数，React 假定 someFunction 是一个 初始化函数，而 someOtherFunction 是一个 更新函数，所以它会尝试调用它们并存储结果。要实际存储一个函数，在这两种情况下都必须将 () =&gt; 放在它们之前。然后 React 将存储你传递的函数。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>fn<span class="token punctuation">,</span> setFn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> someFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setFn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> someOtherFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="源码理解"><a href="#源码理解" class="header-anchor">#</a> 源码理解</h2> <p>首先要理解useState，我们要解决一个核心问题：<strong>函数组件本身是无状态的</strong>，它每次渲染都是一次新的函数调用，执行完后所有局部变量都会丢失。那么，React 是如何在多次渲染之间“记住”这个 state 的呢？</p> <p>React 的秘诀在于，它在<strong>组件函数之外</strong>，为每个组件实例维护了一个<strong>内部数据结构</strong>，这个结构在现代 React 中就是 <strong>Fiber 节点</strong>。这个 Fiber 节点是组件的“身份证”，它在多次渲染之间是持久存在的。</p> <p><code>useState</code> 的内部实现就完全依赖于这个 Fiber 节点：</p> <ol><li><strong>数据结构</strong>：在每个组件的 Fiber 节点上，React 维护了一个<strong>链表</strong>，这个链表专门用来<strong>存储所有的 Hooks</strong>（包括 <code>useState</code>, <code>useEffect</code> 等）。</li> <li><strong>首次渲染</strong>：当组件<strong>第一次渲染</strong>时，你每调用一次 <code>useState</code>，React 就会在这个链表上<strong>创建一个新的节点（Hook 节点）</strong>。这个节点里会保存<strong>当前的状态值</strong>（<code>state</code>）和一个<strong>更新队列</strong>（<code>queue</code>）。</li> <li><strong>后续渲染</strong>：当组件因为状态变更<strong>重新渲染</strong>时，神奇的地方就来了。当 <code>useState</code> 再次被调用时，React <strong>不会</strong>创建新节点，而是会去<strong>按顺序遍历</strong>那个已经存在的 Hook 链表。
<ul><li>你调用的<strong>第一个</strong> <code>useState</code>，React 就取出链表上的<strong>第一个</strong>节点，把里面的状态值返回给你。</li> <li>你调用的<strong>第二个</strong> <code>useState</code>，React 就取出链表上的<strong>第二个</strong>节点，以此类推。</li></ul></li> <li><strong>“Hooks 规则”的原因</strong>：这也完美解释了<strong>为什么 Hooks 必须在顶层调用</strong>，不能放在 <code>if</code> 或循环里。因为 React 完全依赖这个**“稳定不变的调用顺序”**来确保每次都能从链表上拿到正确的状态。如果调用顺序变了，React 在遍历链表时就会“张冠李戴”，导致状态彻底错乱。</li> <li><strong>setState 的工作</strong>：最后，<code>useState</code> 返回的那个 <code>setter</code> 函数（比如 <code>setCount</code>）被调用时，它<strong>并不会立即修改状态</strong>。它做的是两件事：
<ul><li>找到它自己对应的那个 Hook 节点。</li> <li>把这个“更新操作”（比如新的值，或者一个 <code>(prev =&gt; prev + 1)</code> 函数）<strong>放进那个节点的更新队列（queue）里</strong>。</li> <li>最后，它会<strong>调度一次 React 的重新渲染</strong>。</li></ul></li></ol> <p>在下一次渲染时，React 就会回到第 3 步，遍历链表，在计算状态时，会检查更新队列并执行里面的所有操作，从而得到最新的状态值返回给组件。”</p> <p><strong>一句话总结：</strong></p> <p>“所以，<code>useState</code> 的内部实现，本质上就是<strong>依靠一个稳定存在于 Fiber 节点上的 Hook 链表，并通过严格的调用顺序来确保每次渲染都能正确地存取状态。</strong>”</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.ec81c2a4.js" defer></script><script src="/jiabinxu-blog/assets/js/3.c5fdad7d.js" defer></script><script src="/jiabinxu-blog/assets/js/2.34d20650.js" defer></script><script src="/jiabinxu-blog/assets/js/46.e5568ed9.js" defer></script>
  </body>
</html>
