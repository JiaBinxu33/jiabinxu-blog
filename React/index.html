<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 基础部分 | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.f81cf313.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.bb87b8ff.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.180c3171.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/49.ed08971b.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.3c2a6c83.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.3c49b8de.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.91b5c8e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.ef4b17e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.23f5619b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.4bb3669d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.664e814e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.21ad7801.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.d4db7480.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.31141967.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.97e9a047.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.f04bcbc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.f5223a9d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.2e981bab.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.d58d5448.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.fb28f85b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.d10d4810.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.f89661dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.a2c20bce.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.edabae48.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.8f37da54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.86e08cd4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.3ff6f6b3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.42a528d4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.46dbe14a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.0b72d4b8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.7d892d86.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.164a4f16.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.5bc0d409.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.82b75b59.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.e959a5f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.cc983ac3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.9cbc22ee.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.f9457251.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.63e6d8ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.51ebfdbe.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.2e948603.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1907287a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.2aca8e9e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.53572a11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.6c8d55a3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.7c01df11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.1df3a578.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.bf31f66a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.f2feff3d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.d36efdc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.824240b9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.6e5633db.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.0bc9c8bd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.b03cfd91.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.3a221345.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.23192d8d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.e15e8a6b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.d4fc17a1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.bdb98294.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.5b17ac84.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/73.3030d7e2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/74.3329104a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.c9879746.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 基础部分</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/React/#react-的特征" class="sidebar-link">react 的特征</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#jsx-语法" class="sidebar-link">jsx 语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#函数组件和-class-组件区别" class="sidebar-link">函数组件和 class 组件区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#为什么转向函数组件" class="sidebar-link">为什么转向函数组件？</a></li></ul></li><li><a href="/jiabinxu-blog/React/#diff-算法" class="sidebar-link">Diff 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#同层比较" class="sidebar-link">同层比较</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#组件类型比较" class="sidebar-link">组件类型比较</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#key-的比较" class="sidebar-link">key 的比较</a></li></ul></li><li><a href="/jiabinxu-blog/React/#fiber-的核心机制" class="sidebar-link">Fiber 的核心机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#可中断性" class="sidebar-link">可中断性</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#断点重新执行" class="sidebar-link">断点重新执行</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#优先级" class="sidebar-link">优先级</a></li></ul></li><li><a href="/jiabinxu-blog/React/#react-合成事件原理" class="sidebar-link">React 合成事件原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#注意" class="sidebar-link">注意</a></li></ul></li><li><a href="/jiabinxu-blog/React/#mvc-和-mvvm-的区别" class="sidebar-link">MVC 和 MVVM 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-组件通信方法" class="sidebar-link">React 组件通信方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-父组件向子组件通信-props" class="sidebar-link">1. 父组件向子组件通信 (Props)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-子组件向父组件通信-回调函数" class="sidebar-link">2. 子组件向父组件通信 (回调函数)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-跨级组件通信-context-api" class="sidebar-link">3. 跨级组件通信 (Context API)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-状态管理库" class="sidebar-link">4. 状态管理库</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-本地状态共享-hooks" class="sidebar-link">5. 本地状态共享 (Hooks)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_6-非嵌套组件通信-发布-订阅模式" class="sidebar-link">6. 非嵌套组件通信 (发布-订阅模式)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/jiabinxu-blog/React/#事件处理" class="sidebar-link">事件处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-事件命名和绑定" class="sidebar-link">1. 事件命名和绑定</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-阻止默认行为和事件冒泡" class="sidebar-link">2. 阻止默认行为和事件冒泡</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-向事件处理函数传递参数" class="sidebar-link">3. 向事件处理函数传递参数</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-事件对象" class="sidebar-link">4. 事件对象</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-this-指向" class="sidebar-link">5. this 指向</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_6-事件池机制" class="sidebar-link">6. 事件池机制</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_7-常用事件类型" class="sidebar-link">7. 常用事件类型</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_8-事件冒泡与捕获" class="sidebar-link">8. 事件冒泡与捕获</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_9-事件委托" class="sidebar-link">9. 事件委托</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_10-组合使用" class="sidebar-link">10. 组合使用</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结-2" class="sidebar-link">总结</a></li></ul></li><li><a href="/jiabinxu-blog/React/#受控组件与非受控组件" class="sidebar-link">受控组件与非受控组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#hoc-高阶组件" class="sidebar-link">hoc 高阶组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#diff-算法-react-fiber-虚拟-dom" class="sidebar-link">diff 算法 React Fiber 虚拟 dom</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#时间复杂度-空间复杂度" class="sidebar-link">时间复杂度 空间复杂度</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#protal-将组件放到页面中任意你想放的位置" class="sidebar-link">protal 将组件放到页面中任意你想放的位置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-路由" class="sidebar-link">React 路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#react5" class="sidebar-link">React5</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#react-router6" class="sidebar-link">React-Router6</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#hash-和-history" class="sidebar-link">hash 和 history</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#路由鉴权" class="sidebar-link">路由鉴权</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#自定义标签代替-a-标签跳转" class="sidebar-link">自定义标签代替 a 标签跳转</a></li></ul></li><li><a href="/jiabinxu-blog/React/#fetch-和-axios-的区别" class="sidebar-link">fetch 和 axios 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#redux-具体流程-saga" class="sidebar-link">redux 具体流程 saga</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#thunk-和-saga-的区别" class="sidebar-link">thunk 和 saga 的区别</a></li></ul></li><li><a href="/jiabinxu-blog/React/#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件" class="sidebar-link">redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-按需加载" class="sidebar-link">React 按需加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#immutable" class="sidebar-link">immutable</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#webpack" class="sidebar-link">WebPack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-核心思想" class="sidebar-link">1. 核心思想</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-工作机制" class="sidebar-link">2. 工作机制</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-优点" class="sidebar-link">3. 优点</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-缺点" class="sidebar-link">4. 缺点</a></li></ul></li><li><a href="/jiabinxu-blog/React/#webpack-与-grunt、gulp" class="sidebar-link">webpack 与 grunt、gulp</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#类型检查和默认值" class="sidebar-link">类型检查和默认值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#ts-和-js-的区别-使用-typescript-的好处" class="sidebar-link">Ts 和 JS 的区别 使用 typescript 的好处</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数" class="sidebar-link">react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-中的闭包陷阱-closure-trap" class="sidebar-link">React 中的闭包陷阱(Closure Trap)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-什么是闭包陷阱" class="sidebar-link">1. 什么是闭包陷阱？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-经典陷阱案例-setinterval-计数器" class="sidebar-link">2. 经典陷阱案例：setInterval 计数器</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-如何避免闭包陷阱" class="sidebar-link">3. 如何避免闭包陷阱？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-总结" class="sidebar-link">4. 总结</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-参考" class="sidebar-link">5. 参考</a></li></ul></li><li><a href="/jiabinxu-blog/React/#redux-和-mobx-的区别" class="sidebar-link">redux 和 mobx 的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#工作机制对比" class="sidebar-link">工作机制对比</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#内部原理对比" class="sidebar-link">内部原理对比</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#设计哲学" class="sidebar-link">设计哲学</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结对比表" class="sidebar-link">总结对比表</a></li></ul></li><li><a href="/jiabinxu-blog/React/#react-memo" class="sidebar-link">React.memo</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#核心思想-组件的-记忆化" class="sidebar-link">核心思想：组件的“记忆化”</a></li></ul></li><li><a href="/jiabinxu-blog/React/#react-18-启用-fiber-架构" class="sidebar-link">React 18：启用 Fiber 架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#自动批处理-automatic-batching" class="sidebar-link">自动批处理 (Automatic Batching)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#新-hooks" class="sidebar-link">新 Hooks</a></li></ul></li><li><a href="/jiabinxu-blog/React/#react-19-编译器与新架构" class="sidebar-link">React 19：编译器与新架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#react-编译器" class="sidebar-link">React 编译器</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#actions" class="sidebar-link">Actions</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#server-components-rsc-新架构" class="sidebar-link">Server Components (RSC - 新架构)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结-rsc-与-ssr-的协同工作" class="sidebar-link">总结：RSC 与 SSR 的协同工作</a></li></ul></li><li><a href="/jiabinxu-blog/React/#自定义-hooks-的设计规范" class="sidebar-link">自定义 Hooks 的设计规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#目的" class="sidebar-link">目的</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#规范一-必须以-use-开头" class="sidebar-link">规范一：必须以 use 开头</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#规范二-只能在-顶层-调用" class="sidebar-link">规范二：只能在“顶层”调用</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#为什么必须在顶层" class="sidebar-link">为什么必须在顶层？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#hooks-复用的是逻辑-不是状态" class="sidebar-link">Hooks 复用的是逻辑，不是状态</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-基础部分"><a href="#react-基础部分" class="header-anchor">#</a> React 基础部分</h1> <h2 id="react-的特征"><a href="#react-的特征" class="header-anchor">#</a> react 的特征</h2> <p>react 概念：用于构建用户界面的 JavaScript 库，提供了 UI 层面的解决方案</p> <p>react 有几个特征：虚拟 dom 树，jsx 语法，组件化，单向数据流</p> <ul><li>jsx：语法
<ul><li>只能有一个根节点；但是可以相互嵌套</li> <li>换行或者多标签最好加括号,防止 js 自动分号不往后执行；</li></ul></li> <li>虚拟 dom：
<ul><li>虚拟 DOM 是在 DOM 的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟 DOM，最后再批量同步到 DOM 中。</li> <li>在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而仅仅是 JavaScript 对象，称之为虚拟 DOM。</li></ul></li> <li>组件化：
<ul><li>每一个 React 文件都是一个组件，含视图、逻辑操作、数据</li> <li>组件可以被嵌套到其他组件之中</li> <li>注意组件声明需要首字母大写，如<code>&lt;TodoList /&gt;</code></li></ul></li> <li>单向数据流
<ul><li>子组件对于父组件传递过来的数据是【只读】的</li> <li>子组件不可直接修改父组件中的数据，只能通过调用父组件传递过来的方法，来间接修改父组件的数据，形成了单向清晰的数据流</li></ul></li> <li>声明式编程
<ul><li>声明式编程表明想要实现什么目的，应该做什么，但是不指定具体怎么做。</li> <li>声明式点一杯酒，只要告诉服务员：我要一杯酒即可；</li></ul></li></ul> <p>react 的优势：</p> <ul><li>高效灵活</li> <li>声明式的设计，简单使用</li> <li>组件式开发，提高代码复用率</li> <li>单向响应的数据流会比双向绑定的更安全，速度更快</li></ul> <p>react 有函数组件和类组件：类组件有 this 指向，状态和生命周期，函数组件没有，只有 hooks，Hooks 是 16.8 版本才新增的，给函数组件用的，让函数组件拥有类组件的功能</p> <h2 id="jsx-语法"><a href="#jsx-语法" class="header-anchor">#</a> jsx 语法</h2> <p>JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套。可以理解为在 JS 中编写与 XML 类似的语言,一种定义带属性树结构（DOM 结构）的语法
可以通过各种编译器将这些标记编译成标准的 JS 语言。
可以定义包含属性的树状结构的语法，类似 HTML 标签那样的使用，而且更便于代码的阅读。</p> <p>使用 JSX 语法后，你必须要引入 babel 的 JSX 解析器，把 JSX 转化成 JS 语法，这个工作会由 babel 自动完成。同时引入 babel 后，你就可以使用新的 es6 语法，babel 会帮你把 es6 语法转化成 es5 语法，兼容更多的浏览器。</p> <h2 id="函数组件和-class-组件区别"><a href="#函数组件和-class-组件区别" class="header-anchor">#</a> 函数组件和 class 组件区别</h2> <ul><li>工作机制与语法对比</li></ul> <ol><li><p>状态 (State) 管理</p> <ul><li><strong>类组件：</strong> <ul><li>状态必须是一个<strong>单一的 this.state 对象</strong>。</li> <li>必须在 <code>constructor</code> 中初始化 <code>this.state = {}</code>。</li> <li>更新状态<strong>必须</strong>调用 <code>this.setState()</code>。</li> <li><code>this.setState()</code> 会<strong>异步</strong>地“合并”(merge) 你传入的对象到旧 state 中。</li></ul></li> <li><strong>函数组件：</strong> <ul><li><strong>没有 this</strong>。</li> <li>使用 <code>useState</code> Hook 来管理状态。</li> <li><strong>没有限制：</strong> 你可以多次调用 <code>useState</code> 来定义多个、独立的 state 变量（数字、字符串、对象等）。</li> <li>更新状态是调用 <code>setCount()</code> 这样的“替换”函数。它<strong>不会</strong>自动合并对象。</li></ul></li></ul></li> <li><p>生命周期与副作用</p> <ul><li><strong>类组件：</strong> <ul><li>使用<strong>特定的生命周期方法</strong>（<code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>）。</li> <li>逻辑被“割裂”：例如，一个“订阅”的逻辑，它的“建立”代码在 <code>componentDidMount</code> 中，而“清理”代码在 <code>componentWillUnmount</code> 中。</li></ul></li> <li><strong>函数组件：</strong> <ul><li>使用 <code>useEffect</code> Hook 来处理所有“副作用”（包括挂载、更新、卸载）。</li> <li><strong>逻辑集中：</strong> <code>useEffect</code> 将“建立”和“清理”逻辑<strong>组织在一起</strong>（清理函数从 effect 中返回）。</li> <li><code>useEffect</code> 通过一个“依赖项数组”来精确控制何时重新执行，而不是像 <code>componentDidUpdate</code> 那样在每次更新时都执行。</li></ul></li></ul></li> <li><p>this 关键字</p> <ul><li><strong>类组件：</strong> <ul><li><strong>高度依赖 this</strong>。</li> <li><code>this</code> 是复杂性的主要来源。在 <code>render</code> 中访问 state 和 props 必须用 <code>this.state</code> 和 <code>this.props</code>。</li> <li>在事件处理函数（如 <code>onClick</code>）中，<code>this</code> 会丢失上下文，<strong>必须</strong>手动进行“<code>this</code> 绑定”（例如在 <code>constructor</code> 中或使用箭头函数）。</li></ul></li> <li><strong>函数组件：</strong> <ul><li><strong>完全没有 this 关键字</strong>。</li> <li>Props 作为函数参数传入，State 变量直接在函数作用域中访问。极大降低了心智负担。</li></ul></li></ul></li></ol> <h3 id="为什么转向函数组件"><a href="#为什么转向函数组件" class="header-anchor">#</a> 为什么转向函数组件？</h3> <ul><li><p><strong>过去：</strong> 类组件是“容器组件”（负责逻辑和 state），函数组件是“展示组件”（负责 UI）。</p></li> <li><p><strong>现在：</strong> React 团队<strong>推荐</strong>使用函数组件 + Hooks 来编写所有新代码。</p> <ul><li><strong>更简洁：</strong> 代码量更少，没有 <code>class</code> 和 <code>this</code> 的样板代码。</li> <li><strong>易于复用：</strong> Hooks 最大的胜利是**“自定义 Hooks” (Custom Hooks)**。它允许你将“状态逻辑”从组件中提取出来，变成一个可复用的函数。这比类组件的“高阶组件 (HOC)”或“Render Props”模式简单得多。</li> <li><strong>易于维护：</strong> <code>useEffect</code> 按“逻辑功能”组织代码，而不是按“生命周期”割裂代码。</li></ul></li> <li><p>关键点 / 陷阱</p> <ul><li><strong>类组件的陷阱：</strong> <ul><li><code>this</code> 绑定的混乱。</li> <li><code>setState</code> 的异步性：在 <code>setState</code> 后立刻读取 <code>this.state</code> 会读到旧值。</li></ul></li> <li><strong>函数组件的陷阱：</strong> <ul><li><strong>Hooks 规则：</strong> 必须在函数顶层调用 Hooks，不能在循环、条件或嵌套函数中调用。</li> <li><strong>useEffect 依赖项：</strong> 最大的陷阱。忘记在依赖项数组中声明所有用到的 state 或 props，会导致“陈旧闭包”（Stale Closure）问题——Effect 使用了过期的值。</li> <li><strong>心智模型：</strong> 函数组件的 <code>render</code> 更像是在“快照”：每次 state 变化，函数<strong>重新执行</strong>，所有变量（包括 state）都是全新的。</li></ul></li></ul></li></ul> <hr> <ul><li><p>总结对比表</p> <table><thead><tr><th><strong>特性</strong></th> <th><strong>类组件 (Class Component)</strong></th> <th><strong>函数组件 (Function Component)</strong></th></tr></thead> <tbody><tr><td><strong>形态</strong></td> <td>ES6 Class (继承 <code>React.Component</code>)</td> <td>普通 JavaScript 函数</td></tr> <tr><td><strong>状态管理</strong></td> <td><code>this.state</code> (单一对象) / <code>this.setState()</code></td> <td><code>useState()</code> (多个独立变量)</td></tr> <tr><td><strong>生命周期</strong></td> <td><code>componentDidMount</code>, <code>componentDidUpdate</code> 等</td> <td><code>useEffect()</code></td></tr> <tr><td><strong>this 关键字</strong></td> <td><strong>必须使用</strong>，且需要处理绑定问题</td> <td><strong>完全没有 this</strong></td></tr> <tr><td><strong>逻辑复用</strong></td> <td>高阶组件 (HOC), Render Props (复杂)</td> <td><strong>自定义 Hooks</strong> (简单)</td></tr> <tr><td><strong>代码量</strong></td> <td>较多（样板代码）</td> <td><strong>非常简洁</strong></td></tr> <tr><td><strong>官方推荐</strong></td> <td>遗留 (Legacy)</td> <td><strong>现代标准</strong> (Preferred)</td></tr></tbody></table></li></ul> <h2 id="diff-算法"><a href="#diff-算法" class="header-anchor">#</a> Diff 算法</h2> <h3 id="同层比较"><a href="#同层比较" class="header-anchor">#</a> 同层比较</h3> <ul><li><strong>核心思想：</strong> Web UI 很少会发生“跨层级”的节点移动。比如你在 div 下的节点通常不会直接移动到 body 下</li> <li><strong>工作机制：</strong> <ol><li>React 的 diff 过程是通过逐层比较。</li> <li>它在比较两棵虚拟 DOM 树时，只会比较<strong>同一层级</strong>的节点。</li></ol></li> <li><strong>目的/作用：</strong> 这是最大的性能优化。React <strong>放弃了“跨层级比较”</strong>，以减少算法复杂度。</li> <li><strong>如何处理跨层级：</strong> <ul><li>它会在<strong>旧层级销毁</strong>这个节点（触发 <code>unmount</code>），然后在<strong>新层级创建</strong>一个全新的节点（触发 <code>mount</code>）。</li> <li>这意味着，即使是同一个组件，只要跨层级移动了，它的所有 <code>state</code> 都会丢失。</li></ul></li></ul> <hr> <h3 id="组件类型比较"><a href="#组件类型比较" class="header-anchor">#</a> 组件类型比较</h3> <ul><li><strong>核心思想：</strong> 不同类型的组件，会产生不同的 DOM 结构。</li> <li><strong>工作机制：</strong> <ol><li>当 React 在<strong>同一层级</strong>比较两个节点时，它首先会看它们的“类型”。</li> <li><strong>如果类型相同</strong>（比如都是 <code>div</code>，或者都是 <code>MyButton</code> 组件）：React 会认为他可以复用。它会保留 DOM 节点或组件实例，只更新变化的 <code>props</code> 和 <code>style</code>。</li> <li><strong>如果类型不同</strong>（比如 <code>div</code> 变成了 <code>span</code>）：React 认为它们“毫无关系”。</li></ol></li> <li><strong>目的/作用：</strong> 这样避免在两个完全不相干的组件上浪费时间去比较它们的内部细节。</li> <li><strong>如何处理不同类型：</strong> <ul><li>当类型不同时，React 会<strong>彻底销毁</strong>旧的组件（及其所有子节点），并<strong>创建</strong>一个全新的组件实例（及其子节点）。</li> <li>这同样意味着，旧组件的所有 <code>state</code> 都会丢失。</li></ul></li></ul> <hr> <h3 id="key-的比较"><a href="#key-的比较" class="header-anchor">#</a> key 的比较</h3> <ul><li><strong>核心思想：</strong> 在一组子节点中，使用 <code>key</code> 属性来<strong>唯一标识</strong>每一个节点。</li> <li><strong>工作机制：</strong> 当 React 比较<strong>同一层级</strong>的<strong>一组</strong>子节点时（比如 <code>ul</code> 下的多个 <code>li</code>）：
<ul><li><strong>没有 key (旧策略)</strong>：React 会“逐个对比”。如果我在列表<strong>最前面</strong>插入一个新节点，React 会误以为“所有”节点都发生了变化（第 1 个变第 2 个，第 2 个变第 3 个...），导致<strong>所有节点都被原地更新</strong>（或重建），性能极差。</li> <li><strong>有 key (新策略)</strong>：React 会利用 <code>key</code> 创建一个 <code>Map</code>（<code>key</code> -&gt; 节点）。
<ol><li>它遍历新列表，通过 <code>key</code> 去旧的 <code>Map</code> 里查找。</li> <li><strong>找到了 (key 存在)</strong>：说明这个节点只是<strong>移动了</strong>位置，React 会复用它并执行“移动”操作。</li> <li><strong>没找到 (key 是新的)</strong>：说明这是<strong>新增</strong>节点，React 会创建它。</li> <li>(遍历完新列表后) 旧 <code>Map</code> 里还<strong>剩下</strong>的 <code>key</code>：说明这些是<strong>删除</strong>节点，React 会销毁它们。</li></ol></li></ul></li> <li><strong>目的/作用：</strong> 实现 DOM 节点的<strong>最大化复用</strong>。它能让 React 精确地知道哪些节点是“新增”、“删除”或“移动”的，从而执行最少的 DOM 操作。</li> <li><strong>关键点/陷阱：</strong> <ol><li><code>key</code> 必须在<strong>兄弟节点之间唯一</strong>（不需要全局唯一）。</li> <li><strong>绝对禁止使用数组的 index 作为 key</strong>。因为当列表发生“反转”或“在开头插入”时，<code>index</code> 会完全错乱，这会导致 React 错误地复用组件，引发各种 <code>state</code> 混乱的 Bug，其危害甚至比不写 <code>key</code> 更大。</li></ol></li></ul> <h2 id="fiber-的核心机制"><a href="#fiber-的核心机制" class="header-anchor">#</a> Fiber 的核心机制</h2> <p>React 15 依赖 JavaScript 的“函数调用栈”来递归 diff，这个过程一旦开始就无法停止。</p> <p>Fiber 架构在内存中构建了一个<strong>链表</strong>（即“虚拟栈”），React 通过遍历这个链表来执行工作，从而<strong>摆脱了对 JS 调用栈的依赖</strong>。</p> <p>Diff 算法 (Reconciliation)： 是 “要做什么”。它是一套比较规则，用来找出新旧两棵树的差异。</p> <p>Fiber 架构： 是 “要怎么做”。它是 React 16+ 引入的一套全新的“执行引擎”或“调度器”，用来执行这个 Diff 算法。</p> <h3 id="可中断性"><a href="#可中断性" class="header-anchor">#</a> 可中断性</h3> <ul><li><strong>它是什么：</strong> React 能够将一个“大更新”（如 diff 整棵树）拆分成无数个“小工作单元”，并在执行完每个单元后暂停。</li> <li><strong>如何实现：</strong> <ul><li><strong>Fiber 单元：</strong> 树中的每个节点（组件、DOM）都是一个 <strong>Fiber 对象</strong>，即一个“工作单元”。</li> <li><strong>链表指针：</strong> 每个 Fiber 对象包含三个关键指针：<code>return</code> (父级), <code>child</code> (子级), <code>sibling</code> (兄弟)。</li> <li><strong>遍历：</strong> React 的调度器<strong>在内存中</strong>通过这三个指针“遍历”Fiber 树（而不是通过 JS 函数调用）。</li> <li><strong>实现中断：</strong> 因为是 React 自己控制的“遍历”，所以它可以在处理完<strong>任何一个</strong> Fiber 单元后，<strong>主动停止</strong>，并把主线程交还给浏览器（去响应用户输入）。这就是“时间分片”。</li></ul></li></ul> <h3 id="断点重新执行"><a href="#断点重新执行" class="header-anchor">#</a> 断点重新执行</h3> <ul><li><strong>它是什么：</strong> “中断”之后，还能在稍后从“断点”处<strong>继续</strong>工作，而不是重头再来。</li> <li><strong>如何实现：</strong> <ul><li>这正是“链表遍历”带来的好处。</li> <li>当 React 决定“中断”（比如 5ms 时间到了）时，它只需要<strong>在内存中记住</strong>它“<strong>下一个</strong>要处理的 Fiber 单元”的<strong>指针</strong> (<code>nextUnitOfWork</code>)。</li> <li>当浏览器再次空闲时，React 调度器直接从这个指针指向的 Fiber 单元<strong>继续开始</strong>遍历和 diff，之前的所有工作进度（即那棵“WIP 草稿树”）都完整地保存在内存中。</li></ul></li></ul> <h3 id="优先级"><a href="#优先级" class="header-anchor">#</a> 优先级</h3> <ul><li><strong>它是什么：</strong> React 必须能区分“紧急任务”（如用户打字）和“非紧急任务”（如渲染列表），并允许“紧急任务”<strong>插队</strong>。</li> <li><strong>如何实现：</strong> <ul><li><strong>调度器 (Scheduler)：</strong> React 18 引入的机制，用于给不同的更新“贴标签”（如：<code>Urgent</code>, <code>Transition</code>）。</li> <li><strong>两阶段：</strong> Fiber 架构将更新严格分为两个阶段：
<ol><li><strong>阶段一：Render (可中断)</strong>：执行 Diff，找出差异。</li> <li><strong>阶段二：Commit (不可中断)</strong>：将差异应用到真实 DOM。</li></ol></li> <li><strong>实现插队：</strong> <ul><li><strong>场景：</strong> React 正在“慢悠悠”地执行一个“非紧急”的 <strong>Render</strong> 阶段。</li> <li><strong>插队：</strong> 此时一个“紧急”的更新（用户点击）进来了。</li> <li><strong>操作：</strong> 调度器会<strong>立即“丢弃”</strong> 那个正在进行中的、非紧急的 Render 阶段（以及它的“草稿树”），然后<strong>立即启动</strong>一个新的 Render 阶段来处理这个“紧急”更新。</li> <li><strong>提交：</strong> 紧急更新的 Render 和 Commit 阶段会快速执行，保证用户响应。之后，React 再<strong>重新</strong>去执行那个被“丢弃”的非紧急更新。</li></ul></li></ul></li></ul> <h2 id="react-合成事件原理"><a href="#react-合成事件原理" class="header-anchor">#</a> React 合成事件原理</h2> <ol><li><strong>全局事件委托 (Event Delegation)：</strong> <ul><li>React <strong>不会</strong>为你写的<strong>每一个</strong> <code>onClick</code> 都去 DOM 元素上调用 <code>addEventListener</code>。</li> <li>相反，它在<strong>整个应用的根节点</strong>（在 React 17 之前是 <code>document</code>，在 React 17+ 是你 <code>createRoot</code> 的那个 DOM 节点）上只监听<strong>一次</strong>所有它支持的事件（如 <code>click</code>, <code>change</code>）。</li></ul></li> <li><strong>事件派发：</strong> <ul><li>当一个原生 DOM 事件（例如一个按钮的 'click'）冒泡到这个“根节点”时，React 的总监听器会捕获它。</li> <li>React 查看这个原生事件的 <code>target</code>，然后找出是<strong>哪个 React 组件</strong>触发了它。</li></ul></li> <li><strong>创建包装器：</strong> <ul><li>React <strong>获取</strong>这个“原生事件对象”，然后把它<strong>包装</strong>成一个“合成事件对象”。</li> <li>这个合成对象上挂载了 React 抹平差异后的 API（如 <code>e.preventDefault()</code>）。</li></ul></li> <li><strong>调用回调：</strong> <ul><li>React 将这个“合成事件” <code>e</code> 传递给你在 JSX 中定义的 <code>onClick</code> 回调函数。</li> <li><strong>访问原生事件：</strong> 如果你确实需要访问未被包装的“原生”事件对象，可以使用 <code>e.nativeEvent</code>。</li></ul></li></ol> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <ol><li><p>事件池 (Event Pooling) - 已废除</p> <ul><li><strong>React 16 及更早：</strong> <ul><li><strong>机制：</strong> 为了极致的性能，React 会“池化”事件对象。当你的 <code>onClick</code> 回调函数执行完毕后，React 会**立刻“回收”**这个 <code>e</code> 对象，并将其所有属性设置为 <code>null</code>。</li> <li><strong>陷阱：</strong> 这导致你<strong>无法</strong>在<strong>异步</strong>操作（如 <code>setTimeout</code> 或 <code>Promise</code>）中访问 <code>e.target</code>。</li> <li><strong>旧版解决：</strong> 必须手动调用 <code>e.persist()</code> 来“脱离”事件池。</li></ul></li> <li><strong>React 17 及以后：</strong> <ul><li><strong>变更：</strong> React <strong>完全移除了事件池</strong>。</li> <li><strong>效果：</strong> <code>e</code> 对象在你的回调函数执行后<strong>不再</strong>被回收。你现在可以安全地在 <code>setTimeout</code> 等异步代码中访问 <code>e.target</code>，<strong>不再需要</strong>调用 <code>e.persist()</code>。</li></ul></li></ul></li> <li><p>委托根节点 (Delegation Root)</p> <ul><li><strong>React 16 及更早：</strong> <ul><li>React 总是将所有事件委托到 <code>document</code> 级别。</li></ul></li> <li><strong>React 17 及以后：</strong> <ul><li>React 将事件委托到你调用 <code>ReactDOM.createRoot()</code> 的<strong>应用根 DOM 节点</strong>上。</li> <li><strong>好处：</strong> 这使得在一个页面中“渐进式升级”或“嵌套”多个 React 应用版本成为可能，而不会互相干扰事件系统。</li></ul></li></ul></li></ol> <h2 id="mvc-和-mvvm-的区别"><a href="#mvc-和-mvvm-的区别" class="header-anchor">#</a> MVC 和 MVVM 的区别</h2> <ul><li>MVC 和 MVVM 都是常见的软件架构思想</li> <li>MVC
<ul><li>model: 数据层</li> <li>view: 视图层</li> <li>controller: 控制层</li></ul></li> <li>MVC 的通信方式： view -&gt; controller -&gt; model -&gt; view</li> <li>MVVM
<ul><li>model: 数据层</li> <li>view: 视图层</li> <li>viewModel: 视图模型层</li></ul></li> <li>MVVM 的通信方式： view &lt;-&gt; viewmodel -&gt;&lt;- model</li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <ul><li><p><strong>初始化阶段</strong>
constructor 是一个特殊的函数，当这个类被实例化的时候，自动执行，最先执行，只执行一次
初始化 props 和 state</p></li> <li><p><strong>挂载阶段</strong>
UNSAFE_ 前面有这个的就是被废弃了 带 Will 的一般都被废弃了 16.3 版本
<em>UNSAFE_componentWillMount()</em> <em>render()</em> - return 标签渲染页面
<em>componentDidMount()</em>
数据请求 这里面基本上什么都可以写了
只能在 componentDidMount 里面请求数据 由于 fiber 算法的存在 在别的生命周期里每个片都会请求一次数据多次请求</p></li> <li><p><strong>数据更新阶段</strong></p> <ul><li><em>shouldComponentUpdate()</em>
作用：使用 shouldComponentUpdate 就是为了减少 render 不必要的渲染
一定要返回一个布尔值
里面手动判断页面是否需要渲染
shouldComponentUpdate 提供了两个参数 nextProps 和 nextState，表示下一次 props 和一次 state 的值，当函数返回 false 时候，render()方法不执行，组件也就不会渲染，返回 true 时，组件照常重渲染
当传递的是一个复杂对象时由于地址不相同所以就没用了
解决：</li></ul> <ol><li>使用 setState 改变数据之前，先采用 es6 中 assgin 进行拷贝，但是 assgin 只深拷贝的数据的第一层，所以说不是最完美的解决办法。</li> <li>使用 JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为 undefined 和函数时就会错。</li></ol> <ul><li><p>使用 immutable.js 进行项目的搭建。immutable 中讲究数据的不可变性，每次对数据进行操作前，都会自动的对数据进行深拷贝，项目中数据采用 immutable 的方式，可以轻松解决问题，但是又多了一套 API 去学习
immutable.js
Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享</p></li> <li><p><em>UNSAFE_componentWillUpdate() {}</em></p></li> <li><p><em>componentWillReceiveProps</em></p></li> <li><p><em>componentWillUpdate()</em></p></li> <li><p><em>render()</em></p></li> <li><p><em>componentDidUpdate()</em></p></li></ul></li> <li><p><strong>销毁阶段</strong> <em>componentWillUnmount</em>
清除定时器，断开 websocket，取消事件监听，卸载第三方插件</p></li></ul> <h2 id="react-组件通信方法"><a href="#react-组件通信方法" class="header-anchor">#</a> React 组件通信方法</h2> <p>在 React 中，组件是独立且可复用的。为了构建复杂的应用，组件之间需要有效地交换数据。以下是几种核心的组件通信方法。</p> <h3 id="_1-父组件向子组件通信-props"><a href="#_1-父组件向子组件通信-props" class="header-anchor">#</a> 1. 父组件向子组件通信 (Props)</h3> <p>这是最常见和最直接的通信方式。</p> <ul><li><p><strong>核心思想</strong>: 父组件通过 <strong>props</strong> 属性将数据单向传递给子组件。</p></li> <li><p><strong>实现</strong>:</p> <ol><li><strong>父组件</strong>: 在调用子组件时，像传递 HTML 属性一样，将数据绑定到子组件的 props 上。</li> <li><strong>子组件</strong>: 通过 <code>props</code> 对象接收数据。在函数组件中，<code>props</code> 是函数的第一个参数；在类组件中，通过 <code>this.props</code> 访问。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 父组件: ParentComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">&quot;./ChildComponent&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dataToSend <span class="token operator">=</span> <span class="token string">&quot;Hello from Parent!&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildComponent</span></span> <span class="token attr-name">message</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>dataToSend<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件: ChildComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello from Parent!&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_2-子组件向父组件通信-回调函数"><a href="#_2-子组件向父组件通信-回调函数" class="header-anchor">#</a> 2. 子组件向父组件通信 (回调函数)</h3> <p>子组件不能直接修改父组件的状态，因此需要借助回调函数来间接通信。</p> <ul><li><p><strong>核心思想</strong>: 父组件将一个<strong>函数作为 props</strong> 传递给子组件，子组件在需要时调用这个函数，从而将数据作为函数参数传递回父组件。</p></li> <li><p><strong>实现</strong>:</p> <ol><li><strong>父组件</strong>: 定义一个用于更新状态的函数，并将其传递给子组件。</li> <li><strong>子组件</strong>: 通过 props 调用该函数，并将需要传递的数据作为参数传入。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 父组件: ParentComponent.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">&quot;./ChildComponent&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>messageFromChild<span class="token punctuation">,</span> setMessageFromChild<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleChildData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setMessageFromChild</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Message from child: </span><span class="token punctuation">{</span>messageFromChild<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildComponent</span></span> <span class="token attr-name">onSendData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChildData<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件: ChildComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    props<span class="token punctuation">.</span><span class="token function">onSendData</span><span class="token punctuation">(</span><span class="token string">&quot;Hi, I'm the child!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Send Data to Parent</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_3-跨级组件通信-context-api"><a href="#_3-跨级组件通信-context-api" class="header-anchor">#</a> 3. 跨级组件通信 (Context API)</h3> <p>当组件层级很深，通过 props 逐层传递数据会变得非常繁琐（即 &quot;props drilling&quot;），此时 Context 提供了一种更优雅的解决方案。</p> <ul><li><p><strong>核心思想</strong>: Context 提供了一个全局的“上下文”，允许父组件向其下任意层级的子组件直接传递数据，而无需手动逐层传递。</p></li> <li><p><strong>核心 API</strong>: <code>React.createContext</code>, <code>Provider</code>, <code>Consumer</code>, <code>useContext</code> Hook。</p></li> <li><p><strong>实现步骤</strong>:</p> <ol><li><strong>创建 Context</strong>: 使用 <code>const MyContext = React.createContext(defaultValue);</code> 创建一个 Context 对象。</li> <li><strong>提供 Context</strong>: 在父组件或组件树的顶层，使用 <code>&lt;MyContext.Provider value={data}&gt;</code> 组件包裹所有需要访问该数据的子组件。<code>value</code> 属性就是要共享的数据。</li> <li><strong>消费 Context</strong>:
<ul><li><strong><code>useContext</code> Hook (推荐)</strong>: 在函数组件中，使用 <code>const value = useContext(MyContext);</code> 直接获取 <code>value</code>。这是最简洁现代的方式。</li> <li><strong><code>Consumer</code> 组件</strong>: 在类组件或旧版函数组件中，使用 <code>&lt;MyContext.Consumer&gt;{value =&gt; /* JSX based on value */}&lt;/MyContext.Consumer&gt;</code>，通过渲染属性（render prop）的方式来获取数据。</li></ul></li></ol></li> <li><p><strong>代码示例 (使用 <code>useContext</code>)</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// theme-context.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> createContext<span class="token punctuation">,</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 创建 Context</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">&quot;light&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// App.js (提供者)</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token string">&quot;dark&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Toolbar</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Toolbar.js (中间组件)</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemedButton</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ThemedButton.js (消费者)</span>
<span class="token keyword">function</span> <span class="token function">ThemedButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 3. 使用 useContext 消费数据</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Current theme is: </span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_4-状态管理库"><a href="#_4-状态管理库" class="header-anchor">#</a> 4. 状态管理库</h3> <p>对于大型、复杂应用，组件间的通信关系可能错综复杂。此时，使用专门的状态管理库可以提供一个集中式、可预测的状态容器。</p> <ul><li><strong>核心思想</strong>: 将所有共享状态（state）存储在一个全局的 &quot;Store&quot; 中。任何组件都可以从 Store 中读取状态，并可以 &quot;dispatch&quot; 一个 &quot;action&quot; 来请求更新状态。状态的更新逻辑由 &quot;reducer&quot; 函数集中处理。</li> <li><strong>代表库</strong>:
<ul><li><strong>Redux</strong>: 经典的状态管理库，生态成熟，中间件丰富，遵循严格的单向数据流。</li> <li><strong>Zustand</strong>: 一个更轻量、更现代的状态管理方案，API 简单，基于 Hooks，无需大量模板代码。</li></ul></li></ul> <h3 id="_5-本地状态共享-hooks"><a href="#_5-本地状态共享-hooks" class="header-anchor">#</a> 5. 本地状态共享 (Hooks)</h3> <p>React Hooks 提供了一些强大的工具，可以在组件内部或相关组件之间共享逻辑和状态。</p> <h4 id="a-usereducer"><a href="#a-usereducer" class="header-anchor">#</a> a. <code>useReducer</code></h4> <ul><li><strong>核心思想</strong>: <code>useReducer</code> 是 <code>useState</code> 的替代方案。当状态逻辑比较复杂，或者下一个状态依赖于前一个状态时，<code>useReducer</code> 更为适用。它可以看作是单个组件内部的 &quot;小型 Redux&quot;。</li> <li><strong>API</strong>: <code>const [state, dispatch] = useReducer(reducer, initialState);</code> <ul><li><code>reducer</code>: 一个函数 <code>(state, action) =&gt; newState</code>，根据 action 来计算新 state。</li> <li><code>initialState</code>: 初始状态。</li> <li><code>dispatch</code>: 一个函数，用于触发 action，例如 <code>dispatch({ type: 'increment' })</code>。</li></ul></li> <li><strong>注意</strong>: <code>useReducer</code> 本身不处理异步操作（如 API 请求）。通常需要配合 <code>useEffect</code> 来处理副作用，例如在 <code>useEffect</code> 中获取数据，然后调用 <code>dispatch</code> 将数据存入 state。</li></ul> <h4 id="b-状态提升-lifting-state-up"><a href="#b-状态提升-lifting-state-up" class="header-anchor">#</a> b. 状态提升 (Lifting State Up)</h4> <ul><li><strong>核心思想</strong>: 当多个子组件需要共享和操作同一个状态时，应将这个状态提升到它们最近的共同父组件中进行管理。然后，父组件通过 props 将状态和更新状态的函数分发给需要的子组件。</li> <li><strong>本质</strong>: 这并不是一种新的技术，而是 <strong>Props</strong> 和 <strong>回调函数</strong> 模式的结合与实践，是 React 设计的核心原则之一。</li></ul> <h3 id="_6-非嵌套组件通信-发布-订阅模式"><a href="#_6-非嵌套组件通信-发布-订阅模式" class="header-anchor">#</a> 6. 非嵌套组件通信 (发布-订阅模式)</h3> <p>对于两个没有任何层级关系的组件，可以使用全局事件总线（Event Bus）来实现通信。</p> <ul><li><p><strong>核心思想</strong>: 创建一个中央事件管理器。一个组件（发布者）可以发布（<code>emit</code>）一个事件，其他任何组件（订阅者）只要订阅（<code>listen</code> 或 <code>on</code>）了该事件，就能收到通知并执行相应的回调。</p></li> <li><p><strong>实现</strong>:</p> <ol><li>引入一个事件库，如 <code>events</code> 或 <code>pubsub-js</code>。</li> <li>创建一个事件发射器实例。</li> <li>在组件 A 中，使用 <code>emitter.emit('eventName', data)</code> 来发布事件。</li> <li>在组件 B 的 <code>useEffect</code> 中，使用 <code>emitter.on('eventName', callback)</code> 来订阅事件。</li> <li><strong>关键</strong>: 在组件 B 卸载时，必须在 <code>useEffect</code> 的返回函数中调用 <code>emitter.off('eventName', callback)</code> 来取消订阅，以防止内存泄漏。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// event-bus.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventEmitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;events&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ComponentA.js (发布者)</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> emitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./event-bus&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello from Component A!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Send Global Message</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ComponentB.js (订阅者)</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> emitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./event-bus&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ComponentB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">handleMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> handleMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 组件卸载时取消订阅</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      emitter<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> handleMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空依赖数组确保只在挂载和卸载时执行</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Received message: </span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <hr> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <table><thead><tr><th style="text-align:left;">通信场景</th> <th style="text-align:left;">推荐方法</th> <th style="text-align:left;">核心</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>父 -&gt; 子</strong></td> <td style="text-align:left;"><strong>Props</strong></td> <td style="text-align:left;">最基础、最直接的数据传递。</td></tr> <tr><td style="text-align:left;"><strong>子 -&gt; 父</strong></td> <td style="text-align:left;"><strong>回调函数</strong> (通过 Props 传递)</td> <td style="text-align:left;">子组件调用父组件的函数。</td></tr> <tr><td style="text-align:left;"><strong>兄弟组件</strong></td> <td style="text-align:left;"><strong>状态提升</strong></td> <td style="text-align:left;">将共享状态放到共同的父组件中管理。</td></tr> <tr><td style="text-align:left;"><strong>跨多层级组件</strong></td> <td style="text-align:left;"><strong>Context API</strong> (<code>useContext</code>)</td> <td style="text-align:left;">避免 Props 逐层钻取，实现全局数据共享。</td></tr> <tr><td style="text-align:left;"><strong>复杂应用/全局状态</strong></td> <td style="text-align:left;"><strong>状态管理库</strong> (Redux, Zustand)</td> <td style="text-align:left;">集中式、可预测的全局状态管理方案。</td></tr> <tr><td style="text-align:left;"><strong>任意非嵌套组件</strong></td> <td style="text-align:left;"><strong>发布-订阅模式</strong> (Event Bus)</td> <td style="text-align:left;">解耦组件，通过全局事件中心通信。</td></tr></tbody></table> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <h3 id="_1-事件命名和绑定"><a href="#_1-事件命名和绑定" class="header-anchor">#</a> 1. 事件命名和绑定</h3> <ul><li>事件名采用驼峰命名法（如 <code>onClick</code>、<code>onChange</code>）。</li> <li>事件处理函数通常传递为函数引用，而不是字符串。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 正确</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click Me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 错误</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click Me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_2-阻止默认行为和事件冒泡"><a href="#_2-阻止默认行为和事件冒泡" class="header-anchor">#</a> 2. 阻止默认行为和事件冒泡</h3> <p>React 事件对象是合成事件（SyntheticEvent），提供与原生 DOM 事件一致的接口。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleSubmit</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止默认提交</span>
  e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止事件冒泡</span>
<span class="token punctuation">}</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">onSubmit</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleSubmit<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_3-向事件处理函数传递参数"><a href="#_3-向事件处理函数传递参数" class="header-anchor">#</a> 3. 向事件处理函数传递参数</h3> <p>可以使用箭头函数或 bind 方法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handleClick</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Delete</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Delete</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_4-事件对象"><a href="#_4-事件对象" class="header-anchor">#</a> 4. 事件对象</h3> <p>事件处理函数的第一个参数为合成事件对象（SyntheticEvent），具有和原生事件类似的属性。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_5-this-指向"><a href="#_5-this-指向" class="header-anchor">#</a> 5. this 指向</h3> <ul><li>使用 class 组件时，事件处理函数需要绑定 this，或使用箭头函数自动绑定。</li> <li>函数组件中无需关心 this。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// class 组件</span>
<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="_6-事件池机制"><a href="#_6-事件池机制" class="header-anchor">#</a> 6. 事件池机制</h3> <ul><li>React 17 及以下，合成事件对象会被回收（事件池），异步访问事件属性时需调用 <code>event.persist()</code>。</li> <li>React 17 以上已取消事件池机制，但为兼容旧代码，可继续调用 <code>event.persist()</code>。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 防止事件对象被回收</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="_7-常用事件类型"><a href="#_7-常用事件类型" class="header-anchor">#</a> 7. 常用事件类型</h3> <table><thead><tr><th>事件类型</th> <th>说明</th></tr></thead> <tbody><tr><td>onClick</td> <td>点击事件</td></tr> <tr><td>onChange</td> <td>输入、选择改变</td></tr> <tr><td>onSubmit</td> <td>表单提交</td></tr> <tr><td>onMouseEnter</td> <td>鼠标进入</td></tr> <tr><td>onMouseLeave</td> <td>鼠标离开</td></tr> <tr><td>onKeyDown</td> <td>键盘按下</td></tr> <tr><td>onFocus</td> <td>获得焦点</td></tr> <tr><td>onBlur</td> <td>失去焦点</td></tr></tbody></table> <hr> <h3 id="_8-事件冒泡与捕获"><a href="#_8-事件冒泡与捕获" class="header-anchor">#</a> 8. 事件冒泡与捕获</h3> <ul><li>React 默认事件是冒泡阶段。</li> <li>支持捕获事件，写法如 <code>onClickCapture</code>。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClickCapture</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;捕获阶段&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_9-事件委托"><a href="#_9-事件委托" class="header-anchor">#</a> 9. 事件委托</h3> <ul><li>React 事件委托到根节点（如 <code>document</code>），提升性能。</li> <li>组件卸载时会自动移除监听，无需手动清理。</li></ul> <hr> <h3 id="_10-组合使用"><a href="#_10-组合使用" class="header-anchor">#</a> 10. 组合使用</h3> <p>可结合 state、props、Context 等配合事件实现复杂交互。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <ul><li>使用合成事件，跨平台兼容。</li> <li>事件名写法和原生不同。</li> <li>事件处理参数、this 绑定需注意。</li> <li>事件池影响异步操作。</li> <li>支持事件捕获与冒泡、事件委托无需手动管理。</li></ul> <h2 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="header-anchor">#</a> 受控组件与非受控组件</h2> <p>受控组件与非受控组件 都是基于表单组件的
受控组件: 表单由我们自己来控制的组件
就是包含 value 属性和 onChange 事件的组件 onChange 里面写 setState 改变当前点击的 value 的值赋值给 input 绑定的 value
非受控组件就是，表单交给 react 去控制
只有文件上传一定要使用非受控组件，其他时候都尽量使用受控组件</p> <ol><li>引入 createRef</li> <li>定义 ipt = createRef();</li> <li>表单上加 ref 属性</li></ol> <div class="language-JSX extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ipt<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="4"><li>获取时用 this.ipt.current.value</li></ol> <h2 id="hoc-高阶组件"><a href="#hoc-高阶组件" class="header-anchor">#</a> hoc 高阶组件</h2> <p>高阶组件是一个函数，这个函数要传入一个组件，并且返回一个新组件
高阶组件的取名一般用 with 开头，后面加功能
作用增强组件的功能,并且可以做复用
传入一个组件 return 一个功能更多的组件</p> <p>高阶组件-加版权号</p> <div class="language-JSX extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">withCopy</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Component <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
                </span><span class="token punctuation">{</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">_ {...this.props}是将接收到的 props 全部传递给子组件 _</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">}</span><span class="token plain-text">
                </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Comp</span></span> <span class="token attr-name">num</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">20</span><span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Comp</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
                </span><span class="token punctuation">{</span><span class="token operator">/</span>_ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">&amp;copy;版权所有 贾滨旭 xxx </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> _<span class="token operator">/</span><span class="token punctuation">}</span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="diff-算法-react-fiber-虚拟-dom"><a href="#diff-算法-react-fiber-虚拟-dom" class="header-anchor">#</a> diff 算法 React Fiber 虚拟 dom</h2> <ul><li>diff 算法
用 js 对象模拟真实的 DOM 结构 当页面更新的时候比对虚拟 dom 和真实 dom 区别 然后在进行更新 只需要更改部分不需要将页面全部重新渲染
但是标准的的 Diff 算法复杂度需要 O(n^3)
虚拟 dom：将真实 dom 转换成变量存到内存中
diff 算法是一种通过同层的树节点进行比较的高效算法
特点：</li></ul> <ol><li>同级比较</li> <li>key 值比较</li> <li>类的比较
拥有相同类的两个组件 生成相似的树形结构，
拥有不同类的两个组件 生成不同的树形结构。
React 里结合 Web 界面的特点做出了两个简单的假设来降低算法的复杂度
<ol><li>两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构；</li> <li>对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分</li></ol></li></ol> <ul><li>React Fiber
渲染的时候将一个大的进程拆分成小的片 在每个片结束后查看一下其他的进程 然后运行小一点的进程 再去执行下一个片 例子星巴克
虚拟 DOM
虚拟 dom 相当于在 js 和 真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把所记录的差异渲染再真实 dom 上，从而提高性能。</li></ul> <h2 id="时间复杂度-空间复杂度"><a href="#时间复杂度-空间复杂度" class="header-anchor">#</a> 时间复杂度 空间复杂度</h2> <p>时间复杂度：是指执⾏当前算法所消耗的时间；
空间复杂度：是指执⾏当前算法需要占⽤多少内存空间
常⻅的量级有：常数阶 O(1)，对数阶 O(logN)，线性阶 O(n)，线性对数阶 O(nlogN)，平⽅阶 O(n²)，⽴⽅阶 O(n³)，K
次⽅阶 O(n^k)，指数阶</p> <h2 id="protal-将组件放到页面中任意你想放的位置"><a href="#protal-将组件放到页面中任意你想放的位置" class="header-anchor">#</a> protal 将组件放到页面中任意你想放的位置</h2> <p>有时需要将元素渲染到 DOM 中的不同位置上去，这是就用到的 portal 的方法 protal 可以将组件放到页面中任意你想放的位置
引入
import { createPortal } from &quot;react-dom&quot;;
第一个参数 child 是可渲染的 react 子项，比如元素，字符串或者片段等。第二个参数 container 是一个 DOM 元素。
例子：对话框 模态框 轻提示
模态框例子</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// App.jsx</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Modal <span class="token keyword">from</span> <span class="token string">&quot;./Modal&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// import { createPortal } from &quot;react-dom&quot;;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">open</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">ok</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// portal的事件冒泡依旧会冒到原先的父元素上面</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fn<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">对话框</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>open<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Open Modal</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token comment">/* {this.state.show &amp;&amp; &lt;Modal /&gt;} */</span><span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token comment">/* {createPortal(&lt;Modal /&gt;, document.querySelector(&quot;body&quot;))} */</span><span class="token punctuation">}</span><span class="token plain-text">

        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Modal</span></span>
          <span class="token attr-name">visible</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>show<span class="token punctuation">}</span></span>
          <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Basic Modal<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">okText</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>确定<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">onOk</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ok<span class="token punctuation">}</span></span>
        <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> withPortal <span class="token keyword">from</span> <span class="token string">&quot;./withPortal&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;./style.css&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bool<span class="token punctuation">,</span> string <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;prop-types&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Modal</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// console.log(this.props);</span>
    <span class="token comment">// return (</span>
    <span class="token comment">// &lt;div className=&quot;modal&quot;&gt;</span>
    <span class="token comment">//   &lt;div className=&quot;center&quot;&gt;</span>
    <span class="token comment">//     &lt;h4&gt;Basic Modal&lt;/h4&gt;</span>
    <span class="token comment">//   &lt;/div&gt;</span>
    <span class="token comment">// &lt;/div&gt;;</span>
    <span class="token comment">// );</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>visible <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modal<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>onOk<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>okText<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Modal<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">visible</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;标题&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Modal<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">visible</span><span class="token operator">:</span> bool<span class="token punctuation">,</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withPortal</span><span class="token punctuation">(</span>Modal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createPortal <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 添加portal的高阶组件，很多的对话框都需要加到body上，所以将createPortal提出来</span>
<span class="token keyword">const</span> <span class="token function-variable function">withPortal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Component <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">createPortal</span><span class="token punctuation">(</span>
        <span class="token comment">// 将接收到的所有的props，传递给子组件</span>
        <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
        document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> withPortal<span class="token punctuation">;</span>
</code></pre></div><ul><li><p>createPortal 的优点</p> <p>1.使用 Portal 后，界面定制比较灵活，Portlet 是一个容器，通过 console 可以更改 Portlet 的位置，尺寸，级别，外观等，Portlet 内部显示的内容也会随着改变。
2.Portal 有内部安全机制，可以在 Portal 上面定制角色、组及用户，可以指定哪些资源可以被哪些用户（组、角色）访问，对于那些不符合安全条件的用户登录，则看不到相关的资源。
3.Portal 允许自己利用已经开发好的资源（portlet 或者网页）按照自己的喜好定制自己的首页或者网站。提升了网站的可维护性。
4.Portal 软件里面都内置了很多其他方面的组件，比如全文检索，内容管理等。
5.Portal 支持多渠道访问，比如：同一个 Portal 可以不用修改就可以支持手机、PDA 访问。</p></li> <li><p>createPortal 的缺点</p> <p>1.Portal 是标准的 Web 应用，不同厂商的实现不同，有学习曲线和时间成本。
2.Portal 的性能也是一个需要考虑的因素，如果一个页面上 Portlet 数量比较多，则显示速度会比普通的页面慢很多，如果启用了 Portlet 的页面级 cache，则速度会快很多，但使用 Portal 后，性能肯定是个问题。
3.Portal 的开发要比普通的开发步骤多，周期长，另外还要考虑一些引入了 Portal 后带来的技术细节，比如多个 Portlet 内容来自于多个独立的系统，如果使用 iFrame 带来的多 Session 的问题等等。
4.Portal 需要自己做很多工作才能完成的，比如 SSO（Single Sign-On 单点登录）。（后面可以不说）
5.Portal 有时候满足不了复杂项目的需要，需要自己二次开发，需要使用更专业的组件或者软件替代，比如内容管理，安全认证等领域。 6.使用 Portal 后，对于架构设计及开发过程都会产生很大影响，比如使用特定厂商的 Portal 产品后，需要使用特特定的 IDE 才能开发、部署，自动化的测试脚本的作用就会被削弱。</p></li></ul> <h2 id="react-路由"><a href="#react-路由" class="header-anchor">#</a> React 路由</h2> <h3 id="react5"><a href="#react5" class="header-anchor">#</a> React5</h3> <p>五版本路由总结 yarn add react-router-dom@5 ( 一般都用 5 版本 6 版本为新版本)
解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks</p> <ol><li><p>如果项目要使用路由，那么项目的最外面要加上 BrowserRouter 组件 直接在出口文件给总的最大的组件套一个 BrowserRouter 标签
import { BrowserRouter } from &quot;react-router-dom&quot;;</p></li> <li><p>在组件中想使用路由的话在父组件引入 Link 这个 link 标签就相当于 a 标签做跳转 link 标签有一个 to 属性做跳转 to= &quot;路径&quot;
写法:
import { NavLink, Route, Switch } from &quot;react-router-dom&quot;;</p></li> <li><p>对应的每一个 link 标签应该对应一个 Route 标签 Route 标签有两个属性 path=&quot;路径&quot; componen = {要渲染的组件名}</p></li> <li><p>Route 标签的渲染属性有四个：</p> <ol><li>componen = {要渲染的组件名}</li> <li>render ={
(props) =&gt;{
return &lt; 要渲染的组件名 （如果要传递 props 加 {...props}）/&gt;
}
}</li> <li>children={Mine}</li> <li></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/detail<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Detail</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p><em>区别</em>
路由里面最常见的渲染组件的属性是 component
component 可以渲染类组件和函数组件</p> <div class="language- extra-class"><pre><code>   render属性页可以渲染组件，render属性只能渲染函数组件
   render后面是可以写函数的, 那么就可以去加入逻辑判断

   children属性也可以渲染组件，也只能渲染函数组件
   不管url是否匹配，都会渲染
   如果加了Switch，那么就和render的效果一摸一样

   在Route组件的里面，直接写组件， 可以渲染类组件和函数组件
   这种方式默认是拿不到路由信息的, 除非配合withRouter高阶组件
</code></pre></div></li></ul></li> <li><p>react 的路由是包容性路由 (vue 的路由是排他性路由)
用 Switch 标签套在 Route 标签外面，如果你要匹配多个路由，你得在外面加一个盒子，确保唯一子元素，读取时从上往下读，只要有一个匹配就不往下匹配了</p> <p>exact 表示精准匹配
Switch 表示 分支匹配， 将包容性路由变成排他性路由</p> <p>注意：</p> <ul><li>Vue 是排他性路由，react 默认是包容性路由</li> <li>react 默认是 history 模式</li> <li>exact 表示精准匹配</li> <li>Switch 表示 分支匹配， 将包容性路由变成排他性路由</li> <li>如果要做二级路由的时候，一级路由不能用精准匹配</li> <li>路由信息要全部来自于 props</li></ul></li> <li><p>路由嵌套 - 二级/多级路由
在嵌套的子组件 也就是二级路由里面在写一个路由 link 标签 对应的 route 标签 这个组件的 props 里面就会有路由信息
// ?. 可选链操作符 - 如果有这个属性就打印如果没有就不打印
console.log(this.props.match?.params?.id);</p></li> <li><p>路由重定向
import { Link, Route, Switch, Redirect } from &quot;react-router-dom&quot;;
从 react-router-dom 中解构出 Redirect 在和 Route 标签平级的地方写重定向标签</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span> <span class="token attr-name">from</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>要改变的路径<span class="token punctuation">&quot;</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>要改成什么路径<span class="token punctuation">&quot;</span></span> <span class="token attr-name">exact</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>路由鉴权
基础原理：
把 Route 标签里面的渲染属性换成 render 里面就可以写逻辑判断了 判断 localstorage 里面是否存在 token 如果有就是登陆过 然后 return 一个要渲染成的组件 不过不存在 token 渲染登录页的组件
写法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span>
  <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">render</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mine</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span> <span class="token attr-name">from</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/login<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>封装组件：
原理：自定义一个组件 用这个组件去替换 route 标签 这个组件 return 一个 Route 标签
写法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 标签部分：</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Auth</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mine</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Auth</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token comment">// 组件部分：</span>
<span class="token keyword">const</span> <span class="token function-variable function">Auth</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Route
      path<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span>
      render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> props<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span>
              <span class="token attr-name">from</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span></span>
              <span class="token attr-name">to</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/login?from=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">.</span>path<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span></span>
            <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token operator">&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>404 页面
404 页面一定要写在 Route 的最下面， Switch 不能少
在所有 route 的最下面写 404 页面的 route 标签</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Not<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>link 标签高亮
// NavLink 具有 Link 所有的功能，并且会多一个高亮的效果
引入的时候引入 NavLink，去替换 Link
NavLink 标签会多一个类名 active 为这个类名添加样式即可
添加样式尾元素写法：
.active::before {
content: &quot;&gt;&quot;;
}</p></li> <li><p>让函数组件有类组件的功能 Hocks
引入 useHistory，useParams，useLocation
import {
Link,
Route,
Switch,
useHistory,
useParams,
useLocation,
} from &quot;react-router-dom&quot;;
在组件里直接打印 Hocks 调用的结构就有了
hooks 是 react16.8 版本新增的， 只能给函数组件使用
帮助函数组件拥有类组件的功能
所有的 hooks 都是函数
hooks 的调用必须在函数组件的顶层</p></li> <li><p>路由模块化
路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的 URL 去切换组件；在 web 应用前端开发中，路由系统是最核心的部分，当页面的 URL 发生改变时，页面的显示结果可以根据 URL 的变化而变化，但是页面不会刷新。</p></li></ol> <ul><li>BrowserRouter 与 HashRouter 的区别：
（1）底层原理不一样：BrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下版本；HashRouter 使用的是 URL 的哈希值；
（2）path 表现形式不一样：BrowserRouter 的路径中没有#,例如：localhost:3000/demo/test；HashRouter 的路径包含#,例如：localhost:3000/#/demo/test；
（3）刷新后对路由 state 参数的影响：BrowserRouter 没有任何影响，因为 state 保存在 history 对象中；HashRouter 刷新后会导致路由 state 参数的丢失；</li></ul> <h3 id="react-router6"><a href="#react-router6" class="header-anchor">#</a> React-Router6</h3> <p>六版本路由和五版本区别总结 yarn add react-router-dom
解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks</p> <ol><li><p>Switch 组件没有了 改成了 Routes， 并且 Routes 是不能少的， 会变成排他性路由 Routes 里面只能放 Route</p></li> <li><p>渲染组件只剩 element 一种了，里面写的是实例化的结果或者元素
不需要加 exact，也是精准匹配
用 element 渲染出来的组件全都是没有路由信息的
想要有路由信息就要用 hocks
</p></li> <li><p>路由嵌套 需要引入 Outlet 组件 相当于 props.children 在 Routes 里面直接做嵌套</p></li> <li><p>link 标签里面可以传 pathname search hash state(看不见的数据传递 不显示在地址栏上面)</p></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span></span>
  <span class="token attr-name">to</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token literal-property property">pathname</span><span class="token operator">:</span> <span class="token string">&quot;/about&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">search</span><span class="token operator">:</span> <span class="token string">&quot;?a=3&amp;b=4&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token string">&quot;#abc&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
      <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="token punctuation">&gt;</span></span><span class="token plain-text">
  about
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Link</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="5"><li><p>编程式导航
在组件里写一个单击事件 引入 useNavigate
const navigate = useNavigate();
const jump = () =&gt; {
// 直接写路径相当于 push
// navigate(&quot;/detail/888&quot;);</p> <p>// 相当于 replace
// navigate(&quot;/home&quot;, { replace: true });</p> <p>// 直接写数字相当于 go 方法
navigate(-2);
};</p></li> <li><p>重定向
Navigate 组件用于做重定向</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">element</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Navigate</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/home<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Navigate</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <h3 id="hash-和-history"><a href="#hash-和-history" class="header-anchor">#</a> hash 和 history</h3> <ul><li>hash
是指 url 中#后面的部分，虽然出现在 URL 中，但不会被包括在 HTTP 请求中，这部分在服务器中会自动被忽略，但是在浏览器中可以通过 location.hash 来获取。主要是用到了，window.hashchange 事件，这个事件可以监听 url 中的 hash 值变化来进行 dom 操作。
onhashchange 事件触发的条件：
改变 url 地址，在最后面增加或者改变 hash 值
改变 location.herf 或者 location.hash
点击带有锚点的链接
浏览器前进后退可能会导致 hash 的变化，就是两个网页地址的 hash 值不同
实现思路：当浏览器地址栏 URl 的 hash 值发生改变时，就会触发 onhashchange 事件，这是需要通过 window.location.hash 可以拿到当前浏览器的 url 的 hash 值，执行不同的回调函数，加载不同的组件。</li> <li>history
利用 window.history 的 api：
主要使用到了 history.pushState()和 history.replaceState()这两个接口。二者均接收三个参数，分别是 state，title，url，
state 用来存放将要插入 history 实体的相关信息，是一个 json 格式的参数； title 是传入 history 实体的标题，firefox 现在会自动忽略掉这个属性；
url 用来传递新的 history 实体的相对路径，如果其值为 null 则表示当前要插入的 history 实体与前一个实体一致，没有改变。
两者唯一的区别在于 replaceState()方法会将最新一条的 history 实体覆盖掉，而不是直接添加。
这两个方法都不会主动触发浏览器页面的刷新，只是 history 对象包括地址栏的内容会发生改变，当触发前进后退等 history 事件时才会进行相应的响应</li> <li>区别：
Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL
History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li></ul> <h3 id="路由鉴权"><a href="#路由鉴权" class="header-anchor">#</a> 路由鉴权</h3> <p>可以在 route 中的 render 上直接做判断
定义一个 auth 的函数组件，传入一个 props，里面 path 就是 props.path
里面 render 的时候做判断 一般都是判断登没登陆过 判断 localStorage 是否有 token，如果有的话就渲染组件，如果没有的话就重定向到登录页面。</p> <h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <ul><li>从 react 中解构出 lazy 和 Suspense</li> <li>lazy 函数传入回调函数，回调函数用 import
例：const Child = lazy(() =&gt; import(&quot;./Child&quot;));</li> <li>lazy 方法要和 Suspense 组件一起使用</li> <li>Suspense 组件需要有一个 fallback 属性，里面写组件，当这个要引得组件还没有引来得时候渲染</li> <li>suspense 要放在要做懒加载的组件外面
例：<div class="language- extra-class"><pre class="language-text"><code>  &lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;
  {this.state.isShow &amp;&amp; &lt;Child /&gt;}
  &lt;/Suspense&gt;
</code></pre></div></li></ul> <h3 id="自定义标签代替-a-标签跳转"><a href="#自定义标签代替-a-标签跳转" class="header-anchor">#</a> 自定义标签代替 a 标签跳转</h3> <ul><li>自定义一个组件，这个组件要去做编程式导航</li> <li>在组件中添加 list，渲染出来</li> <li>将要做跳转的标签加上点击事件</li> <li>如果要做跳转，首先要拿到路由信息的 history 对象</li> <li>编程式导航 go/push/replace/goBack</li></ul> <h2 id="fetch-和-axios-的区别"><a href="#fetch-和-axios-的区别" class="header-anchor">#</a> fetch 和 axios 的区别</h2> <ol><li>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：</li></ol> <ul><li>自动转换 JSON 数据 fetch 不可以 这也就是为什么 axios 只需要一步.then</li> <li>axios 是一个基于 Promise 封装的一个 ajax 库 可以避免回调地狱 可以使用 async + await 实现同步代码</li> <li>axios 可以做拦截 请求数据之前可以做一些业务逻辑的判断 比如说判断有没有 token 如果没有 token 就取消这次请求 请求后也可以进行拦截</li> <li>从浏览器中创建 XMLHttpRequest</li> <li>客户端支持防止 CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>超时取消请求</li></ul> <ol start="2"><li>fetch 优势：
语法简洁，更加语义化
基于标准 Promise 实现，支持 async/await
同构方便，使用 isomorphic-fetch
更加底层，提供的 API 丰富（request, response）
脱离了 XHR，是 ES 规范里新的实现方式 3. fetch 存在问题</li></ol> <ul><li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ul> <h2 id="redux-具体流程-saga"><a href="#redux-具体流程-saga" class="header-anchor">#</a> redux 具体流程 saga</h2> <ol><li><p>创建一个仓库文件夹</p></li> <li><p>从 redux 里面解构出来 createStore 定义一个 store 常量等于 createStore(reducer) 把仓库暴露出去</p></li> <li><p>在 createStore 里面要写一个参数 reducer 一般 reducer 都是建一个单独的 reducer 文件</p></li> <li><p>reducer 里面定义一个 reducer 函数并暴露出去 定义一个 defaultstate 作为 reducer 第一个参数的默认值 reducer = (state = defaultstate , action)</p></li> <li><p>reducer reducer 为纯函数 （一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。）
有两个参数 第一个参数是 state = defaultstate 是状态里面存放数据 第二个参数是 action 用于接收组件传递的参数
写法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> defaultState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// type 的不同表示我们要做不同的事情</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&quot;increment&quot;</span><span class="token operator">:</span>
      <span class="token comment">// 返回出来的对象会去覆盖以前的 state 对象</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将没有进行修改的数据全部保留下来</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&quot;decrement&quot;</span><span class="token operator">:</span>
      <span class="token comment">// 返回出来的对象会去覆盖以前的 state 对象</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将没有进行修改的数据全部保留下来</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> action<span class="token punctuation">.</span>num<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>在入口文件引入 react-redux 并解构出 Provide 引入 store 然后 用<code>&lt;Provide store = {store}&gt;&lt;/Provide&gt;</code>将引入的标签包起来 然后再在组件中从 react-redux 中解构出 { connect } 组件因为他的执行结果是一个高阶组件所以暴露的时候用 connect(mapStateToProps, mapDispatchToProps)(App)</p></li> <li><p>connect 中有两个参数 mapStateToProps 和 mapDispatchToProps 意思是把仓库中的数据映射到 props 里面 用 this.props 可以调用
也可以不用 connect 可以使用 react-redux 提供的两个 hocks useSelector 和 useDispatch 这两个分别是获取仓库数据和调用仓库的方法的
<strong>怎么使用：</strong>
useSelector：
定义一个变量去接收 useSelector 的参数是一个函数 这个函数的参数就是仓库中的 state 就可以获取数据了
const list = useSelector((state) =&gt; state.list);
useDispatch：
定义一个 dispatch 实例 dispatch 调用的时候可以传一个对象作为参数 这个对象就是 reducer 的第二个参数 action 就可以传 type 和数据给仓库</p></li> <li><p>mapStateToProps
写法 ：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将仓库的 count，变成组件的 props 的 count</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>mapDispatchToProps dispatch 方法就相当于调用 reducer 函数
写法 ：</p></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">mapDispatchToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> num <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="10"><li>异步请求数据
store.js
在 store 中从 redux 中引入 applyMiddleware
然后下载 thunk 异步库 import thunk from &quot;redux-thunk&quot;;
创建仓库 createStore(reducer, applyMiddleware(thunk))
建一个 actionCreators.js 文件 在这个文件中写一个函数去 return 一个对象 然后再组件中在引入这个函数去调用他 这样虽然是一样的但是在这个 actionCreators.js 中写的这个函数 return 这个对象之前就可以去请求数据 但是请求到之后还是要写一个同步方法去改变仓库数据 写的这个函数就是个异步函数用这个异步方法去调同步方法改变仓库数据
写法：</li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">initAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;init&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">list</span><span class="token operator">:</span> list <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">initAsyncAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 请求数据</span>
  <span class="token comment">// Actions must be plain objects</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span>
      <span class="token string">&quot;https://www.fastmock.site/mock/15579798b9f988acd4d04ff978a2bd7c/api/list&quot;</span>
    <span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// return { type: &quot;init&quot;, list: res.list };</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">initAction</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="11"><li>异步请求数据 -saga 异步库
思路：
首先在 store 的 index 中改变写法 引 saga 异步库
里面引入 sagas 文件
组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了 在 saga 里面进行一些操作 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer 然后 reducer 去改变里面的数据 最后在组件中再去调用一下仓库中的数据就有请求过后的数据了
组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action
<ol><li>组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了
useEffect(() =&gt; {
dispatch({
type: &quot;init2&quot;,
});
// eslint-disable-next-line
}, []);
2.--_ 在 saga 里面请求数据 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer
import { takeEvery, put, call } from &quot;redux-saga/effects&quot;;
import axios from &quot;axios&quot;;
function_ loadFn() {
// 先请求数据
// call 用来请求数据
const res = yield call(() =&gt; {
return axios
.get(&quot;http://www.pudge.wang:3080/api/rated/list&quot;)
.then((res) =&gt; {
return res.data;
});
});
yield put({
type: &quot;init&quot;,
list: res.result,
});
}
function* mySaga() {
yield takeEvery(&quot;init2&quot;, loadFn);
}
export default mySaga;</li> <li>reducer 去改变里面的数据
const reducer = (state = defaultstate, action) =&gt; {
switch (action.type) {
case &quot;init&quot;:
// console.log(action);
// return {
// ...state,
// list: action.list,
// };
return state.set(&quot;list&quot;, action.list); //immutable 写法
default:
return state;
}
】
最后在组件中再去调用一下仓库中的数据就有请求过后的数据了
这里注意 组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action
import { useSelector, useDispatch } from &quot;react-redux&quot;;
const list = useSelector((state) =&gt; state.get(&quot;list&quot;));</li></ol></li> <li>配置 saga sagas 文件里面请求数据 请求到数据之后调用 put 方法相当于
下载 saga
<ol><li>yarn add redux-saga</li> <li>在 store 中从 redux 中引入 applyMiddleware</li> <li>创建一个 sagas.js 文件 引入到 store 的 index 中
import mySaga from &quot;./sagas&quot;;</li> <li>从 react-saga 中引入 createSagaMiddleware
import createSagaMiddleware from &quot;redux-saga&quot;;</li> <li>createSagaMiddleware 是个函数 将他的执行结果定义为一个变量
const sagaMiddleware = createSagaMiddleware();</li> <li>创建仓库 createStore(reducer, applyMiddleware(sagaMiddleware))</li> <li>最后在暴露之前执行 sagaMiddleware.run(mySaga);
<strong>sagas 文件中写什么</strong>
从 redux-saga/effects 中解构 takeEvery 和 put
import { takeEvery, put } from &quot;redux-saga/effects&quot;;
takeEvery:用来监听的 只要在组件里面去调用 dispatch，会优先进入 mySaga 函数
第一个参数是函数名，对应的是组件的 dispatch 的 type
第二个参数是回调函数
put：用来调用 reducer 的函数
call：用来做数据请求的
里面写一个生成器函数 调用 takeEvery 函数 里面有两个参数 第一个参数是组件调用 dispatch 时候的名字 第二个参数是一个函数可以接收一个参数相当于 reducer 中的 action 第二个参数对应的函数中写 put 函数 put 就相当于调用 dispatch
执行的时候会先到 sagas 这个文件里面来执行过之后再到 reducer
import { takeEvery, put ,call } from &quot;redux-saga/effects&quot;;
function* addFn(action) {
yield put({
type: &quot;add&quot;,
payload: action.payload,
});
}
function* mySaga() {
yield takeEvery(&quot;add2&quot;, addFn);
}
export default mySaga;</li></ol></li> <li>actionTypes 写法就是用一个文件里面定义一个常量大写并暴露出去 替换 reducer 里面的 case 的条件</li> <li>模块化</li></ol> <h3 id="thunk-和-saga-的区别"><a href="#thunk-和-saga-的区别" class="header-anchor">#</a> thunk 和 saga 的区别</h3> <p>redux-thunk 和 redux-saga 处理异步任务的时机不一样。对于 redux-saga，相对于在 redux 的 action 基础上，重新开辟了一个 async action 的分支，单独处理异步任务
saga 自己有一套监听机制 saga 会比 thunk 难一点</p> <h2 id="redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件"><a href="#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件" class="header-anchor">#</a> redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？</h2> <p>redux 本来是同步的，为什么它能执行异步代码
当我们需要修改 store 中值的时候，我们是通过 dispatch(action)将要修改的值传到 reducer 中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理 action 的机会，在 middleware 中，我们可以检阅每一个流过的 action，并挑选出特定类型的 action 进行相应操作，以此来改变 action；
···
applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后 applyMiddleware 会将不同的中间件一层一层包裹到原生的 dispatch 之上；
redux-thunk 中间件的作用就是让我们可以异步执行 redux，首先检查参数 action 的类型，如果是函数的话，就执行这个 action 这个函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action。
···
中间件的实现原理是什么？
中间键的原理就是将原来的 dispatch 存起来然后改变他的指向 重命名
···
都有哪些中间件？
redux-thunk
redux-saga</p> <h2 id="react-按需加载"><a href="#react-按需加载" class="header-anchor">#</a> React 按需加载</h2> <p>从 react 中解构 lazy 引入的时候用 lazy 去替换原本模块化的 import 引入 结合 Router 可以做到组件懒加载的效果
const Home = lazy(() =&gt; import('./routes/Home'))</p> <h2 id="immutable"><a href="#immutable" class="header-anchor">#</a> immutable</h2> <p>用于解决 JavaScript 数据修改的问题
引用数据类型之间传递的是地址 所以当修改其中一个一起改变
为了解决这个问题可以用 深 浅拷贝
JSON.parse JSON.stringfy 当对象的 value 是函数 或者 undefined 时会失效
Object.assign
但是这样会非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable
<strong>例子 ：D:\htlm5\代码\html5-3\React.js\react-basic-2110\src\19-immutable\App.jsx</strong></p> <p>immutable 不可变数据
安装 - yarn add immutable
引入 import { Map, List, Seq, fromJS } from &quot;immutable&quot;;</p> <p>定义 immutableData</p> <ol><li><p>Map
import { Map } from &quot;immutable&quot;;
const obj = Map({
a: 1,
});
获取数据用 get 方法
obj.get('a') // 1</p></li> <li><p>Seq
Seq 可以定义数组和对象
seq 是具有惰性的, 从结果出发，不用的东西是不会执行的</p></li> <li><p>fromJS
fromJS 定义的对象具有深度 里面的对象也是 immutable 对象 formJS 会递归的, 数组和对象都能用</p></li></ol> <p>改变数据需要新建一个变量 用 set 方法定义
const obj2 = obj.set(&quot;a&quot;, 2);</p> <p>obj 于 obj2 比较的时候由于是赋值的所以是需要比较里面的数据相不相同</p> <p>对象合并 - merge</p> <p>定义数组 引入 List
import { List } from &quot;immutable&quot;;
immutable 数组有一些 api，这些 api 很多和原生 api 相同
const list1 = List([1, 2]);
const list2 = list1.push(3, 4, 5); //1 2 3 4 5
const list3 = list2.unshift(0); //0 1 2 3 4 5
const list4 = list1.concat(list2, list3);
console.log(list4);
size 表示数组长度
console.log(list4.size === 13);</p> <p>数组合并 immutable 数组可以使用数组的方法 所以直接 concat 就可以</p> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> WebPack</h2> <h3 id="_1-核心思想"><a href="#_1-核心思想" class="header-anchor">#</a> 1. 核心思想</h3> <p>Webpack 的核心思想是把您项目中的<strong>所有资源</strong>（JavaScript、CSS、图片、字体等）都当作“模块”。它会把这些分散的模块，按照依赖关系，<strong>打包合并</strong>成一个或几个浏览器能直接运行的静态文件（通常是 <code>bundle.js</code>）。</p> <h3 id="_2-工作机制"><a href="#_2-工作机制" class="header-anchor">#</a> 2. 工作机制</h3> <p>它的工作主要就两步：</p> <ol><li><strong>画“关系图” (构建依赖图)</strong>：
<ul><li>Webpack 从您指定的“入口文件”（<code>entry</code>）开始。</li> <li>它会分析这个文件，找出它 <code>import</code> 或 <code>require</code> 了哪些其他模块（比如 <code>utils.js</code>、<code>style.css</code>）。</li> <li>接着，它再去分析 <code>utils.js</code> 和 <code>style.css</code>，看它们又依赖了谁。</li> <li>这样一直找下去，直到把项目里所有模块的依赖关系都搞清楚，形成一个完整的“依赖关系图”(Dependency Graph)。</li></ul></li> <li><strong>“翻译”并打包 (输出 Bundle)</strong>：
<ul><li>拿到这张图后，Webpack 会用 <strong>Loader</strong>（加载器）去“翻译”那些浏览器不认识的模块（比如把 SASS 转成 CSS，把 ES6 转成 ES5）。</li> <li>最后，它把所有处理好的模块，按照图上的关系，聪明地组装打包到您指定的“出口文件”（<code>output</code>）里。</li></ul></li></ol> <h3 id="_3-优点"><a href="#_3-优点" class="header-anchor">#</a> 3. 优点</h3> <p>对我来说，它的优点主要有三个：</p> <ol><li><strong>模块化开发</strong>：它让我们能放心地用模块化的方式写代码（比如 ES Module），Webpack 会处理好模块间的依赖和浏览器兼容性，我们不用再关心 <code>&lt;script&gt;</code> 标签的顺序。</li> <li><strong>性能优化</strong>：它内置了很多优化手段，比如<strong>代码压缩</strong>、<strong>Tree Shaking</strong>（自动删除没用到的代码）、<strong>代码分割</strong>（按需加载），这些都能极大提升页面加载速度。</li> <li><strong>生态强大</strong>：它有 <strong>Loader</strong> 和 <strong>Plugin</strong> 这两大“法宝”。Loader 让我们能处理任何类型的资源，Plugin 则让我们能在打包的整个流程中做各种定制（比如自动生成 HTML 文件），非常灵活。</li></ol> <h3 id="_4-缺点"><a href="#_4-缺点" class="header-anchor">#</a> 4. 缺点</h3> <p>当然，它也有两个比较明显的缺点：</p> <ol><li><strong>配置复杂</strong>：这是它最大的门槛。<code>webpack.config.js</code> 里的配置项非常多，尤其对于新手，要配好一个项目（特别是性能优化部分）需要花不少学习成本。</li> <li><strong>构建速度</strong>：在一些特别大的项目中，它的构建速度（特别是冷启动时）可能会比较慢，需要我们花心思去做各种缓存和构建优化。</li></ol> <h2 id="webpack-与-grunt、gulp"><a href="#webpack-与-grunt、gulp" class="header-anchor">#</a> webpack 与 grunt、gulp</h2> <p>相同点：都是前端构建⼯具，grunt、gulp 以前流⾏，现在 webpack 流⾏，轻量化的任务还是可以⽤ gulp 来实现。
grunt 和 gulp 是基于任务和流的：找到⼀个⼜⼀个⽂件，做链式操作更新流上的数据，这个为⼀个任务，多个任务组成整个 web 构建流程。
webpack 是一个打包模块化 javascript 的工具，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目。loader 用于加载某些资源文件，plugin 用于扩展 webpack 的功能。
webpack 四个组成：⼊⼝，出⼝，loader，plugin</p> <h2 id="类型检查和默认值"><a href="#类型检查和默认值" class="header-anchor">#</a> 类型检查和默认值</h2> <p>函数式组件的默认值只能写成
App.defaultProps = {
msg : &quot;zhangsan&quot;
}
类组件的默认值可以在外面写
App.defaultProps = {
msg : &quot;zhangsan&quot;
}
也可以在类里面加一个 static 表示私有属性
static defaultProps = {
name : &quot;wangwu&quot;
}
static propTypes = {
name: PropTypes.string,
};
类型检查
import PropTypes from 'prop-types';
写法同默认值</p> <h2 id="ts-和-js-的区别-使用-typescript-的好处"><a href="#ts-和-js-的区别-使用-typescript-的好处" class="header-anchor">#</a> Ts 和 JS 的区别 使用 typescript 的好处</h2> <p>区别
Typescript 是 JavaScript 的超集，它支持所有 JavaScript 的语法，并在此基础上添加静态类型定义和面向对象的思想。最终编译成 JavaScript 运行。 TypeScript 它不是一门新的语言，而是用来规范 js 的，js 始终是一门弱类型语言 ，ts 它是 js 的超集 js 分成 EcmaScript(js 的语法规范),Dom(文档对象模型),Bom(浏览器对象模型)ts 实际上是 EcmaScript 的超集, ts 是强类型版的 js</p> <p>使用 typescript 的好处</p> <p>1.开源，跨平台。它本身不需要考虑运行环境的问题，所有支持 JavaScript 的地方都可以使用 typescript； 2.引入静态类型声明，减少不必要的类型判断和文档注释；
3。及早发现错误，静态类型检查 1 或编译时发现问题，不用等到运行； 4.类、接口的使用更易于构建和维护组件； 5.重构更方便可靠，适合大型项目；</p> <h2 id="react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数"><a href="#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数" class="header-anchor">#</a> react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数</h2> <ul><li><p>react 中的 key 有什么作用</p> <p>1.简单的来说就是为了提高 diff 的同级比较的效率，避免原地复用带来的副作用
2.react 利用 key 来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个 key 对应一个组件，相同的 key react 认为是同一个组件，这样后续相同的 key 对应组件都不会被创</p></li></ul> <p>key 发生变化会发生什么</p> <p>key 值不同组件会销毁再重新创建</p> <p>key 值发生改变后会执行哪些生命周期函数</p> <p>1.componentWillUnmount
2.constructor
3.componentWillMount（可以不说）
4.render
5.componentDidMount</p> <h2 id="react-中的闭包陷阱-closure-trap"><a href="#react-中的闭包陷阱-closure-trap" class="header-anchor">#</a> React 中的闭包陷阱(Closure Trap)</h2> <h3 id="_1-什么是闭包陷阱"><a href="#_1-什么是闭包陷阱" class="header-anchor">#</a> 1. 什么是闭包陷阱？</h3> <p>在 React 的函数式组件中，<strong>闭包陷阱</strong>常发生在 <code>useEffect</code>、<code>useCallback</code> 等 Hooks 中。其本质是：组件中的函数（尤其是在 effect 或回调中）形成了一个闭包，捕获并持有了<strong>旧的（过时的）state 或 props 值</strong>。</p> <ul><li><p>核心原因</p> <ul><li>React 的函数组件每次渲染都是一次独立的“快照”。</li> <li>组件内部的所有变量（state, props）和函数，都是该次渲染“快照”的一部分。</li> <li>如果某个函数是在某次渲染中创建的，它就会“记住”当时的 state 和 props。</li> <li>如果这个函数在后续渲染中没有被更新，它“记住”的就永远是旧的值。</li></ul></li></ul> <hr> <h3 id="_2-经典陷阱案例-setinterval-计数器"><a href="#_2-经典陷阱案例-setinterval-计数器" class="header-anchor">#</a> 2. 经典陷阱案例：setInterval 计数器</h3> <ul><li><p>错误示例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">IntervalCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里形成了闭包，count 永远是初始值</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">正在更新 count... 闭包中捕获的 count 值是 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖数组为空，仅组件挂载时运行一次</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>问题分析</p> <ul><li>初始渲染：<code>count</code> 为 0，<code>useEffect</code> 执行，<code>setInterval</code> 的回调函数被创建。</li> <li>闭包形成：<code>setInterval</code> 的回调函数“记住”了初始渲染时的 <code>count</code>，这个值永远是 0。</li> <li>后续行为：
<ol><li>1 秒后，定时器触发，执行 <code>setCount(0 + 1)</code>，<code>count</code> 变为 1。</li> <li>2 秒后，定时器再次触发，但回调函数闭包里的 <code>count</code> 依旧是 0，再次 <code>setCount(0 + 1)</code>。</li></ol></li> <li><strong>最终结果</strong>：<code>count</code> 的值只会在 0 和 1 之间来回变化，无法持续递增。</li></ul></li></ul> <hr> <h3 id="_3-如何避免闭包陷阱"><a href="#_3-如何避免闭包陷阱" class="header-anchor">#</a> 3. 如何避免闭包陷阱？</h3> <ul><li>方法一：正确使用依赖数组</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把 count 加入依赖数组</span>
</code></pre></div><ul><li>原理：<code>count</code> 每次改变，<code>useEffect</code> 会重新执行，旧定时器被清除，创建新定时器，捕获到最新的 <code>count</code>。</li> <li>缺点：对于 <code>setInterval</code> 这类场景，频繁清除/创建定时器有性能开销，可能导致计时不准，通常<strong>不推荐</strong>。</li></ul> <hr> <ul><li>方法二：使用函数式更新（推荐）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数式更新</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖数组为空</span>
</code></pre></div><ul><li>原理：<code>setCount</code> 传入函数，React 会确保 <code>prevCount</code> 永远是<strong>最新的状态值</strong>。</li> <li>优点：无须依赖外部闭包的变量，写法简洁，性能好，是最佳实践。</li></ul> <hr> <ul><li>方法三：使用 useRef 保存最新值</li></ul> <p>适用于需要在异步回调中<strong>读取最新 state 或 props</strong>的场景。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">IntervalCounterWithRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> countRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 同步 ref 的值</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    countRef<span class="token punctuation">.</span>current <span class="token operator">=</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>countRef<span class="token punctuation">.</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>原理：<code>ref</code> 对象在组件整个生命周期中不变。闭包捕获的是 <code>countRef</code> 这个稳定对象，通过 <code>.current</code> 总能读取到最新的 <code>count</code>。</li> <li>优点：适用于任何需要异步回调中获取最新 state/props 的场景，通用性强。</li></ul> <hr> <h3 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4. 总结</h3> <ul><li><strong>闭包陷阱</strong>是 React 函数组件开发中常见的陷阱，尤其在 <code>useEffect</code>、<code>setInterval</code>、异步回调等场景中。</li> <li>推荐优先使用<strong>函数式更新</strong>解决闭包陷阱。</li> <li>更复杂的场景下，可以通过 <code>useRef</code> 解决对最新 state/props 的读取问题。</li></ul> <hr> <h3 id="_5-参考"><a href="#_5-参考" class="header-anchor">#</a> 5. 参考</h3> <ul><li><a href="https://react.dev/reference/react/useState" target="_blank" rel="noopener noreferrer">React 官方文档 - Using the State Hook<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904186715285512" target="_blank" rel="noopener noreferrer">深入理解 React Hooks 的闭包陷阱<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="redux-和-mobx-的区别"><a href="#redux-和-mobx-的区别" class="header-anchor">#</a> redux 和 mobx 的区别</h2> <p>mobx 和 redux 的区别主要分为以下几个方面</p> <ul><li><p><strong>Redux：</strong> <strong>单一数据源 (Single Source of Truth)</strong></p> <ul><li>整个应用的 state 被存储在一个单一的、巨大的 JavaScript 对象中（Store）。</li> <li>这个 state 对象是<strong>只读的 (Immutable)</strong>。</li></ul></li> <li><p><strong>MobX：</strong> <strong>分散的、可观察的数据 (Observable State)</strong></p> <ul><li>允许有多个独立的 Store 来管理不同模块的 state。</li> <li>State 是<strong>可变的 (Mutable)</strong>，但这些变化是被“监视”的。</li></ul></li></ul> <h3 id="工作机制对比"><a href="#工作机制对比" class="header-anchor">#</a> 工作机制对比</h3> <ul><li><strong>Redux：</strong> Redux 通过 dispatch 派发一个不可变的 action 动作，通过 reducer 接收，让 reducer 产生一个新的 State，View 订阅 store 的变化并且进行更新</li> <li><strong>MobX：</strong> Mobx 通过 Observable 将 state 标记为可观察的，然后通过 action 直接修改 state 的属性，mobx 会自动的更新视图。</li></ul> <h4 id="_1-状态更新"><a href="#_1-状态更新" class="header-anchor">#</a> 1. 状态更新</h4> <ul><li><p><strong>Redux：</strong> <strong>严格且明确</strong></p> <ol><li><strong>Action：</strong> 必须派发（dispatch）一个“动作”（Action），这是一个描述“发生了什么”的普通对象。</li> <li><strong>Reducer：</strong> 编写纯函数（Reducer）来接收旧的 state 和 Action。</li> <li><strong>New State：</strong> Reducer 返回一个<strong>全新的</strong> state 对象，而不是修改旧的。</li> <li><strong>View：</strong> 视图（如 React 组件）订阅 Store 的变化并更新。</li></ol> <ul><li><strong>特点：</strong> 流程非常清晰、可预测、可回溯。</li></ul></li> <li><p><strong>MobX：</strong> <strong>隐式且自动</strong></p> <ol><li><strong>Observable：</strong> 将 state 标记为“可观察的”。</li> <li><strong>Action：</strong> （可选但推荐）在一个标记为“action”的函数中，<strong>直接修改</strong> state 属性。</li> <li><strong>Reaction：</strong> 视图（如 React 组件）被标记为“观察者”（Observer）。</li> <li><strong>Auto-Update：</strong> 当被观察的 state 变化时，MobX 会自动且精确地更新“观察”了该 state 的视图。</li></ol> <ul><li><strong>特点：</strong> 非常自动、代码量少、“魔法”。</li></ul></li></ul> <h4 id="_2-数据处理"><a href="#_2-数据处理" class="header-anchor">#</a> 2. 数据处理</h4> <ul><li><strong>Redux：</strong> <strong>规范化 (Normalized)</strong> <ul><li>倾向于将 state 组织得像数据库一样，避免数据嵌套，使用 ID 进行关联。</li> <li>数据是普通的 JS 对象或数组。</li></ul></li> <li><strong>MobX：</strong> <strong>嵌套 (Nested)</strong> <ul><li>可以随意使用嵌套的对象和数组。</li> <li>数据被包装成“可观察”对象，不是普通对象。</li></ul></li></ul> <h3 id="内部原理对比"><a href="#内部原理对比" class="header-anchor">#</a> 内部原理对比</h3> <h4 id="mobx-原理"><a href="#mobx-原理" class="header-anchor">#</a> MobX 原理</h4> <ul><li>依赖追踪</li></ul> <p>当一个被 observer 包裹的 React 组件在执行 render 时，MobX 会“监视”这个过程。它会精确地记录下这个 render 函数读取了哪些可观察（Observable）的属性。</p> <p>比如，我的组件只用到了 store.user.name，MobX 就会记下：“OK，这个组件依赖 store.user.name”。它并不会关心 store.user.age 或其他数据。</p> <ul><li>触发反应</li></ul> <p>当我的代码通过 action 去修改（写入）这个 store.user.name 时，MobX 就会立即启动“反应”。</p> <p>它会去查看它在第一步中记录的依赖列表，然后找到所有订阅了 store.user.name 的组件，并通知它们：“你依赖的数据变了，请重新渲染”。</p> <ul><li>总结</li></ul> <p>MobX 的高效就来自于这种精细化的订阅。它不像 Context 那样，value 一变就通知所有组件。MobX 能精确到**“哪个组件”依赖了“哪个属性”**，实现了最小范围的更新，所以性能非常好，也不需要我们手动去写 useMemo 优化</p> <h4 id="redux-原理"><a href="#redux-原理" class="header-anchor">#</a> Redux 原理</h4> <ol><li><p>Action 派发与 Reducer
当我想更新状态时（比如点击按钮），我不能像 MobX 那样直接修改 store，我必须 dispatch（派发）一个 Action。这个 Action 是一个普通的 JavaScript 对象，比如 { type: 'SET_USER_NAME', payload: 'B' }。</p> <p>Redux 的 Store 接收到这个 Action 后，会把它和当前完整的 State 一起，传递给我预先定义好的 Reducer 函数。</p> <p>Reducer 是一个纯函数。它拿到旧的 State 和 Action，绝不会修改旧 State，而是会返回一个全新的 State 对象（这就是“不可变性”）。</p></li> <li><p>状态订阅与 useSelector</p> <p>Redux 的 Store 本身并不知道“哪个组件”依赖了“哪个属性”。</p> <p>在 React 中，我们使用 react-redux 的 useSelector 钩子来显式地“订阅” store 中的数据。</p> <p>比如，我的组件写了 const name = useSelector(state =&gt; state.user.name)。</p> <p>react-redux 会立即执行这个 selector 函数拿到 name，并且“记住”这个组件和它上次返回的值。</p></li> <li><p>更新机制：广播与浅比较</p> <p>当 Reducer 返回了全新的 State 对象后，Store 会**“广播”一个通知，告诉所有**通过 useSelector 订阅了的组件 State 改变了</p> <p>react-redux 收到通知后，会在每一个订阅的组件里，重新运行它的 selector 函数（state =&gt; state.user.name），拿到新 state 下的值。</p> <p>然后，它会用浅比较（===），对比“这次拿到的新值”和“它上次记住的旧值”。</p> <p>只有当这个值真的发生了变化时，react-redux 才会触发这个组件重新渲染。如果值没变（比如我更新的是 age，但这个组件只订阅了 name），组件就不会更新。</p></li></ol> <ul><li><p>总结：</p> <p>MobX 的高效来自于**“精细化的自动追踪”**，它知道哪个属性变了，就只更新对应的组件。</p> <p>Redux 的高效则来自于**“不可变性 + 浅比较”**。它先把更新“广播”给所有订阅者，然后由 react-redux 在组件层级通过 useSelector 进行快速的浅比较，来决定是否需要重新渲染。</p></li></ul> <h3 id="设计哲学"><a href="#设计哲学" class="header-anchor">#</a> 设计哲学</h3> <ul><li><strong>Redux：</strong> <strong>追求可预测性 (Predictability)</strong> <ul><li>借鉴了函数式编程（FP）思想。</li> <li>核心是“事件溯源”，所有 state 变化都有清晰的记录（Actions），非常利于调试大型、复杂的应用（例如时间旅行调试）。</li></ul></li> <li><strong>MobX：</strong> <strong>追求简洁和效率 (Simplicity &amp; Efficiency)</strong> <ul><li>借鉴了面向对象（OOP）和响应式编程（RP）思想。</li> <li>核心是让状态管理尽可能“透明”，开发者像操作普通 JS 对象一样操作 state，MobX 负责在背后处理更新。</li></ul></li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ul><li><strong>Redux：</strong> <ul><li><strong>样板代码 (Boilerplate)：</strong> 最大的问题。为了改一个简单数据，需要写 Action Type、Action Creator、Reducer case，流程很长。</li> <li><strong>学习曲线：</strong> 需要理解纯函数、Immutability、中间件（Middleware）等概念。</li> <li><strong>性能：</strong> 默认情况下，任何 dispatch 都会通知所有订阅者，可能需要手动优化（如使用 <code>reselect</code>）。</li></ul></li> <li><strong>MobX：</strong> <ul><li><strong>“魔法” (Magic)：</strong> 自动更新很爽，但也意味着出错时很难排查“为什么更新了”或“为什么没更新”。</li> <li><strong>调试：</strong> 不如 Redux 的“Action 日志”清晰，虽然也有工具，但可追溯性较差。</li> <li><strong>规范：</strong> 因为太灵活，团队成员可能用不同的方式修改 state，导致代码风格混乱（需要用 <code>action</code> 来约束）。</li></ul></li></ul> <hr> <h3 id="总结对比表"><a href="#总结对比表" class="header-anchor">#</a> 总结对比表</h3> <table><thead><tr><th><strong>特性</strong></th> <th><strong>Redux</strong></th> <th><strong>MobX</strong></th></tr></thead> <tbody><tr><td><strong>核心范式</strong></td> <td>函数式编程 (FP)</td> <td>响应式编程 (OOP/RP)</td></tr> <tr><td><strong>State 结构</strong></td> <td>单一 Store，普通对象</td> <td>多个 Store，可观察对象</td></tr> <tr><td><strong>State 可变性</strong></td> <td><strong>不可变 (Immutable)</strong></td> <td><strong>可变 (Mutable)</strong></td></tr> <tr><td><strong>更新方式</strong></td> <td><strong>明确的</strong> (Dispatch Action -&gt; Reducer)</td> <td><strong>隐式的</strong> (直接修改被观察的属性)</td></tr> <tr><td><strong>样板代码</strong></td> <td>多</td> <td>少</td></tr> <tr><td><strong>调试</strong></td> <td>极强（时间旅行）</td> <td>较弱（依赖追踪）</td></tr> <tr><td><strong>学习曲线</strong></td> <td>较陡</td> <td>较平</td></tr></tbody></table> <h2 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h2> <h3 id="核心思想-组件的-记忆化"><a href="#核心思想-组件的-记忆化" class="header-anchor">#</a> 核心思想：组件的“记忆化”</h3> <ul><li><strong>它是什么：</strong> 一个<strong>高阶组件 (HOC)</strong>，即一个用来“包裹”你组件的函数。</li> <li><strong>工作机制：</strong> <ol><li>你用 <code>React.memo</code> 包裹一个功能组件（<code>const MyMemoizedComponent = React.memo(MyComponent)</code>）。</li> <li>当其<strong>父组件</strong>重新渲染时，<code>React.memo</code> 会“拦截”这次渲染。</li> <li>它会**“浅比较”** (shallow compare) 这次传给 <code>MyComponent</code> 的 <code>props</code> 和上一次的 <code>props</code>。</li> <li><strong>决策：</strong> <ul><li>如果所有 <code>props</code> <strong>都</strong> <code>===</code> (严格相等)，<code>React.memo</code> 就会<strong>阻止 MyComponent 重新渲染</strong>，并直接复用上一次的渲染结果。</li> <li>如果有<strong>任何一个</strong> <code>prop</code> 变了，它才会允许 <code>MyComponent</code> 重新渲染。</li></ul></li></ol></li> <li><strong>目的/作用：</strong> <ul><li>它的<strong>唯一目的</strong>是：<strong>防止组件因为“父组件更新”而导致的“被动”重新渲染</strong>。</li></ul></li> <li><strong>关键点 (类比)：</strong> <ul><li><code>React.memo</code> 之于“函数组件”，就如同 <code>PureComponent</code> 之于“类组件”。</li></ul></li></ul> <h2 id="react-18-启用-fiber-架构"><a href="#react-18-启用-fiber-架构" class="header-anchor">#</a> React 18：启用 Fiber 架构</h2> <p>React 18 的核心主题是**“并发”**。它引入了一个可中断的渲染引擎 <a href="#fiber-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6">fiber 架构</a>，让 React 在处理复杂渲染时也能保持 UI 的流畅响应。</p> <h3 id="自动批处理-automatic-batching"><a href="#自动批处理-automatic-batching" class="header-anchor">#</a> 自动批处理 (Automatic Batching)</h3> <ul><li><strong>核心思想：</strong> 把多次 <code>setState</code> 合并为一次渲染。</li> <li><strong>工作机制：</strong> R17 只在 React 事件（如 <code>onClick</code>）中批处理。R18 将其扩展到了 <code>Promise</code>、<code>setTimeout</code> 等<strong>任何异步</strong>回调中。</li> <li><strong>目的/作用：</strong> 减少不必要的重复渲染。</li></ul> <h3 id="新-hooks"><a href="#新-hooks" class="header-anchor">#</a> 新 Hooks</h3> <ul><li><strong>useId</strong>：解决 SSR (服务端渲染) 场景下，客户端和服务器端 ID 不匹配导致的“水合”错误。</li> <li><strong>useDeferredValue</strong>：<code>useTransition</code> 的“数据”版本，用于推迟更新一个“非紧急”的值。</li></ul> <hr> <h2 id="react-19-编译器与新架构"><a href="#react-19-编译器与新架构" class="header-anchor">#</a> React 19：编译器与新架构</h2> <p>React 19 的核心主题是**“大幅简化开发”**。它通过“编译器”自动化了性能优化，并通过“RSC 架构”重塑了我们编写和交付组件的方式。</p> <h3 id="react-编译器"><a href="#react-编译器" class="header-anchor">#</a> React 编译器</h3> <ul><li><strong>核心思想：</strong> 从“手动优化”转向“自动优化”。</li> <li><strong>工作机制：</strong> 这是一个构建时工具，它会自动分析你的组件代码。</li> <li><strong>目的/作用：</strong> 编译器会自动帮你实现 <code>useMemo</code>、<code>useCallback</code> 和 <code>React.memo</code> 的功能。开发者<strong>不再需要</strong>（或极少需要）手动包裹这些 Hooks，极大简化了代码。</li></ul> <h3 id="actions"><a href="#actions" class="header-anchor">#</a> Actions</h3> <ul><li><strong>核心思想：</strong> 将“数据提交”和“状态管理”内置到 React 中。</li> <li><strong>工作机制：</strong> 允许在 <code>&lt;form&gt;</code> 上使用 <code>action</code> 属性绑定异步函数，并配合新 Hooks (<code>useOptimistic</code>, <code>useFormStatus</code>) 自动管理 <code>pending</code>、<code>error</code> 等状态。</li> <li><strong>目的/作用：</strong> 大幅简化表单和异步数据提交的模板代码。</li></ul> <h3 id="server-components-rsc-新架构"><a href="#server-components-rsc-新架构" class="header-anchor">#</a> Server Components (RSC - 新架构)</h3> <p>这是 React 19 最大的架构变化，也是刚才我们讨论的重点，它与 SSR (服务端渲染) 是<strong>完全不同</strong>的概念。</p> <ul><li><strong>它是一种“组件架构”，不是一种“渲染模式”</strong> <ul><li>它把 React 组件<strong>严格拆分</strong>为两种类型。</li></ul></li> <li><strong>A. 服务端组件 (Server Components - RSC)</strong> <ul><li><strong>这是默认的</strong>（在 Next.js App Router 中）。</li> <li><strong>工作机制：</strong> <ol><li>它<strong>只在</strong>服务端运行。</li> <li>你可以<strong>直接</strong>在组件里用 JS/React 语法（<code>async/await</code>）访问数据库或后端资源。</li> <li>它的 JS 代码<strong>永远不会</strong>发送到浏览器。</li></ol></li> <li><strong>关键点 (水合)：</strong> 因为它的 JS 不会发送到客户端，所以 RSC <strong>“永不水合” (No Hydration)</strong>。它对于浏览器来说是纯静态的。</li> <li><strong>限制：</strong> 不能使用 <code>useState</code>, <code>useEffect</code>, <code>onClick</code> 等任何客户端 Hooks。</li></ul></li> <li><strong>B. 客户端组件 (Client Components)</strong> <ul><li><strong>这是您写前端业务逻辑的地方。</strong></li> <li><strong>工作机制：</strong> <ol><li>你<strong>必须</strong>在文件顶部用 <code>&quot;use client&quot;;</code> 标记。</li> <li><strong>所有</strong>的 Hooks (<code>useState</code> 等) 和事件 (<code>onClick</code>) <strong>必须</strong>写在这里面。</li></ol></li> <li><strong>关键点 (水合)：</strong> 客户端组件的 JS 代码<strong>会</strong>被发送到浏览器。</li> <li><strong>它与 SSR 的关系：</strong> Next.js 仍然会<strong>对客户端组件执行 SSR</strong>，即在服务器上预渲染它们，生成<strong>静态 HTML</strong> 发给浏览器（保证首屏速度），然后客户端下载 JS 包，执行**“水合” (Hydration)**，让这些 HTML 变得可交互。</li></ul></li></ul> <hr> <h3 id="总结-rsc-与-ssr-的协同工作"><a href="#总结-rsc-与-ssr-的协同工作" class="header-anchor">#</a> 总结：RSC 与 SSR 的协同工作</h3> <p>所以，在 React 19 和 Next.js App Router 的新模型下：</p> <ul><li><strong>RSC (服务端组件)</strong> 负责“骨架”和“数据获取”，它的 JS 留在服务器，<strong>不水合</strong>。</li> <li><strong>SSR (服务端渲染)</strong> 负责预渲染那些“交互点”（<code>&quot;use client&quot;;</code> 组件），生成 HTML。</li> <li><strong>Hydration (水合)</strong> <strong>只会</strong>发生在那些 <code>&quot;use client&quot;;</code> 的“群岛”上，以激活它们的交互性。</li></ul> <p>这是一个“混合”模型，它让我们的应用兼顾了“零 JS 体积”（RSC）和“丰富交互性”（Client Components）。</p> <h2 id="自定义-hooks-的设计规范"><a href="#自定义-hooks-的设计规范" class="header-anchor">#</a> 自定义 Hooks 的设计规范</h2> <ul><li><strong>它是一种模式，不是一个功能</strong>：自定义 Hook 本质上只是一个<strong>普通的 JavaScript 函数</strong>。</li> <li><strong>它的特殊性</strong>：这个函数特殊在它的“内部”调用了其他 React Hooks（如 <code>useState</code>, <code>useEffect</code> 或其他自定义 Hooks）。</li> <li><strong>它的命名</strong>：它的名字<strong>必须</strong>以 <code>use</code> 开头（例如 <code>useWindowSize</code>）。</li></ul> <h3 id="目的"><a href="#目的" class="header-anchor">#</a> 目的</h3> <ul><li><strong>复用“有状态的逻辑”</strong>：这是它的唯一目的。</li> <li><strong>场景</strong>：当你有多个组件都需要做同样的事情时（比如：订阅事件、获取数据、跟踪表单状态），你就可以把这套“包含了 state 或 effect”的逻辑，抽离到一个自定义 Hook 中。</li> <li><strong>保持组件简洁</strong>：它能把复杂的逻辑从组件视图中剥离出去，让组件只关心 UI 渲染。</li></ul> <hr> <h3 id="规范一-必须以-use-开头"><a href="#规范一-必须以-use-开头" class="header-anchor">#</a> 规范一：必须以 <code>use</code> 开头</h3> <p>这是最表面，但也是最关键的“入口”规范。</p> <ul><li><strong>核心思想</strong>：这是一个<strong>命名约定</strong>。</li> <li><strong>工作机制</strong>：React 本身并不关心函数名叫什么。但是，<strong>ESLint 插件 (linter)</strong> 会“盯”这个 <code>use</code> 前缀。</li> <li><strong>目的/作用</strong>：
<ol><li><strong>代码可读性</strong>：开发者一看 <code>use</code> 就知道：“哦，这里面有状态，它必须遵守 Hook 的规则”。</li> <li><strong>自动检查</strong>：更重要的是，ESLint 插件会<strong>自动帮你检查</strong>你是否违反了“规范二”（在循环或 <code>if</code> 中调用）。如果你不以 <code>use</code> 开头，linter 就“瞎了”，无法帮你检查错误。</li></ol></li></ul> <h3 id="规范二-只能在-顶层-调用"><a href="#规范二-只能在-顶层-调用" class="header-anchor">#</a> 规范二：只能在“顶层”调用</h3> <p>这是 React 工作的<strong>核心依赖</strong>，也是最容易出问题的。</p> <ul><li><strong>核心思想</strong>：永远在你的 React 函数（或另一个自定义 Hook）的<strong>最顶层</strong>调用 Hooks。</li> <li><strong>绝对禁止</strong>：
<ul><li><strong>禁止在 if 语句中调用</strong></li> <li><strong>禁止在 for 或 while 循环中调用</strong></li> <li><strong>禁止在普通 JS 函数中调用</strong> (包括 <code>useEffect</code> 的回调、事件处理器如 <code>onClick</code> 等)</li></ul></li></ul> <h3 id="为什么必须在顶层"><a href="#为什么必须在顶层" class="header-anchor">#</a> 为什么必须在顶层？</h3> <p>这背后的原因是 React 内部<strong>没有</strong>用“名字”来识别 Hooks，它完全依赖于**“调用顺序”**。</p> <ul><li><strong>工作机制</strong> <ul><li>React 在内部为每个组件维护了一个（概念上的）<strong>数组</strong>或<strong>链表</strong>，用来存储 Hooks 的状态。</li> <li><strong>第一次渲染 (mount)</strong>：
<ol><li>你调用 <code>useState(&quot;A&quot;)</code> -&gt; React 把 &quot;A&quot; 存到<strong>数组第 0 位</strong>。</li> <li>你调用 <code>useEffect(...)</code> -&gt; React 把 effect 存到<strong>数组第 1 位</strong>。</li> <li>你调用 <code>useState(&quot;B&quot;)</code> -&gt; React 把 &quot;B&quot; 存到<strong>数组第 2 位</strong>。</li></ol></li> <li><strong>第二次渲染 (re-render)</strong>：
<ol><li>React 期待<strong>第一个</strong>被调用的 Hook 是“第 0 位的 <code>useState</code>”，于是它返回 &quot;A&quot; 的当前状态。</li> <li>React 期待<strong>第二个</strong>被调用的 Hook 是“第 1 位的 <code>useEffect</code>”。</li> <li>...以此类推。</li></ol></li></ul></li> <li><strong>如果你违反了规则</strong> <ul><li><strong>场景</strong>：假设你在<strong>第二次</strong>渲染时，用一个 <code>if</code> 语句<strong>跳过</strong>了第一个 <code>useState</code> 的调用。</li> <li><strong>灾难</strong>：
<ol><li>React 期待的“第 0 位 <code>useState</code>”没来。</li> <li>你调用的第一个 Hook 变成了 <code>useEffect</code>。</li> <li>React 以为这个 <code>useEffect</code> 是“第 0 位 Hook”，于是尝试从第 0 位取状态... <strong>整个链表全部错位</strong>，React 彻底混乱了。</li></ol></li></ul></li></ul> <p><strong>总结</strong>：<code>use</code> 开头是给 linter 看的，而“顶层调用”是给 React 内部的“顺序记账本”机制看的。</p> <hr> <h3 id="hooks-复用的是逻辑-不是状态"><a href="#hooks-复用的是逻辑-不是状态" class="header-anchor">#</a> Hooks 复用的是逻辑，不是状态</h3> <ul><li><strong>核心思想</strong>：每次你在组件中调用一个自定义 Hook，你都是在“复印”一份新的逻辑。</li> <li><strong>举例</strong>：
<ul><li><code>组件A</code> 调用了 <code>useMyHook()</code>。</li> <li><code>组件B</code> 也调用了 <code>useMyHook()</code>。</li></ul></li> <li><strong>结果</strong>：这两个组件各自拥有<strong>一套完全独立、互不相干的状态</strong>。<code>useMyHook</code> 内部的 <code>useState</code> 在组件 A 和组件 B 中是<strong>完全隔离</strong>的。</li> <li><strong>对比</strong>：这和 Redux 或 Zustand 那种“共享全局状态”的模式是完全不同的。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.f81cf313.js" defer></script><script src="/jiabinxu-blog/assets/js/3.bb87b8ff.js" defer></script><script src="/jiabinxu-blog/assets/js/2.180c3171.js" defer></script><script src="/jiabinxu-blog/assets/js/49.ed08971b.js" defer></script>
  </body>
</html>
