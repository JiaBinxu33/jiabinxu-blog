<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 基础部分 | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.ec81c2a4.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.c5fdad7d.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.34d20650.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/48.05896a6c.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.90fb1753.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.b39679df.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.8187523c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.0bc8e462.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.ccfaad73.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.cec46538.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.380c784d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.bfab453a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.6516dd9c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.52e99ec1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.33ab9282.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.20d5488c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.da345bbd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.306efef7.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.257df29b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.8f6a39a4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.b9965851.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.da12a983.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.94ca7cf0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.629923f3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.eb4c3c24.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.189b8eea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.309f3546.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.8ebea494.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.e84b982a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.e9872d14.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.13bfd9fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.d36e48f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.44ec783e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.e5568ed9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.04437602.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.77566d25.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.771b0795.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.4f5d6672.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.80005314.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.13eb153e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.81101b31.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1111d26e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.4e36f15a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.426d3a06.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.0cddb7d0.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.3b97796b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.ca777a9f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.8d56997f.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.53a63991.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.c37f8662.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.85309368.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.e90aa37c.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.37829d64.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.42652f54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.9a0bab4a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/68.605d1390.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.c655efdc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.f71f155e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.fe87e7ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.3e9861fb.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.987510dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.a6595e30.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/常见面试手写题/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/JavaScript核心对象/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 基础部分</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/React/#react-的特征" class="sidebar-link">react 的特征</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#jsx-语法" class="sidebar-link">jsx 语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#函数组件和-class-组件区别" class="sidebar-link">函数组件和 class 组件区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#mvc-和-mvvm-的区别" class="sidebar-link">MVC 和 MVVM 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-组件通信方法" class="sidebar-link">React 组件通信方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-父组件向子组件通信-props" class="sidebar-link">1. 父组件向子组件通信 (Props)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-子组件向父组件通信-回调函数" class="sidebar-link">2. 子组件向父组件通信 (回调函数)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-跨级组件通信-context-api" class="sidebar-link">3. 跨级组件通信 (Context API)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-状态管理库-redux-zustand-等" class="sidebar-link">4. 状态管理库 (Redux / Zustand 等)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-本地状态共享-hooks" class="sidebar-link">5. 本地状态共享 (Hooks)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_6-非嵌套组件通信-发布-订阅模式" class="sidebar-link">6. 非嵌套组件通信 (发布-订阅模式)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/jiabinxu-blog/React/#事件处理" class="sidebar-link">事件处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-事件命名和绑定" class="sidebar-link">1. 事件命名和绑定</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-阻止默认行为和事件冒泡" class="sidebar-link">2. 阻止默认行为和事件冒泡</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-向事件处理函数传递参数" class="sidebar-link">3. 向事件处理函数传递参数</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-事件对象" class="sidebar-link">4. 事件对象</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-this-指向" class="sidebar-link">5. this 指向</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_6-事件池机制" class="sidebar-link">6. 事件池机制</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_7-常用事件类型" class="sidebar-link">7. 常用事件类型</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_8-事件冒泡与捕获" class="sidebar-link">8. 事件冒泡与捕获</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_9-事件委托" class="sidebar-link">9. 事件委托</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_10-组合使用" class="sidebar-link">10. 组合使用</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#总结-2" class="sidebar-link">总结</a></li></ul></li><li><a href="/jiabinxu-blog/React/#受控组件与非受控组件" class="sidebar-link">受控组件与非受控组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#hoc-高阶组件" class="sidebar-link">hoc 高阶组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#diff-算法-react-fiber-虚拟-dom" class="sidebar-link">diff 算法 React Fiber 虚拟 dom</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#时间复杂度-空间复杂度" class="sidebar-link">时间复杂度 空间复杂度</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#protal-将组件放到页面中任意你想放的位置" class="sidebar-link">protal 将组件放到页面中任意你想放的位置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-路由" class="sidebar-link">React 路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#react5" class="sidebar-link">React5</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#react-router6" class="sidebar-link">React-Router6</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#hash-和-history" class="sidebar-link">hash 和 history</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#路由鉴权" class="sidebar-link">路由鉴权</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#自定义标签代替-a-标签跳转" class="sidebar-link">自定义标签代替 a 标签跳转</a></li></ul></li><li><a href="/jiabinxu-blog/React/#fetch-和-axios-的区别" class="sidebar-link">fetch 和 axios 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#redux-具体流程-saga" class="sidebar-link">redux 具体流程 saga</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#thunk-和-saga-的区别" class="sidebar-link">thunk 和 saga 的区别</a></li></ul></li><li><a href="/jiabinxu-blog/React/#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件" class="sidebar-link">redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-按需加载" class="sidebar-link">React 按需加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#immutable" class="sidebar-link">immutable</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#webpack" class="sidebar-link">WebPack</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#webpack-与-grunt、gulp" class="sidebar-link">webpack 与 grunt、gulp</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#类型检查和默认值" class="sidebar-link">类型检查和默认值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#ts-和-js-的区别-使用-typescript-的好处" class="sidebar-link">Ts 和 JS 的区别 使用 typescript 的好处</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数" class="sidebar-link">react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/jiabinxu-blog/React/#react-中的闭包陷阱-closure-trap" class="sidebar-link">React 中的闭包陷阱（Closure Trap）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_1-什么是闭包陷阱" class="sidebar-link">1. 什么是闭包陷阱？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_2-经典陷阱案例-setinterval-计数器" class="sidebar-link">2. 经典陷阱案例：setInterval 计数器</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_3-如何避免闭包陷阱" class="sidebar-link">3. 如何避免闭包陷阱？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_4-总结" class="sidebar-link">4. 总结</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/React/#_5-参考" class="sidebar-link">5. 参考</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-基础部分"><a href="#react-基础部分" class="header-anchor">#</a> React 基础部分</h1> <h2 id="react-的特征"><a href="#react-的特征" class="header-anchor">#</a> react 的特征</h2> <p>react 概念：用于构建用户界面的 JavaScript 库，提供了 UI 层面的解决方案</p> <p>react 有几个特征：虚拟 dom 树，jsx 语法，组件化，单向数据流</p> <ul><li>jsx：语法
<ul><li>只能有一个根节点；但是可以相互嵌套</li> <li>换行或者多标签最好加括号,防止 js 自动分号不往后执行；</li></ul></li> <li>虚拟 dom：
<ul><li>虚拟 DOM 是在 DOM 的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟 DOM，最后再批量同步到 DOM 中。</li> <li>在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而仅仅是 JavaScript 对象，称之为虚拟 DOM。</li></ul></li> <li>组件化：
<ul><li>每一个 React 文件都是一个组件，含视图、逻辑操作、数据</li> <li>组件可以被嵌套到其他组件之中</li> <li>注意组件声明需要首字母大写，如<code>&lt;TodoList /&gt;</code></li></ul></li> <li>单向数据流
<ul><li>子组件对于父组件传递过来的数据是【只读】的</li> <li>子组件不可直接修改父组件中的数据，只能通过调用父组件传递过来的方法，来间接修改父组件的数据，形成了单向清晰的数据流</li></ul></li> <li>声明式编程
<ul><li>声明式编程表明想要实现什么目的，应该做什么，但是不指定具体怎么做。</li> <li>声明式点一杯酒，只要告诉服务员：我要一杯酒即可；</li></ul></li></ul> <p>react 的优势：</p> <ul><li>高效灵活</li> <li>声明式的设计，简单使用</li> <li>组件式开发，提高代码复用率</li> <li>单向响应的数据流会比双向绑定的更安全，速度更快</li></ul> <p>react 有函数组件和类组件：类组件有 this 指向，状态和生命周期，函数组件没有，只有 hooks，Hooks 是 16.8 版本才新增的，给函数组件用的，让函数组件拥有类组件的功能</p> <h2 id="jsx-语法"><a href="#jsx-语法" class="header-anchor">#</a> jsx 语法</h2> <p>JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套。可以理解为在 JS 中编写与 XML 类似的语言,一种定义带属性树结构（DOM 结构）的语法
可以通过各种编译器将这些标记编译成标准的 JS 语言。
可以定义包含属性的树状结构的语法，类似 HTML 标签那样的使用，而且更便于代码的阅读。</p> <p>使用 JSX 语法后，你必须要引入 babel 的 JSX 解析器，把 JSX 转化成 JS 语法，这个工作会由 babel 自动完成。同时引入 babel 后，你就可以使用新的 es6 语法，babel 会帮你把 es6 语法转化成 es5 语法，兼容更多的浏览器。</p> <h2 id="函数组件和-class-组件区别"><a href="#函数组件和-class-组件区别" class="header-anchor">#</a> 函数组件和 class 组件区别</h2> <p>函数组件纯函数，输入 props，输出 jsx
函数组件没有实例，没有生命周期，没有 state
函数组件不能扩展其他方法
class 创建的组件,有自己的私有数据(this.state)和生命周期</p> <h2 id="mvc-和-mvvm-的区别"><a href="#mvc-和-mvvm-的区别" class="header-anchor">#</a> MVC 和 MVVM 的区别</h2> <ul><li>MVC 和 MVVM 都是常见的软件架构思想</li> <li>MVC
<ul><li>model: 数据层</li> <li>view: 视图层</li> <li>controller: 控制层</li></ul></li> <li>MVC 的通信方式： view -&gt; controller -&gt; model -&gt; view</li> <li>MVVM
<ul><li>model: 数据层</li> <li>view: 视图层</li> <li>viewModel: 视图模型层</li></ul></li> <li>MVVM 的通信方式： view &lt;-&gt; viewmodel -&gt;&lt;- model</li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <ul><li><p><strong>初始化阶段</strong>
constructor 是一个特殊的函数，当这个类被实例化的时候，自动执行，最先执行，只执行一次
初始化 props 和 state</p></li> <li><p><strong>挂载阶段</strong>
UNSAFE_ 前面有这个的就是被废弃了 带 Will 的一般都被废弃了 16.3 版本
<em>UNSAFE_componentWillMount()</em> <em>render()</em> - return 标签渲染页面
<em>componentDidMount()</em>
数据请求 这里面基本上什么都可以写了
只能在 componentDidMount 里面请求数据 由于 fiber 算法的存在 在别的生命周期里每个片都会请求一次数据多次请求</p></li> <li><p><strong>数据更新阶段</strong></p> <ul><li><em>shouldComponentUpdate()</em>
作用：使用 shouldComponentUpdate 就是为了减少 render 不必要的渲染
一定要返回一个布尔值
里面手动判断页面是否需要渲染
shouldComponentUpdate 提供了两个参数 nextProps 和 nextState，表示下一次 props 和一次 state 的值，当函数返回 false 时候，render()方法不执行，组件也就不会渲染，返回 true 时，组件照常重渲染
当传递的是一个复杂对象时由于地址不相同所以就没用了
解决：</li></ul> <ol><li>使用 setState 改变数据之前，先采用 es6 中 assgin 进行拷贝，但是 assgin 只深拷贝的数据的第一层，所以说不是最完美的解决办法。</li> <li>使用 JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为 undefined 和函数时就会错。</li></ol> <ul><li><p>使用 immutable.js 进行项目的搭建。immutable 中讲究数据的不可变性，每次对数据进行操作前，都会自动的对数据进行深拷贝，项目中数据采用 immutable 的方式，可以轻松解决问题，但是又多了一套 API 去学习
immutable.js
Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享</p></li> <li><p><em>UNSAFE_componentWillUpdate() {}</em></p></li> <li><p><em>componentWillReceiveProps</em></p></li> <li><p><em>componentWillUpdate()</em></p></li> <li><p><em>render()</em></p></li> <li><p><em>componentDidUpdate()</em></p></li></ul></li> <li><p><strong>销毁阶段</strong> <em>componentWillUnmount</em>
清除定时器，断开 websocket，取消事件监听，卸载第三方插件</p></li></ul> <h2 id="react-组件通信方法"><a href="#react-组件通信方法" class="header-anchor">#</a> React 组件通信方法</h2> <p>在 React 中，组件是独立且可复用的。为了构建复杂的应用，组件之间需要有效地交换数据。以下是几种核心的组件通信方法。</p> <h3 id="_1-父组件向子组件通信-props"><a href="#_1-父组件向子组件通信-props" class="header-anchor">#</a> 1. 父组件向子组件通信 (Props)</h3> <p>这是最常见和最直接的通信方式。</p> <ul><li><p><strong>核心思想</strong>: 父组件通过 <strong>props</strong> 属性将数据单向传递给子组件。</p></li> <li><p><strong>实现</strong>:</p> <ol><li><strong>父组件</strong>: 在调用子组件时，像传递 HTML 属性一样，将数据绑定到子组件的 props 上。</li> <li><strong>子组件</strong>: 通过 <code>props</code> 对象接收数据。在函数组件中，<code>props</code> 是函数的第一个参数；在类组件中，通过 <code>this.props</code> 访问。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 父组件: ParentComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">&quot;./ChildComponent&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dataToSend <span class="token operator">=</span> <span class="token string">&quot;Hello from Parent!&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildComponent</span></span> <span class="token attr-name">message</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>dataToSend<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件: ChildComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello from Parent!&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_2-子组件向父组件通信-回调函数"><a href="#_2-子组件向父组件通信-回调函数" class="header-anchor">#</a> 2. 子组件向父组件通信 (回调函数)</h3> <p>子组件不能直接修改父组件的状态，因此需要借助回调函数来间接通信。</p> <ul><li><p><strong>核心思想</strong>: 父组件将一个<strong>函数作为 props</strong> 传递给子组件，子组件在需要时调用这个函数，从而将数据作为函数参数传递回父组件。</p></li> <li><p><strong>实现</strong>:</p> <ol><li><strong>父组件</strong>: 定义一个用于更新状态的函数，并将其传递给子组件。</li> <li><strong>子组件</strong>: 通过 props 调用该函数，并将需要传递的数据作为参数传入。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 父组件: ParentComponent.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">&quot;./ChildComponent&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>messageFromChild<span class="token punctuation">,</span> setMessageFromChild<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleChildData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setMessageFromChild</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Message from child: </span><span class="token punctuation">{</span>messageFromChild<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildComponent</span></span> <span class="token attr-name">onSendData</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChildData<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件: ChildComponent.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    props<span class="token punctuation">.</span><span class="token function">onSendData</span><span class="token punctuation">(</span><span class="token string">&quot;Hi, I'm the child!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Send Data to Parent</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_3-跨级组件通信-context-api"><a href="#_3-跨级组件通信-context-api" class="header-anchor">#</a> 3. 跨级组件通信 (Context API)</h3> <p>当组件层级很深，通过 props 逐层传递数据会变得非常繁琐（即 &quot;props drilling&quot;），此时 Context 提供了一种更优雅的解决方案。</p> <ul><li><p><strong>核心思想</strong>: Context 提供了一个全局的“上下文”，允许父组件向其下任意层级的子组件直接传递数据，而无需手动逐层传递。</p></li> <li><p><strong>核心 API</strong>: <code>React.createContext</code>, <code>Provider</code>, <code>Consumer</code>, <code>useContext</code> Hook。</p></li> <li><p><strong>实现步骤</strong>:</p> <ol><li><strong>创建 Context</strong>: 使用 <code>const MyContext = React.createContext(defaultValue);</code> 创建一个 Context 对象。</li> <li><strong>提供 Context</strong>: 在父组件或组件树的顶层，使用 <code>&lt;MyContext.Provider value={data}&gt;</code> 组件包裹所有需要访问该数据的子组件。<code>value</code> 属性就是要共享的数据。</li> <li><strong>消费 Context</strong>:
<ul><li><strong><code>useContext</code> Hook (推荐)</strong>: 在函数组件中，使用 <code>const value = useContext(MyContext);</code> 直接获取 <code>value</code>。这是最简洁现代的方式。</li> <li><strong><code>Consumer</code> 组件</strong>: 在类组件或旧版函数组件中，使用 <code>&lt;MyContext.Consumer&gt;{value =&gt; /* JSX based on value */}&lt;/MyContext.Consumer&gt;</code>，通过渲染属性（render prop）的方式来获取数据。</li></ul></li></ol></li> <li><p><strong>代码示例 (使用 <code>useContext</code>)</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// theme-context.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> createContext<span class="token punctuation">,</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 创建 Context</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">&quot;light&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// App.js (提供者)</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token string">&quot;dark&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Toolbar</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Toolbar.js (中间组件)</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemedButton</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ThemedButton.js (消费者)</span>
<span class="token keyword">function</span> <span class="token function">ThemedButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 3. 使用 useContext 消费数据</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Current theme is: </span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_4-状态管理库-redux-zustand-等"><a href="#_4-状态管理库-redux-zustand-等" class="header-anchor">#</a> 4. 状态管理库 (Redux / Zustand 等)</h3> <p>对于大型、复杂应用，组件间的通信关系可能错综复杂。此时，使用专门的状态管理库可以提供一个集中式、可预测的状态容器。</p> <ul><li><strong>核心思想</strong>: 将所有共享状态（state）存储在一个全局的 &quot;Store&quot; 中。任何组件都可以从 Store 中读取状态，并可以 &quot;dispatch&quot; 一个 &quot;action&quot; 来请求更新状态。状态的更新逻辑由 &quot;reducer&quot; 函数集中处理。</li> <li><strong>代表库</strong>:
<ul><li><strong>Redux</strong>: 经典的状态管理库，生态成熟，中间件丰富，遵循严格的单向数据流。</li> <li><strong>Zustand</strong>: 一个更轻量、更现代的状态管理方案，API 简单，基于 Hooks，无需大量模板代码。</li></ul></li></ul> <h3 id="_5-本地状态共享-hooks"><a href="#_5-本地状态共享-hooks" class="header-anchor">#</a> 5. 本地状态共享 (Hooks)</h3> <p>React Hooks 提供了一些强大的工具，可以在组件内部或相关组件之间共享逻辑和状态。</p> <h4 id="a-usereducer"><a href="#a-usereducer" class="header-anchor">#</a> a. <code>useReducer</code></h4> <ul><li><strong>核心思想</strong>: <code>useReducer</code> 是 <code>useState</code> 的替代方案。当状态逻辑比较复杂，或者下一个状态依赖于前一个状态时，<code>useReducer</code> 更为适用。它可以看作是单个组件内部的 &quot;小型 Redux&quot;。</li> <li><strong>API</strong>: <code>const [state, dispatch] = useReducer(reducer, initialState);</code> <ul><li><code>reducer</code>: 一个函数 <code>(state, action) =&gt; newState</code>，根据 action 来计算新 state。</li> <li><code>initialState</code>: 初始状态。</li> <li><code>dispatch</code>: 一个函数，用于触发 action，例如 <code>dispatch({ type: 'increment' })</code>。</li></ul></li> <li><strong>注意</strong>: <code>useReducer</code> 本身不处理异步操作（如 API 请求）。通常需要配合 <code>useEffect</code> 来处理副作用，例如在 <code>useEffect</code> 中获取数据，然后调用 <code>dispatch</code> 将数据存入 state。</li></ul> <h4 id="b-状态提升-lifting-state-up"><a href="#b-状态提升-lifting-state-up" class="header-anchor">#</a> b. 状态提升 (Lifting State Up)</h4> <ul><li><strong>核心思想</strong>: 当多个子组件需要共享和操作同一个状态时，应将这个状态提升到它们最近的共同父组件中进行管理。然后，父组件通过 props 将状态和更新状态的函数分发给需要的子组件。</li> <li><strong>本质</strong>: 这并不是一种新的技术，而是 <strong>Props</strong> 和 <strong>回调函数</strong> 模式的结合与实践，是 React 设计的核心原则之一。</li></ul> <h3 id="_6-非嵌套组件通信-发布-订阅模式"><a href="#_6-非嵌套组件通信-发布-订阅模式" class="header-anchor">#</a> 6. 非嵌套组件通信 (发布-订阅模式)</h3> <p>对于两个没有任何层级关系的组件，可以使用全局事件总线（Event Bus）来实现通信。</p> <ul><li><p><strong>核心思想</strong>: 创建一个中央事件管理器。一个组件（发布者）可以发布（<code>emit</code>）一个事件，其他任何组件（订阅者）只要订阅（<code>listen</code> 或 <code>on</code>）了该事件，就能收到通知并执行相应的回调。</p></li> <li><p><strong>实现</strong>:</p> <ol><li>引入一个事件库，如 <code>events</code> 或 <code>pubsub-js</code>。</li> <li>创建一个事件发射器实例。</li> <li>在组件 A 中，使用 <code>emitter.emit('eventName', data)</code> 来发布事件。</li> <li>在组件 B 的 <code>useEffect</code> 中，使用 <code>emitter.on('eventName', callback)</code> 来订阅事件。</li> <li><strong>关键</strong>: 在组件 B 卸载时，必须在 <code>useEffect</code> 的返回函数中调用 <code>emitter.off('eventName', callback)</code> 来取消订阅，以防止内存泄漏。</li></ol></li> <li><p><strong>代码示例</strong>:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// event-bus.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventEmitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;events&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ComponentA.js (发布者)</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> emitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./event-bus&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello from Component A!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Send Global Message</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ComponentB.js (订阅者)</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> emitter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./event-bus&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ComponentB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">handleMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> handleMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 组件卸载时取消订阅</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      emitter<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> handleMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空依赖数组确保只在挂载和卸载时执行</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Received message: </span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <hr> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> <strong>总结</strong></h3> <table><thead><tr><th style="text-align:left;">通信场景</th> <th style="text-align:left;">推荐方法</th> <th style="text-align:left;">核心</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>父 -&gt; 子</strong></td> <td style="text-align:left;"><strong>Props</strong></td> <td style="text-align:left;">最基础、最直接的数据传递。</td></tr> <tr><td style="text-align:left;"><strong>子 -&gt; 父</strong></td> <td style="text-align:left;"><strong>回调函数</strong> (通过 Props 传递)</td> <td style="text-align:left;">子组件调用父组件的函数。</td></tr> <tr><td style="text-align:left;"><strong>兄弟组件</strong></td> <td style="text-align:left;"><strong>状态提升</strong></td> <td style="text-align:left;">将共享状态放到共同的父组件中管理。</td></tr> <tr><td style="text-align:left;"><strong>跨多层级组件</strong></td> <td style="text-align:left;"><strong>Context API</strong> (<code>useContext</code>)</td> <td style="text-align:left;">避免 Props 逐层钻取，实现全局数据共享。</td></tr> <tr><td style="text-align:left;"><strong>复杂应用/全局状态</strong></td> <td style="text-align:left;"><strong>状态管理库</strong> (Redux, Zustand)</td> <td style="text-align:left;">集中式、可预测的全局状态管理方案。</td></tr> <tr><td style="text-align:left;"><strong>任意非嵌套组件</strong></td> <td style="text-align:left;"><strong>发布-订阅模式</strong> (Event Bus)</td> <td style="text-align:left;">解耦组件，通过全局事件中心通信。</td></tr></tbody></table> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <h3 id="_1-事件命名和绑定"><a href="#_1-事件命名和绑定" class="header-anchor">#</a> 1. 事件命名和绑定</h3> <ul><li>事件名采用驼峰命名法（如 <code>onClick</code>、<code>onChange</code>）。</li> <li>事件处理函数通常传递为函数引用，而不是字符串。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 正确</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click Me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 错误</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click Me</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_2-阻止默认行为和事件冒泡"><a href="#_2-阻止默认行为和事件冒泡" class="header-anchor">#</a> 2. 阻止默认行为和事件冒泡</h3> <p>React 事件对象是合成事件（SyntheticEvent），提供与原生 DOM 事件一致的接口。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleSubmit</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止默认提交</span>
  e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止事件冒泡</span>
<span class="token punctuation">}</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">onSubmit</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleSubmit<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_3-向事件处理函数传递参数"><a href="#_3-向事件处理函数传递参数" class="header-anchor">#</a> 3. 向事件处理函数传递参数</h3> <p>可以使用箭头函数或 bind 方法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handleClick</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Delete</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Delete</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_4-事件对象"><a href="#_4-事件对象" class="header-anchor">#</a> 4. 事件对象</h3> <p>事件处理函数的第一个参数为合成事件对象（SyntheticEvent），具有和原生事件类似的属性。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_5-this-指向"><a href="#_5-this-指向" class="header-anchor">#</a> 5. this 指向</h3> <ul><li>使用 class 组件时，事件处理函数需要绑定 this，或使用箭头函数自动绑定。</li> <li>函数组件中无需关心 this。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// class 组件</span>
<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="_6-事件池机制"><a href="#_6-事件池机制" class="header-anchor">#</a> 6. 事件池机制</h3> <ul><li>React 17 及以下，合成事件对象会被回收（事件池），异步访问事件属性时需调用 <code>event.persist()</code>。</li> <li>React 17 以上已取消事件池机制，但为兼容旧代码，可继续调用 <code>event.persist()</code>。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 防止事件对象被回收</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="_7-常用事件类型"><a href="#_7-常用事件类型" class="header-anchor">#</a> 7. 常用事件类型</h3> <table><thead><tr><th>事件类型</th> <th>说明</th></tr></thead> <tbody><tr><td>onClick</td> <td>点击事件</td></tr> <tr><td>onChange</td> <td>输入、选择改变</td></tr> <tr><td>onSubmit</td> <td>表单提交</td></tr> <tr><td>onMouseEnter</td> <td>鼠标进入</td></tr> <tr><td>onMouseLeave</td> <td>鼠标离开</td></tr> <tr><td>onKeyDown</td> <td>键盘按下</td></tr> <tr><td>onFocus</td> <td>获得焦点</td></tr> <tr><td>onBlur</td> <td>失去焦点</td></tr></tbody></table> <hr> <h3 id="_8-事件冒泡与捕获"><a href="#_8-事件冒泡与捕获" class="header-anchor">#</a> 8. 事件冒泡与捕获</h3> <ul><li>React 默认事件是冒泡阶段。</li> <li>支持捕获事件，写法如 <code>onClickCapture</code>。</li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClickCapture</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;捕获阶段&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><hr> <h3 id="_9-事件委托"><a href="#_9-事件委托" class="header-anchor">#</a> 9. 事件委托</h3> <ul><li>React 事件委托到根节点（如 <code>document</code>），提升性能。</li> <li>组件卸载时会自动移除监听，无需手动清理。</li></ul> <hr> <h3 id="_10-组合使用"><a href="#_10-组合使用" class="header-anchor">#</a> 10. 组合使用</h3> <p>可结合 state、props、Context 等配合事件实现复杂交互。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <ul><li>使用合成事件，跨平台兼容。</li> <li>事件名写法和原生不同。</li> <li>事件处理参数、this 绑定需注意。</li> <li>事件池影响异步操作。</li> <li>支持事件捕获与冒泡、事件委托无需手动管理。</li></ul> <h2 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="header-anchor">#</a> 受控组件与非受控组件</h2> <p>受控组件与非受控组件 都是基于表单组件的
受控组件: 表单由我们自己来控制的组件
就是包含 value 属性和 onChange 事件的组件 onChange 里面写 setState 改变当前点击的 value 的值赋值给 input 绑定的 value
非受控组件就是，表单交给 react 去控制
只有文件上传一定要使用非受控组件，其他时候都尽量使用受控组件</p> <ol><li>引入 createRef</li> <li>定义 ipt = createRef();</li> <li>表单上加 ref 属性</li></ol> <div class="language-JSX extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ipt<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="4"><li>获取时用 this.ipt.current.value</li></ol> <h2 id="hoc-高阶组件"><a href="#hoc-高阶组件" class="header-anchor">#</a> hoc 高阶组件</h2> <p>高阶组件是一个函数，这个函数要传入一个组件，并且返回一个新组件
高阶组件的取名一般用 with 开头，后面加功能
作用增强组件的功能,并且可以做复用
传入一个组件 return 一个功能更多的组件</p> <p>高阶组件-加版权号</p> <div class="language-JSX extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">withCopy</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Component <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
                </span><span class="token punctuation">{</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">_ {...this.props}是将接收到的 props 全部传递给子组件 _</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">}</span><span class="token plain-text">
                </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Comp</span></span> <span class="token attr-name">num</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">20</span><span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Comp</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
                </span><span class="token punctuation">{</span><span class="token operator">/</span>_ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">&amp;copy;版权所有 贾滨旭 xxx </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> _<span class="token operator">/</span><span class="token punctuation">}</span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="diff-算法-react-fiber-虚拟-dom"><a href="#diff-算法-react-fiber-虚拟-dom" class="header-anchor">#</a> diff 算法 React Fiber 虚拟 dom</h2> <ul><li>diff 算法
用 js 对象模拟真实的 DOM 结构 当页面更新的时候比对虚拟 dom 和真实 dom 区别 然后在进行更新 只需要更改部分不需要将页面全部重新渲染
但是标准的的 Diff 算法复杂度需要 O(n^3)
虚拟 dom：将真实 dom 转换成变量存到内存中
diff 算法是一种通过同层的树节点进行比较的高效算法
特点：</li></ul> <ol><li>同级比较</li> <li>key 值比较</li> <li>类的比较
拥有相同类的两个组件 生成相似的树形结构，
拥有不同类的两个组件 生成不同的树形结构。
React 里结合 Web 界面的特点做出了两个简单的假设来降低算法的复杂度
<ol><li>两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构；</li> <li>对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分</li></ol></li></ol> <ul><li>React Fiber
渲染的时候将一个大的进程拆分成小的片 在每个片结束后查看一下其他的进程 然后运行小一点的进程 再去执行下一个片 例子星巴克
虚拟 DOM
虚拟 dom 相当于在 js 和 真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把所记录的差异渲染再真实 dom 上，从而提高性能。</li></ul> <h2 id="时间复杂度-空间复杂度"><a href="#时间复杂度-空间复杂度" class="header-anchor">#</a> 时间复杂度 空间复杂度</h2> <p>时间复杂度：是指执⾏当前算法所消耗的时间；
空间复杂度：是指执⾏当前算法需要占⽤多少内存空间
常⻅的量级有：常数阶 O(1)，对数阶 O(logN)，线性阶 O(n)，线性对数阶 O(nlogN)，平⽅阶 O(n²)，⽴⽅阶 O(n³)，K
次⽅阶 O(n^k)，指数阶</p> <h2 id="protal-将组件放到页面中任意你想放的位置"><a href="#protal-将组件放到页面中任意你想放的位置" class="header-anchor">#</a> protal 将组件放到页面中任意你想放的位置</h2> <p>有时需要将元素渲染到 DOM 中的不同位置上去，这是就用到的 portal 的方法 protal 可以将组件放到页面中任意你想放的位置
引入
import { createPortal } from &quot;react-dom&quot;;
第一个参数 child 是可渲染的 react 子项，比如元素，字符串或者片段等。第二个参数 container 是一个 DOM 元素。
例子：对话框 模态框 轻提示
模态框例子</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// App.jsx</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Modal <span class="token keyword">from</span> <span class="token string">&quot;./Modal&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// import { createPortal } from &quot;react-dom&quot;;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">open</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">ok</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// portal的事件冒泡依旧会冒到原先的父元素上面</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>fn<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">对话框</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>open<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Open Modal</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token comment">/* {this.state.show &amp;&amp; &lt;Modal /&gt;} */</span><span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token comment">/* {createPortal(&lt;Modal /&gt;, document.querySelector(&quot;body&quot;))} */</span><span class="token punctuation">}</span><span class="token plain-text">

        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Modal</span></span>
          <span class="token attr-name">visible</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>show<span class="token punctuation">}</span></span>
          <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Basic Modal<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">okText</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>确定<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">onOk</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ok<span class="token punctuation">}</span></span>
        <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> withPortal <span class="token keyword">from</span> <span class="token string">&quot;./withPortal&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;./style.css&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bool<span class="token punctuation">,</span> string <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;prop-types&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Modal</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// console.log(this.props);</span>
    <span class="token comment">// return (</span>
    <span class="token comment">// &lt;div className=&quot;modal&quot;&gt;</span>
    <span class="token comment">//   &lt;div className=&quot;center&quot;&gt;</span>
    <span class="token comment">//     &lt;h4&gt;Basic Modal&lt;/h4&gt;</span>
    <span class="token comment">//   &lt;/div&gt;</span>
    <span class="token comment">// &lt;/div&gt;;</span>
    <span class="token comment">// );</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>visible <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modal<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>onOk<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>okText<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Modal<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">visible</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;标题&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Modal<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">visible</span><span class="token operator">:</span> bool<span class="token punctuation">,</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withPortal</span><span class="token punctuation">(</span>Modal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createPortal <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 添加portal的高阶组件，很多的对话框都需要加到body上，所以将createPortal提出来</span>
<span class="token keyword">const</span> <span class="token function-variable function">withPortal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Component <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">createPortal</span><span class="token punctuation">(</span>
        <span class="token comment">// 将接收到的所有的props，传递给子组件</span>
        <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
        document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> withPortal<span class="token punctuation">;</span>
</code></pre></div><ul><li><p>createPortal 的优点</p> <p>1.使用 Portal 后，界面定制比较灵活，Portlet 是一个容器，通过 console 可以更改 Portlet 的位置，尺寸，级别，外观等，Portlet 内部显示的内容也会随着改变。
2.Portal 有内部安全机制，可以在 Portal 上面定制角色、组及用户，可以指定哪些资源可以被哪些用户（组、角色）访问，对于那些不符合安全条件的用户登录，则看不到相关的资源。
3.Portal 允许自己利用已经开发好的资源（portlet 或者网页）按照自己的喜好定制自己的首页或者网站。提升了网站的可维护性。
4.Portal 软件里面都内置了很多其他方面的组件，比如全文检索，内容管理等。
5.Portal 支持多渠道访问，比如：同一个 Portal 可以不用修改就可以支持手机、PDA 访问。</p></li> <li><p>createPortal 的缺点</p> <p>1.Portal 是标准的 Web 应用，不同厂商的实现不同，有学习曲线和时间成本。
2.Portal 的性能也是一个需要考虑的因素，如果一个页面上 Portlet 数量比较多，则显示速度会比普通的页面慢很多，如果启用了 Portlet 的页面级 cache，则速度会快很多，但使用 Portal 后，性能肯定是个问题。
3.Portal 的开发要比普通的开发步骤多，周期长，另外还要考虑一些引入了 Portal 后带来的技术细节，比如多个 Portlet 内容来自于多个独立的系统，如果使用 iFrame 带来的多 Session 的问题等等。
4.Portal 需要自己做很多工作才能完成的，比如 SSO（Single Sign-On 单点登录）。（后面可以不说）
5.Portal 有时候满足不了复杂项目的需要，需要自己二次开发，需要使用更专业的组件或者软件替代，比如内容管理，安全认证等领域。 6.使用 Portal 后，对于架构设计及开发过程都会产生很大影响，比如使用特定厂商的 Portal 产品后，需要使用特特定的 IDE 才能开发、部署，自动化的测试脚本的作用就会被削弱。</p></li></ul> <h2 id="react-路由"><a href="#react-路由" class="header-anchor">#</a> React 路由</h2> <h3 id="react5"><a href="#react5" class="header-anchor">#</a> React5</h3> <p>五版本路由总结 yarn add react-router-dom@5 ( 一般都用 5 版本 6 版本为新版本)
解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks</p> <ol><li><p>如果项目要使用路由，那么项目的最外面要加上 BrowserRouter 组件 直接在出口文件给总的最大的组件套一个 BrowserRouter 标签
import { BrowserRouter } from &quot;react-router-dom&quot;;</p></li> <li><p>在组件中想使用路由的话在父组件引入 Link 这个 link 标签就相当于 a 标签做跳转 link 标签有一个 to 属性做跳转 to= &quot;路径&quot;
写法:
import { NavLink, Route, Switch } from &quot;react-router-dom&quot;;</p></li> <li><p>对应的每一个 link 标签应该对应一个 Route 标签 Route 标签有两个属性 path=&quot;路径&quot; componen = {要渲染的组件名}</p></li> <li><p>Route 标签的渲染属性有四个：</p> <ol><li>componen = {要渲染的组件名}</li> <li>render ={
(props) =&gt;{
return &lt; 要渲染的组件名 （如果要传递 props 加 {...props}）/&gt;
}
}</li> <li>children={Mine}</li> <li></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/detail<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Detail</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p><em>区别</em>
路由里面最常见的渲染组件的属性是 component
component 可以渲染类组件和函数组件</p> <div class="language- extra-class"><pre><code>   render属性页可以渲染组件，render属性只能渲染函数组件
   render后面是可以写函数的, 那么就可以去加入逻辑判断

   children属性也可以渲染组件，也只能渲染函数组件
   不管url是否匹配，都会渲染
   如果加了Switch，那么就和render的效果一摸一样

   在Route组件的里面，直接写组件， 可以渲染类组件和函数组件
   这种方式默认是拿不到路由信息的, 除非配合withRouter高阶组件
</code></pre></div></li></ul></li> <li><p>react 的路由是包容性路由 (vue 的路由是排他性路由)
用 Switch 标签套在 Route 标签外面，如果你要匹配多个路由，你得在外面加一个盒子，确保唯一子元素，读取时从上往下读，只要有一个匹配就不往下匹配了</p> <p>exact 表示精准匹配
Switch 表示 分支匹配， 将包容性路由变成排他性路由</p> <p>注意：</p> <ul><li>Vue 是排他性路由，react 默认是包容性路由</li> <li>react 默认是 history 模式</li> <li>exact 表示精准匹配</li> <li>Switch 表示 分支匹配， 将包容性路由变成排他性路由</li> <li>如果要做二级路由的时候，一级路由不能用精准匹配</li> <li>路由信息要全部来自于 props</li></ul></li> <li><p>路由嵌套 - 二级/多级路由
在嵌套的子组件 也就是二级路由里面在写一个路由 link 标签 对应的 route 标签 这个组件的 props 里面就会有路由信息
// ?. 可选链操作符 - 如果有这个属性就打印如果没有就不打印
console.log(this.props.match?.params?.id);</p></li> <li><p>路由重定向
import { Link, Route, Switch, Redirect } from &quot;react-router-dom&quot;;
从 react-router-dom 中解构出 Redirect 在和 Route 标签平级的地方写重定向标签</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span> <span class="token attr-name">from</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>要改变的路径<span class="token punctuation">&quot;</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>要改成什么路径<span class="token punctuation">&quot;</span></span> <span class="token attr-name">exact</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>路由鉴权
基础原理：
把 Route 标签里面的渲染属性换成 render 里面就可以写逻辑判断了 判断 localstorage 里面是否存在 token 如果有就是登陆过 然后 return 一个要渲染成的组件 不过不存在 token 渲染登录页的组件
写法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span>
  <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">render</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mine</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span> <span class="token attr-name">from</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/login<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>封装组件：
原理：自定义一个组件 用这个组件去替换 route 标签 这个组件 return 一个 Route 标签
写法：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 标签部分：</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Auth</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/mine<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mine</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Auth</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token comment">// 组件部分：</span>
<span class="token keyword">const</span> <span class="token function-variable function">Auth</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Route
      path<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span>
      render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> props<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span>
              <span class="token attr-name">from</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>path<span class="token punctuation">}</span></span>
              <span class="token attr-name">to</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/login?from=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">.</span>path<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span></span>
            <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Redirect</span></span><span class="token punctuation">&gt;</span></span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token operator">&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>404 页面
404 页面一定要写在 Route 的最下面， Switch 不能少
在所有 route 的最下面写 404 页面的 route 标签</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Not<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>link 标签高亮
// NavLink 具有 Link 所有的功能，并且会多一个高亮的效果
引入的时候引入 NavLink，去替换 Link
NavLink 标签会多一个类名 active 为这个类名添加样式即可
添加样式尾元素写法：
.active::before {
content: &quot;&gt;&quot;;
}</p></li> <li><p>让函数组件有类组件的功能 Hocks
引入 useHistory，useParams，useLocation
import {
Link,
Route,
Switch,
useHistory,
useParams,
useLocation,
} from &quot;react-router-dom&quot;;
在组件里直接打印 Hocks 调用的结构就有了
hooks 是 react16.8 版本新增的， 只能给函数组件使用
帮助函数组件拥有类组件的功能
所有的 hooks 都是函数
hooks 的调用必须在函数组件的顶层</p></li> <li><p>路由模块化
路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的 URL 去切换组件；在 web 应用前端开发中，路由系统是最核心的部分，当页面的 URL 发生改变时，页面的显示结果可以根据 URL 的变化而变化，但是页面不会刷新。</p></li></ol> <ul><li>BrowserRouter 与 HashRouter 的区别：
（1）底层原理不一样：BrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下版本；HashRouter 使用的是 URL 的哈希值；
（2）path 表现形式不一样：BrowserRouter 的路径中没有#,例如：localhost:3000/demo/test；HashRouter 的路径包含#,例如：localhost:3000/#/demo/test；
（3）刷新后对路由 state 参数的影响：BrowserRouter 没有任何影响，因为 state 保存在 history 对象中；HashRouter 刷新后会导致路由 state 参数的丢失；</li></ul> <h3 id="react-router6"><a href="#react-router6" class="header-anchor">#</a> React-Router6</h3> <p>六版本路由和五版本区别总结 yarn add react-router-dom
解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks</p> <ol><li><p>Switch 组件没有了 改成了 Routes， 并且 Routes 是不能少的， 会变成排他性路由 Routes 里面只能放 Route</p></li> <li><p>渲染组件只剩 element 一种了，里面写的是实例化的结果或者元素
不需要加 exact，也是精准匹配
用 element 渲染出来的组件全都是没有路由信息的
想要有路由信息就要用 hocks
</p></li> <li><p>路由嵌套 需要引入 Outlet 组件 相当于 props.children 在 Routes 里面直接做嵌套</p></li> <li><p>link 标签里面可以传 pathname search hash state(看不见的数据传递 不显示在地址栏上面)</p></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span></span>
  <span class="token attr-name">to</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token literal-property property">pathname</span><span class="token operator">:</span> <span class="token string">&quot;/about&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">search</span><span class="token operator">:</span> <span class="token string">&quot;?a=3&amp;b=4&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token string">&quot;#abc&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
      <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="token punctuation">&gt;</span></span><span class="token plain-text">
  about
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Link</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="5"><li><p>编程式导航
在组件里写一个单击事件 引入 useNavigate
const navigate = useNavigate();
const jump = () =&gt; {
// 直接写路径相当于 push
// navigate(&quot;/detail/888&quot;);</p> <p>// 相当于 replace
// navigate(&quot;/home&quot;, { replace: true });</p> <p>// 直接写数字相当于 go 方法
navigate(-2);
};</p></li> <li><p>重定向
Navigate 组件用于做重定向</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">element</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Navigate</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/home<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Navigate</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <h3 id="hash-和-history"><a href="#hash-和-history" class="header-anchor">#</a> hash 和 history</h3> <ul><li>hash
是指 url 中#后面的部分，虽然出现在 URL 中，但不会被包括在 HTTP 请求中，这部分在服务器中会自动被忽略，但是在浏览器中可以通过 location.hash 来获取。主要是用到了，window.hashchange 事件，这个事件可以监听 url 中的 hash 值变化来进行 dom 操作。
onhashchange 事件触发的条件：
改变 url 地址，在最后面增加或者改变 hash 值
改变 location.herf 或者 location.hash
点击带有锚点的链接
浏览器前进后退可能会导致 hash 的变化，就是两个网页地址的 hash 值不同
实现思路：当浏览器地址栏 URl 的 hash 值发生改变时，就会触发 onhashchange 事件，这是需要通过 window.location.hash 可以拿到当前浏览器的 url 的 hash 值，执行不同的回调函数，加载不同的组件。</li> <li>history
利用 window.history 的 api：
主要使用到了 history.pushState()和 history.replaceState()这两个接口。二者均接收三个参数，分别是 state，title，url，
state 用来存放将要插入 history 实体的相关信息，是一个 json 格式的参数； title 是传入 history 实体的标题，firefox 现在会自动忽略掉这个属性；
url 用来传递新的 history 实体的相对路径，如果其值为 null 则表示当前要插入的 history 实体与前一个实体一致，没有改变。
两者唯一的区别在于 replaceState()方法会将最新一条的 history 实体覆盖掉，而不是直接添加。
这两个方法都不会主动触发浏览器页面的刷新，只是 history 对象包括地址栏的内容会发生改变，当触发前进后退等 history 事件时才会进行相应的响应</li> <li>区别：
Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL
History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li></ul> <h3 id="路由鉴权"><a href="#路由鉴权" class="header-anchor">#</a> 路由鉴权</h3> <p>可以在 route 中的 render 上直接做判断
定义一个 auth 的函数组件，传入一个 props，里面 path 就是 props.path
里面 render 的时候做判断 一般都是判断登没登陆过 判断 localStorage 是否有 token，如果有的话就渲染组件，如果没有的话就重定向到登录页面。</p> <h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <ul><li>从 react 中解构出 lazy 和 Suspense</li> <li>lazy 函数传入回调函数，回调函数用 import
例：const Child = lazy(() =&gt; import(&quot;./Child&quot;));</li> <li>lazy 方法要和 Suspense 组件一起使用</li> <li>Suspense 组件需要有一个 fallback 属性，里面写组件，当这个要引得组件还没有引来得时候渲染</li> <li>suspense 要放在要做懒加载的组件外面
例：&lt;Suspense fallback={<div>loading...</div>}&gt;
{this.state.isShow &amp;&amp; <Child></Child>}
</li></ul> <h3 id="自定义标签代替-a-标签跳转"><a href="#自定义标签代替-a-标签跳转" class="header-anchor">#</a> 自定义标签代替 a 标签跳转</h3> <ul><li>自定义一个组件，这个组件要去做编程式导航</li> <li>在组件中添加 list，渲染出来</li> <li>将要做跳转的标签加上点击事件</li> <li>如果要做跳转，首先要拿到路由信息的 history 对象</li> <li>编程式导航 go/push/replace/goBack</li></ul> <h2 id="fetch-和-axios-的区别"><a href="#fetch-和-axios-的区别" class="header-anchor">#</a> fetch 和 axios 的区别</h2> <ol><li>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：</li></ol> <ul><li>自动转换 JSON 数据 fetch 不可以 这也就是为什么 axios 只需要一步.then</li> <li>axios 是一个基于 Promise 封装的一个 ajax 库 可以避免回调地狱 可以使用 async + await 实现同步代码</li> <li>axios 可以做拦截 请求数据之前可以做一些业务逻辑的判断 比如说判断有没有 token 如果没有 token 就取消这次请求 请求后也可以进行拦截</li> <li>从浏览器中创建 XMLHttpRequest</li> <li>客户端支持防止 CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>超时取消请求</li></ul> <ol start="2"><li>fetch 优势：
语法简洁，更加语义化
基于标准 Promise 实现，支持 async/await
同构方便，使用 isomorphic-fetch
更加底层，提供的 API 丰富（request, response）
脱离了 XHR，是 ES 规范里新的实现方式 3. fetch 存在问题</li></ol> <ul><li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ul> <h2 id="redux-具体流程-saga"><a href="#redux-具体流程-saga" class="header-anchor">#</a> redux 具体流程 saga</h2> <ol><li><p>创建一个仓库文件夹</p></li> <li><p>从 redux 里面解构出来 createStore 定义一个 store 常量等于 createStore(reducer) 把仓库暴露出去</p></li> <li><p>在 createStore 里面要写一个参数 reducer 一般 reducer 都是建一个单独的 reducer 文件</p></li> <li><p>reducer 里面定义一个 reducer 函数并暴露出去 定义一个 defaultstate 作为 reducer 第一个参数的默认值 reducer = (state = defaultstate , action)</p></li> <li><p>reducer reducer 为纯函数 （一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。）
有两个参数 第一个参数是 state = defaultstate 是状态里面存放数据 第二个参数是 action 用于接收组件传递的参数
写法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> defaultState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// type 的不同表示我们要做不同的事情</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&quot;increment&quot;</span><span class="token operator">:</span>
      <span class="token comment">// 返回出来的对象会去覆盖以前的 state 对象</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将没有进行修改的数据全部保留下来</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&quot;decrement&quot;</span><span class="token operator">:</span>
      <span class="token comment">// 返回出来的对象会去覆盖以前的 state 对象</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将没有进行修改的数据全部保留下来</span>
        <span class="token operator">...</span>state<span class="token punctuation">,</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> action<span class="token punctuation">.</span>num<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>在入口文件引入 react-redux 并解构出 Provide 引入 store 然后 用<code>&lt;Provide store = {store}&gt;&lt;/Provide&gt;</code>将引入的标签包起来 然后再在组件中从 react-redux 中解构出 { connect } 组件因为他的执行结果是一个高阶组件所以暴露的时候用 connect(mapStateToProps, mapDispatchToProps)(App)</p></li> <li><p>connect 中有两个参数 mapStateToProps 和 mapDispatchToProps 意思是把仓库中的数据映射到 props 里面 用 this.props 可以调用
也可以不用 connect 可以使用 react-redux 提供的两个 hocks useSelector 和 useDispatch 这两个分别是获取仓库数据和调用仓库的方法的
<strong>怎么使用：</strong>
useSelector：
定义一个变量去接收 useSelector 的参数是一个函数 这个函数的参数就是仓库中的 state 就可以获取数据了
const list = useSelector((state) =&gt; state.list);
useDispatch：
定义一个 dispatch 实例 dispatch 调用的时候可以传一个对象作为参数 这个对象就是 reducer 的第二个参数 action 就可以传 type 和数据给仓库</p></li> <li><p>mapStateToProps
写法 ：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将仓库的 count，变成组件的 props 的 count</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>mapDispatchToProps dispatch 方法就相当于调用 reducer 函数
写法 ：</p></li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">mapDispatchToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> num <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="10"><li>异步请求数据
store.js
在 store 中从 redux 中引入 applyMiddleware
然后下载 thunk 异步库 import thunk from &quot;redux-thunk&quot;;
创建仓库 createStore(reducer, applyMiddleware(thunk))
建一个 actionCreators.js 文件 在这个文件中写一个函数去 return 一个对象 然后再组件中在引入这个函数去调用他 这样虽然是一样的但是在这个 actionCreators.js 中写的这个函数 return 这个对象之前就可以去请求数据 但是请求到之后还是要写一个同步方法去改变仓库数据 写的这个函数就是个异步函数用这个异步方法去调同步方法改变仓库数据
写法：</li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token function-variable function">initAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;init&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">list</span><span class="token operator">:</span> list <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">initAsyncAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 请求数据</span>
  <span class="token comment">// Actions must be plain objects</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span>
      <span class="token string">&quot;https://www.fastmock.site/mock/15579798b9f988acd4d04ff978a2bd7c/api/list&quot;</span>
    <span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// return { type: &quot;init&quot;, list: res.list };</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">initAction</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="11"><li>异步请求数据 -saga 异步库
思路：
首先在 store 的 index 中改变写法 引 saga 异步库
里面引入 sagas 文件
组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了 在 saga 里面进行一些操作 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer 然后 reducer 去改变里面的数据 最后在组件中再去调用一下仓库中的数据就有请求过后的数据了
组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action
<ol><li>组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了
useEffect(() =&gt; {
dispatch({
type: &quot;init2&quot;,
});
// eslint-disable-next-line
}, []);
2.--_ 在 saga 里面请求数据 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer
import { takeEvery, put, call } from &quot;redux-saga/effects&quot;;
import axios from &quot;axios&quot;;
function_ loadFn() {
// 先请求数据
// call 用来请求数据
const res = yield call(() =&gt; {
return axios
.get(&quot;http://www.pudge.wang:3080/api/rated/list&quot;)
.then((res) =&gt; {
return res.data;
});
});
yield put({
type: &quot;init&quot;,
list: res.result,
});
}
function* mySaga() {
yield takeEvery(&quot;init2&quot;, loadFn);
}
export default mySaga;</li> <li>reducer 去改变里面的数据
const reducer = (state = defaultstate, action) =&gt; {
switch (action.type) {
case &quot;init&quot;:
// console.log(action);
// return {
// ...state,
// list: action.list,
// };
return state.set(&quot;list&quot;, action.list); //immutable 写法
default:
return state;
}
】
最后在组件中再去调用一下仓库中的数据就有请求过后的数据了
这里注意 组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action
import { useSelector, useDispatch } from &quot;react-redux&quot;;
const list = useSelector((state) =&gt; state.get(&quot;list&quot;));</li></ol></li> <li>配置 saga sagas 文件里面请求数据 请求到数据之后调用 put 方法相当于
下载 saga
<ol><li>yarn add redux-saga</li> <li>在 store 中从 redux 中引入 applyMiddleware</li> <li>创建一个 sagas.js 文件 引入到 store 的 index 中
import mySaga from &quot;./sagas&quot;;</li> <li>从 react-saga 中引入 createSagaMiddleware
import createSagaMiddleware from &quot;redux-saga&quot;;</li> <li>createSagaMiddleware 是个函数 将他的执行结果定义为一个变量
const sagaMiddleware = createSagaMiddleware();</li> <li>创建仓库 createStore(reducer, applyMiddleware(sagaMiddleware))</li> <li>最后在暴露之前执行 sagaMiddleware.run(mySaga);
<strong>sagas 文件中写什么</strong>
从 redux-saga/effects 中解构 takeEvery 和 put
import { takeEvery, put } from &quot;redux-saga/effects&quot;;
takeEvery:用来监听的 只要在组件里面去调用 dispatch，会优先进入 mySaga 函数
第一个参数是函数名，对应的是组件的 dispatch 的 type
第二个参数是回调函数
put：用来调用 reducer 的函数
call：用来做数据请求的
里面写一个生成器函数 调用 takeEvery 函数 里面有两个参数 第一个参数是组件调用 dispatch 时候的名字 第二个参数是一个函数可以接收一个参数相当于 reducer 中的 action 第二个参数对应的函数中写 put 函数 put 就相当于调用 dispatch
执行的时候会先到 sagas 这个文件里面来执行过之后再到 reducer
import { takeEvery, put ,call } from &quot;redux-saga/effects&quot;;
function* addFn(action) {
yield put({
type: &quot;add&quot;,
payload: action.payload,
});
}
function* mySaga() {
yield takeEvery(&quot;add2&quot;, addFn);
}
export default mySaga;</li></ol></li> <li>actionTypes 写法就是用一个文件里面定义一个常量大写并暴露出去 替换 reducer 里面的 case 的条件</li> <li>模块化</li></ol> <h3 id="thunk-和-saga-的区别"><a href="#thunk-和-saga-的区别" class="header-anchor">#</a> thunk 和 saga 的区别</h3> <p>redux-thunk 和 redux-saga 处理异步任务的时机不一样。对于 redux-saga，相对于在 redux 的 action 基础上，重新开辟了一个 async action 的分支，单独处理异步任务
saga 自己有一套监听机制 saga 会比 thunk 难一点</p> <h2 id="redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件"><a href="#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件" class="header-anchor">#</a> redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？</h2> <p>redux 本来是同步的，为什么它能执行异步代码
当我们需要修改 store 中值的时候，我们是通过 dispatch(action)将要修改的值传到 reducer 中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理 action 的机会，在 middleware 中，我们可以检阅每一个流过的 action，并挑选出特定类型的 action 进行相应操作，以此来改变 action；
···
applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后 applyMiddleware 会将不同的中间件一层一层包裹到原生的 dispatch 之上；
redux-thunk 中间件的作用就是让我们可以异步执行 redux，首先检查参数 action 的类型，如果是函数的话，就执行这个 action 这个函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action。
···
中间件的实现原理是什么？
中间键的原理就是将原来的 dispatch 存起来然后改变他的指向 重命名
···
都有哪些中间件？
redux-thunk
redux-saga</p> <h2 id="react-按需加载"><a href="#react-按需加载" class="header-anchor">#</a> React 按需加载</h2> <p>从 react 中解构 lazy 引入的时候用 lazy 去替换原本模块化的 import 引入 结合 Router 可以做到组件懒加载的效果
const Home = lazy(() =&gt; import('./routes/Home'))</p> <h2 id="immutable"><a href="#immutable" class="header-anchor">#</a> immutable</h2> <p>用于解决 JavaScript 数据修改的问题
引用数据类型之间传递的是地址 所以当修改其中一个一起改变
为了解决这个问题可以用 深 浅拷贝
JSON.parse JSON.stringfy 当对象的 value 是函数 或者 undefined 时会失效
Object.assign
但是这样会非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable
<strong>例子 ：D:\htlm5\代码\html5-3\React.js\react-basic-2110\src\19-immutable\App.jsx</strong></p> <p>immutable 不可变数据
安装 - yarn add immutable
引入 import { Map, List, Seq, fromJS } from &quot;immutable&quot;;</p> <p>定义 immutableData</p> <ol><li><p>Map
import { Map } from &quot;immutable&quot;;
const obj = Map({
a: 1,
});
获取数据用 get 方法
obj.get('a') // 1</p></li> <li><p>Seq
Seq 可以定义数组和对象
seq 是具有惰性的, 从结果出发，不用的东西是不会执行的</p></li> <li><p>fromJS
fromJS 定义的对象具有深度 里面的对象也是 immutable 对象 formJS 会递归的, 数组和对象都能用</p></li></ol> <p>改变数据需要新建一个变量 用 set 方法定义
const obj2 = obj.set(&quot;a&quot;, 2);</p> <p>obj 于 obj2 比较的时候由于是赋值的所以是需要比较里面的数据相不相同</p> <p>对象合并 - merge</p> <p>定义数组 引入 List
import { List } from &quot;immutable&quot;;
immutable 数组有一些 api，这些 api 很多和原生 api 相同
const list1 = List([1, 2]);
const list2 = list1.push(3, 4, 5); //1 2 3 4 5
const list3 = list2.unshift(0); //0 1 2 3 4 5
const list4 = list1.concat(list2, list3);
console.log(list4);
size 表示数组长度
console.log(list4.size === 13);</p> <p>数组合并 immutable 数组可以使用数组的方法 所以直接 concat 就可以</p> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> WebPack</h2> <p>WebPack 可以看做是静态资源打包机，它做的事情是，分析你的项目结构，因为浏览器很多文件都不认识，所以要转换成浏览器认识的文件，将其打包为合适的格式以供浏览器使用。
前端环境分为
开发环境:无法在服务器环境中运行（本地做开发的时候）
生产环境:将开发环境的代码经过打包压缩编译之后的文件，放在测试环境服务器中运行
核心概念：
wepack 管控打包转化的控制工具，将源码转成目标格式
entry：入口文件，它是一个数组，因为它有很多个入口，
output：出口文件，打包出的文件所在目录
loader：转换器，用于对模块的源代码进行转换。（将不是 js 文件转成 js 文件经行打包压缩 8）
样式：style-loader、css-loader、less-loader、sass-loader 等
文件：raw-loader、file-loader 、url-loader 等
编译：babel-loader、coffee-loader 、ts-loader 等
校验测试：mocha-loader、jshint-loader 、eslint-loader 等
Plugin：插件，本质是构造函数，给工程化提供额外的功能
webpack 内置 UglifyJsPlugin，压缩和混淆代码。
webpack 内置 CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。
ProvidePlugin：自动加载模块，代替 require 和 import
···
底层：
是由 node.js 来开发的--也就是说 webpack 配置文件都是 node.js 文件，
环境支持 node.js8 版本以上
书写规范：common.js 规范
···
source-map 把错误映射到源码的位置
···
热更新
在应用程序的开发环境，方便开发人员在不刷新页面的情况下，就能修改代码，并且直观地在页面上看到变化的机制，提升开发效率。
···
webpack 如何实现热部署
通过 webpack-dev-server 来实现，它是 webpack 官方提供的一个小型 Express 服务器，使用它可以为 webpack 打包生成的资源文件提供 web 服务。可以使用它来实时监听代码文件变化。
项目中只需要在配置文件 package.json 配置 hot: true, // 是否热更新即可开启 Hot Module Replacemen 即热模块替换</p> <h2 id="webpack-与-grunt、gulp"><a href="#webpack-与-grunt、gulp" class="header-anchor">#</a> webpack 与 grunt、gulp</h2> <p>相同点：都是前端构建⼯具，grunt、gulp 以前流⾏，现在 webpack 流⾏，轻量化的任务还是可以⽤ gulp 来实现。
grunt 和 gulp 是基于任务和流的：找到⼀个⼜⼀个⽂件，做链式操作更新流上的数据，这个为⼀个任务，多个任务组成整个 web 构建流程。
webpack 是一个打包模块化 javascript 的工具，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目。loader 用于加载某些资源文件，plugin 用于扩展 webpack 的功能。
webpack 四个组成：⼊⼝，出⼝，loader，plugin</p> <h2 id="类型检查和默认值"><a href="#类型检查和默认值" class="header-anchor">#</a> 类型检查和默认值</h2> <p>函数式组件的默认值只能写成
App.defaultProps = {
msg : &quot;zhangsan&quot;
}
类组件的默认值可以在外面写
App.defaultProps = {
msg : &quot;zhangsan&quot;
}
也可以在类里面加一个 static 表示私有属性
static defaultProps = {
name : &quot;wangwu&quot;
}
static propTypes = {
name: PropTypes.string,
};
类型检查
import PropTypes from 'prop-types';
写法同默认值</p> <h2 id="ts-和-js-的区别-使用-typescript-的好处"><a href="#ts-和-js-的区别-使用-typescript-的好处" class="header-anchor">#</a> Ts 和 JS 的区别 使用 typescript 的好处</h2> <p>区别
Typescript 是 JavaScript 的超集，它支持所有 JavaScript 的语法，并在此基础上添加静态类型定义和面向对象的思想。最终编译成 JavaScript 运行。 TypeScript 它不是一门新的语言，而是用来规范 js 的，js 始终是一门弱类型语言 ，ts 它是 js 的超集 js 分成 EcmaScript(js 的语法规范),Dom(文档对象模型),Bom(浏览器对象模型)ts 实际上是 EcmaScript 的超集, ts 是强类型版的 js</p> <p>使用 typescript 的好处</p> <p>1.开源，跨平台。它本身不需要考虑运行环境的问题，所有支持 JavaScript 的地方都可以使用 typescript； 2.引入静态类型声明，减少不必要的类型判断和文档注释；
3。及早发现错误，静态类型检查 1 或编译时发现问题，不用等到运行； 4.类、接口的使用更易于构建和维护组件； 5.重构更方便可靠，适合大型项目；</p> <h2 id="react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数"><a href="#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数" class="header-anchor">#</a> react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数</h2> <ul><li><p>react 中的 key 有什么作用</p> <p>1.简单的来说就是为了提高 diff 的同级比较的效率，避免原地复用带来的副作用
2.react 利用 key 来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个 key 对应一个组件，相同的 key react 认为是同一个组件，这样后续相同的 key 对应组件都不会被创</p></li></ul> <p>key 发生变化会发生什么</p> <p>key 值不同组件会销毁再重新创建</p> <p>key 值发生改变后会执行哪些生命周期函数</p> <p>1.componentWillUnmount
2.constructor
3.componentWillMount（可以不说）
4.render
5.componentDidMount</p> <h2 id="react-中的闭包陷阱-closure-trap"><a href="#react-中的闭包陷阱-closure-trap" class="header-anchor">#</a> React 中的闭包陷阱（Closure Trap）</h2> <h3 id="_1-什么是闭包陷阱"><a href="#_1-什么是闭包陷阱" class="header-anchor">#</a> 1. 什么是闭包陷阱？</h3> <p>在 React 的函数式组件中，<strong>闭包陷阱</strong>常发生在 <code>useEffect</code>、<code>useCallback</code> 等 Hooks 中。其本质是：组件中的函数（尤其是在 effect 或回调中）形成了一个闭包，捕获并持有了<strong>旧的（过时的）state 或 props 值</strong>。</p> <ul><li><p>核心原因</p> <ul><li>React 的函数组件每次渲染都是一次独立的“快照”。</li> <li>组件内部的所有变量（state, props）和函数，都是该次渲染“快照”的一部分。</li> <li>如果某个函数是在某次渲染中创建的，它就会“记住”当时的 state 和 props。</li> <li>如果这个函数在后续渲染中没有被更新，它“记住”的就永远是旧的值。</li></ul></li></ul> <hr> <h3 id="_2-经典陷阱案例-setinterval-计数器"><a href="#_2-经典陷阱案例-setinterval-计数器" class="header-anchor">#</a> 2. 经典陷阱案例：setInterval 计数器</h3> <ul><li><p>错误示例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">IntervalCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里形成了闭包，count 永远是初始值</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">正在更新 count... 闭包中捕获的 count 值是 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖数组为空，仅组件挂载时运行一次</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>问题分析</p> <ul><li>初始渲染：<code>count</code> 为 0，<code>useEffect</code> 执行，<code>setInterval</code> 的回调函数被创建。</li> <li>闭包形成：<code>setInterval</code> 的回调函数“记住”了初始渲染时的 <code>count</code>，这个值永远是 0。</li> <li>后续行为：
<ol><li>1 秒后，定时器触发，执行 <code>setCount(0 + 1)</code>，<code>count</code> 变为 1。</li> <li>2 秒后，定时器再次触发，但回调函数闭包里的 <code>count</code> 依旧是 0，再次 <code>setCount(0 + 1)</code>。</li></ol></li> <li><strong>最终结果</strong>：<code>count</code> 的值只会在 0 和 1 之间来回变化，无法持续递增。</li></ul></li></ul> <hr> <h3 id="_3-如何避免闭包陷阱"><a href="#_3-如何避免闭包陷阱" class="header-anchor">#</a> 3. 如何避免闭包陷阱？</h3> <ul><li>方法一：正确使用依赖数组</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把 count 加入依赖数组</span>
</code></pre></div><ul><li>原理：<code>count</code> 每次改变，<code>useEffect</code> 会重新执行，旧定时器被清除，创建新定时器，捕获到最新的 <code>count</code>。</li> <li>缺点：对于 <code>setInterval</code> 这类场景，频繁清除/创建定时器有性能开销，可能导致计时不准，通常<strong>不推荐</strong>。</li></ul> <hr> <ul><li>方法二：使用函数式更新（推荐）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prevCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数式更新</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖数组为空</span>
</code></pre></div><ul><li>原理：<code>setCount</code> 传入函数，React 会确保 <code>prevCount</code> 永远是<strong>最新的状态值</strong>。</li> <li>优点：无须依赖外部闭包的变量，写法简洁，性能好，是最佳实践。</li></ul> <hr> <ul><li>方法三：使用 useRef 保存最新值</li></ul> <p>适用于需要在异步回调中<strong>读取最新 state 或 props</strong>的场景。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">IntervalCounterWithRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> countRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 同步 ref 的值</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    countRef<span class="token punctuation">.</span>current <span class="token operator">=</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>countRef<span class="token punctuation">.</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>原理：<code>ref</code> 对象在组件整个生命周期中不变。闭包捕获的是 <code>countRef</code> 这个稳定对象，通过 <code>.current</code> 总能读取到最新的 <code>count</code>。</li> <li>优点：适用于任何需要异步回调中获取最新 state/props 的场景，通用性强。</li></ul> <hr> <h3 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4. 总结</h3> <ul><li><strong>闭包陷阱</strong>是 React 函数组件开发中常见的陷阱，尤其在 <code>useEffect</code>、<code>setInterval</code>、异步回调等场景中。</li> <li>推荐优先使用<strong>函数式更新</strong>解决闭包陷阱。</li> <li>更复杂的场景下，可以通过 <code>useRef</code> 解决对最新 state/props 的读取问题。</li></ul> <hr> <h3 id="_5-参考"><a href="#_5-参考" class="header-anchor">#</a> 5. 参考</h3> <ul><li><a href="https://react.dev/reference/react/useState" target="_blank" rel="noopener noreferrer">React 官方文档 - Using the State Hook<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904186715285512" target="_blank" rel="noopener noreferrer">深入理解 React Hooks 的闭包陷阱<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.ec81c2a4.js" defer></script><script src="/jiabinxu-blog/assets/js/3.c5fdad7d.js" defer></script><script src="/jiabinxu-blog/assets/js/2.34d20650.js" defer></script><script src="/jiabinxu-blog/assets/js/48.05896a6c.js" defer></script>
  </body>
</html>
