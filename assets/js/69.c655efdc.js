(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{391:function(e,t,s){"use strict";s.r(t);var n=s(27),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"基于-next-js-的双-token-无感刷新认证系统-学习笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于-next-js-的双-token-无感刷新认证系统-学习笔记"}},[e._v("#")]),e._v(" 基于 Next.js 的双 Token 无感刷新认证系统 - 学习笔记")]),e._v(" "),t("h2",{attrs:{id:"🚀-概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🚀-概述"}},[e._v("#")]),e._v(" 🚀 概述")]),e._v(" "),t("p",[e._v("首先token分为两种一种是短期的一种是长期的，为什么要分为两个token呢，就是因为出于安全性考虑，比如说你单token登录，一个token过期时间设置为几天，如果被人获取到了这个token，别人就可以利用这个token登录用户的账号，这个token也不能设置的太短，如果太短的话用户体验就太差了，你去上个厕所回来就要重新登录了")]),e._v(" "),t("p",[e._v("再说回双token登录，短期token和长期token，短期token作为真正的token去使用所有的请求头都带上这个token，另外一个长期token作为刷新token，当我们的短期token过期的时候我们通过这个refreshtoken验证是否真正的过期，没有过期就重新签发一个短期token实现无感刷新")]),e._v(" "),t("p",[e._v("双Token体系,"),t("strong",[e._v("两种Token的存储位置和方式完全不同")]),e._v("：短期token可以存在内存中，长期token在服务器中（服务端设置的 HttpOnly Cookie）里，所以前端获取不到这个代码，安全系数高")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("短期 accessToken")]),e._v("：因为它需要被JavaScript频繁读取并添加到请求头中，所以通常存储在"),t("strong",[e._v("客户端的内存")]),e._v("里（比如React的state或Vuex/Pinia中）。这使得它容易受到XSS攻击，但因为它生命周期极短，被盗后的危害有限。")]),e._v(" "),t("li",[t("strong",[e._v("长期 refreshToken")]),e._v("：它的安全性最高。最佳实践是将其存储在由"),t("strong",[e._v("服务端设置的 HttpOnly Cookie")]),e._v(" 中。\n"),t("ul",[t("li",[t("code",[e._v("HttpOnly")]),e._v(" 属性意味着前端的JavaScript代码"),t("strong",[e._v("完全无法读取")]),e._v("到这个Cookie。")]),e._v(" "),t("li",[e._v("这样一来，即使网站遭到XSS攻击，攻击者的脚本也偷不走 "),t("code",[e._v("refreshToken")]),e._v("，从而保证了用户长期会话的安全。")])])])]),e._v(" "),t("p",[e._v("可能遇到的问题："),t("a",{attrs:{href:"#%E7%AC%AC-7-%E6%AD%A5-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82-%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%88%B7%E6%96%B0"}},[e._v("如果多个请求同时因为 Token 过期而失败，它们会同时触发刷新，造成浪费和冲突。")])]),e._v(" "),t("h2",{attrs:{id:"第一部分-后端-api-接口搭建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一部分-后端-api-接口搭建"}},[e._v("#")]),e._v(" 第一部分：后端 API 接口搭建")]),e._v(" "),t("p",[e._v("我们在 Next.js 的 App Router 中创建三个核心的 API 接口，用于处理认证流程。")]),e._v(" "),t("h3",{attrs:{id:"第-1-步-用户登录接口-api-auth-login"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-1-步-用户登录接口-api-auth-login"}},[e._v("#")]),e._v(" 第 1 步：用户登录接口 ("),t("code",[e._v("/api/auth/login")]),e._v(")")]),e._v(" "),t("p",[t("strong",[e._v("目的")]),e._v("：验证用户身份，成功后返回 "),t("code",[e._v("accessToken")]),e._v("，同时将 "),t("code",[e._v("refreshToken")]),e._v(" 安全地设置在 "),t("code",[e._v("HttpOnly")]),e._v(" Cookie 中。")]),e._v(" "),t("h4",{attrs:{id:"_1-1-签发两种-token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-签发两种-token"}},[e._v("#")]),e._v(" 1.1 - 签发两种 Token")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/login/route.ts\nimport { sign } from 'jsonwebtoken';\n\n// 假设用户验证成功，用户ID为 1\nconst userId = 1;\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n\n// 创建 AccessToken (有效期短，例如15分钟)\nconst accessToken = sign({ userId }, JWT_SECRET, { expiresIn: '15m' });\n// 创建 RefreshToken (有效期长，例如7天)\nconst refreshToken = sign({ userId }, JWT_SECRET, { expiresIn: '7d' });\n")])])]),t("h4",{attrs:{id:"_1-2-将-refreshtoken-序列化为安全的-cookie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-将-refreshtoken-序列化为安全的-cookie"}},[e._v("#")]),e._v(" 1.2 - 将 RefreshToken 序列化为安全的 Cookie")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/login/route.ts\nimport { serialize } from 'cookie';\n\nconst serializedCookie = serialize('refreshToken', refreshToken, {\n    httpOnly: true, // 防止JS读取，防御XSS攻击\n    secure: process.env.NODE_ENV === 'production', // 只在HTTPS下传输\n    sameSite: 'strict', // 严格的同站策略，防御CSRF攻击\n    maxAge: 60 * 60 * 24 * 7, // 7天有效期\n    path: '/',\n});\n")])])]),t("h4",{attrs:{id:"_1-3-组合成完整接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-组合成完整接口"}},[e._v("#")]),e._v(" 1.3 - 组合成完整接口")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/login/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function POST(req: Request) {\n    // ... 用户名密码验证逻辑 ...\n    // ... 签发 token 和序列化 cookie 的代码 ...\n    \n    return NextResponse.json(\n        { accessToken }, // 在body中返回accessToken\n        {\n            status: 200,\n            headers: { 'Set-Cookie': serializedCookie }, // 在header中设置cookie\n        }\n    );\n}\n")])])]),t("blockquote",[t("p",[e._v("💡 "),t("strong",[e._v("核心知识点回顾")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("jsonwebtoken")]),e._v(": 这是一个构建和验证“数字身份证”（JWT）的工具。\n"),t("ul",[t("li",[t("code",[e._v("jwt.sign()")]),e._v(": "),t("strong",[e._v("签发凭证")]),e._v("。它接收用户信息（Payload）、一个绝密的秘钥（Secret Key），生成一个带防伪签名（Signature）的 Token 字符串。这确保了 Token 的内容未经篡改。")]),e._v(" "),t("li",[t("code",[e._v("jwt.verify()")]),e._v(": "),t("strong",[e._v("验证凭证")]),e._v("。它使用"),t("strong",[e._v("同一个秘钥")]),e._v("来检查 Token 的签名是否正确、是否在有效期内。这是实现"),t("strong",[e._v("无状态认证")]),e._v("的关键，服务器无需存储 Session 信息。")])])]),e._v(" "),t("li",[t("strong",[e._v("NextResponse.json()")]),e._v(": 这不是简单的 "),t("code",[e._v("JSON.stringify()")]),e._v("。它是一个"),t("strong",[e._v("完整的 HTTP 响应构造器")]),e._v("。\n"),t("ul",[t("li",[e._v("它将 JS 对象转换为 JSON 字符串作为"),t("strong",[e._v("响应体 (Body)")]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("自动设置")]),e._v("关键的 "),t("code",[e._v("Content-Type: application/json")]),e._v(" "),t("strong",[e._v("响应头 (Header)")]),e._v("，告知浏览器数据格式。")]),e._v(" "),t("li",[e._v("它返回一个功能齐全的 "),t("code",[e._v("NextResponse")]),e._v(" 对象，允许你链式地设置状态码、Cookie ("),t("code",[e._v("Set-Cookie")]),e._v(") 和其他自定义 Headers，是构建健壮后端 API 的基石。")])])])])]),e._v(" "),t("h3",{attrs:{id:"第-2-步-刷新-token-接口-api-auth-refresh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-2-步-刷新-token-接口-api-auth-refresh"}},[e._v("#")]),e._v(" 第 2 步：刷新 Token 接口 ("),t("code",[e._v("/api/auth/refresh")]),e._v(")")]),e._v(" "),t("p",[t("strong",[e._v("目的")]),e._v("：当 "),t("code",[e._v("accessToken")]),e._v(" 过期时，前端调用此接口，验证 "),t("code",[e._v("refreshToken")]),e._v(" Cookie，并返回一个新的 "),t("code",[e._v("accessToken")]),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-读取并验证-cookie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-读取并验证-cookie"}},[e._v("#")]),e._v(" 2.1 - 读取并验证 Cookie")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/refresh/route.ts\nimport { cookies } from 'next/headers';\nimport { verify } from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n\nexport async function POST(req: Request) {\n    const cookieStore = cookies();\n    const refreshToken = cookieStore.get('refreshToken')?.value;\n\n    if (!refreshToken) {\n        return NextResponse.json({ message: 'RefreshToken 未找到' }, { status: 401 });\n    }\n\n    try {\n        const decoded = verify(refreshToken, JWT_SECRET) as { userId: number };\n        // ... 接 2.2\n    } catch (error) {\n        return NextResponse.json({ message: '会话无效，请重新登录' }, { status: 401 });\n    }\n}\n")])])]),t("h4",{attrs:{id:"_2-2-签发新的-accesstoken"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-签发新的-accesstoken"}},[e._v("#")]),e._v(" 2.2 - 签发新的 AccessToken")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/refresh/route.ts\n// ... (在 try 块内部)\n// 使用从 refreshToken 解码出的用户信息来创建新的 accessToken\nconst accessToken = sign({ userId: decoded.userId }, JWT_SECRET, { expiresIn: '15m' });\nreturn NextResponse.json({ accessToken });\n")])])]),t("h3",{attrs:{id:"第-3-步-用户登出接口-api-auth-logout"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-3-步-用户登出接口-api-auth-logout"}},[e._v("#")]),e._v(" 第 3 步：用户登出接口 ("),t("code",[e._v("/api/auth/logout")]),e._v(")")]),e._v(" "),t("p",[t("strong",[e._v("目的")]),e._v("：让 "),t("code",[e._v("refreshToken")]),e._v(" Cookie 失效，完成登出。通过返回一个同名、同路径但 "),t("code",[e._v("maxAge")]),e._v(" 为负数的 Cookie 实现。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/api/auth/logout/route.ts\nimport { NextResponse } from 'next/server';\nimport { serialize } from 'cookie';\n\nexport async function POST(req: Request) {\n    const serializedCookie = serialize('refreshToken', '', {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        path: '/',\n        maxAge: -1, // 关键：设置为负数使其立即过期\n    });\n\n    return NextResponse.json(\n        { message: '登出成功' },\n        {\n            status: 200,\n            headers: { 'Set-Cookie': serializedCookie },\n        }\n    );\n}\n")])])]),t("h2",{attrs:{id:"第二部分-前端认证状态管理-use-client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二部分-前端认证状态管理-use-client"}},[e._v("#")]),e._v(" 第二部分：前端认证状态管理 ("),t("code",[e._v('"use client"')]),e._v(")")]),e._v(" "),t("h3",{attrs:{id:"第-4-步-创建认证上下文-authcontext"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-4-步-创建认证上下文-authcontext"}},[e._v("#")]),e._v(" 第 4 步：创建认证上下文 (AuthContext)")]),e._v(" "),t("p",[t("strong",[e._v("目的")]),e._v("：创建一个全局状态管理器，让应用中任何组件都能方便地获取认证状态和方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/contexts/AuthContext.tsx\n\"use client\";\nimport React, { createContext, useContext, useState, ReactNode } from 'react';\n\n// ... (接口定义和 Provider/Hook 骨架)\n")])])]),t("h3",{attrs:{id:"第-5-步-封装认证请求-authfetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-5-步-封装认证请求-authfetch"}},[e._v("#")]),e._v(" 第 5 步：封装认证请求 ("),t("code",[e._v("authFetch")]),e._v(")")]),e._v(" "),t("p",[t("strong",[e._v("目的")]),e._v("：创建一个 "),t("code",[e._v("fetch")]),e._v(" 的替代品，它能自动为请求添加 "),t("code",[e._v("Authorization")]),e._v(" 头，并处理后续的无感刷新。")]),e._v(" "),t("h3",{attrs:{id:"第-6-步-实现核心的无感刷新逻辑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-6-步-实现核心的无感刷新逻辑"}},[e._v("#")]),e._v(" 第 6 步：实现核心的无感刷新逻辑")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("authFetch")]),e._v(" 内部捕获 401 错误，调用刷新 API，获取新的 "),t("code",[e._v("accessToken")]),e._v("，然后用新 Token "),t("strong",[e._v("重试")]),e._v("刚才失败的请求。")]),e._v(" "),t("h3",{attrs:{id:"第-7-步-处理并发请求-防止重复刷新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-7-步-处理并发请求-防止重复刷新"}},[e._v("#")]),e._v(" 第 7 步：处理并发请求，防止重复刷新")]),e._v(" "),t("p",[e._v("问题：如果多个请求同时因为 Token 过期而失败，它们会同时触发刷新，造成浪费和冲突。")]),e._v(" "),t("p",[e._v("解决方案：使用一个外部变量作为“锁”，确保同一时间只有一个刷新请求在进行。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/contexts/AuthContext.tsx\n\n// 在 AuthProvider 组件外部定义一个变量\nlet refreshTokenPromise: Promise<string | null> | null = null;\n\n// 在 AuthProvider 内部，authFetch 的 401 处理逻辑\nif (response.status === 401) {\n    if (!refreshTokenPromise) {\n        // 如果当前没有正在刷新的请求，则发起一个新的\n        refreshTokenPromise = new Promise(async (resolve, reject) => {\n            try {\n                // ... (执行刷新Token的API调用) ...\n                const newAccessToken = '...';\n                resolve(newAccessToken);\n            } catch (e) {\n                reject(e);\n            } finally {\n                // 结束后，清空Promise，以便下次可以再次触发\n                refreshTokenPromise = null;\n            }\n        });\n    }\n\n    try {\n        // 等待正在进行的刷新请求完成\n        const newAccessToken = await refreshTokenPromise;\n        // ... (用 newAccessToken 重试请求) ...\n    } catch (e) {\n        // 刷新失败，登出\n    }\n}\n")])])]),t("blockquote",[t("p",[e._v("🧠 "),t("strong",[e._v("深度解析：并发刷新与 Promise 锁模式")])]),e._v(" "),t("p",[e._v("这是一个极其巧妙的并发控制模式。为什么必须用 "),t("code",[e._v("Promise")]),e._v(" 而不是简单的布尔值 "),t("code",[e._v("isRefreshing")]),e._v("？")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("布尔值的缺陷")]),e._v(": 布尔值只能告知“"),t("strong",[e._v("是否在刷新")]),e._v("”，但它无法提供一个机制让后来的请求"),t("strong",[e._v("暂停并等待结果")]),e._v("，也无法"),t("strong",[e._v("传递最终的结果")]),e._v("（新的Token）。简单的 "),t("code",[e._v("while(isRefreshing)")]),e._v(" 会阻塞 JavaScript 主线程，导致页面卡死。")]),e._v(" "),t("li",[t("strong",[e._v("Promise 的完美 çözüm")]),e._v("：\n"),t("ol",[t("li",[t("strong",[e._v("状态即是锁")]),e._v(": 一个处于 "),t("code",[e._v("pending")]),e._v(" 状态的 Promise 本身就是一个完美的“锁”。")]),e._v(" "),t("li",[t("strong",[e._v("await 即是等待")]),e._v(": "),t("code",[e._v("await")]),e._v(" 关键字天生就是用来“暂停”当前函数，等待一个 Promise 完成，并且"),t("strong",[e._v("不会阻塞主线程")]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("resolve 即是结果传递")]),e._v(": 当 Promise 被 "),t("code",[e._v("resolve(value)")]),e._v(" 时，所有 "),t("code",[e._v("await")]),e._v(" 这个 Promise 的地方都会被唤醒，并拿到这个 "),t("code",[e._v("value")]),e._v("。")])])])]),e._v(" "),t("blockquote",[t("p",[e._v("思想升华：发布-订阅模式的精妙应用")])]),e._v(" "),t("blockquote",[t("p",[e._v("这个 Promise 锁模式，本质上是"),t("strong",[e._v("利用 Promise 的原生特性，实现了一次性的、带记忆功能的发布-订阅模式")]),e._v("。")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[t("strong",[e._v("主题")]),e._v(": "),t("code",[e._v("refreshTokenPromise")]),e._v(" 这个 Promise 对象。")]),e._v(" "),t("li",[t("strong",[e._v("发布者")]),e._v(": 第一个触发刷新并创建 "),t("code",[e._v("new Promise")]),e._v(" 的请求。它通过调用 "),t("code",[e._v("resolve")]),e._v(" 或 "),t("code",[e._v("reject")]),e._v(" 来“发布”最终结果。")]),e._v(" "),t("li",[t("strong",[e._v("订阅者")]),e._v(": 所有后来 "),t("code",[e._v("await refreshTokenPromise")]),e._v(" 的请求。它们“订阅”了这个主题，等待最终结果的通知。")])])]),e._v(" "),t("blockquote",[t("p",[e._v("这证明了"),t("strong",[e._v("设计模式是一种思想，而非固定的代码")]),e._v("。通过理解其核心（如解耦），我们可以用各种工具（如 Promise）巧妙地实现它。")])])]),e._v(" "),t("h2",{attrs:{id:"第三部分-整合与使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三部分-整合与使用"}},[e._v("#")]),e._v(" 第三部分：整合与使用")]),e._v(" "),t("h3",{attrs:{id:"第-8-步-全局应用-provider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-8-步-全局应用-provider"}},[e._v("#")]),e._v(" 第 8 步：全局应用 Provider")]),e._v(" "),t("p",[e._v("将 "),t("code",[e._v("AuthProvider")]),e._v(" 包裹在根布局 "),t("code",[e._v("layout.tsx")]),e._v(" 中，使整个应用都能访问到认证状态。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 文件: /app/layout.tsx\nimport { AuthProvider } from './contexts/AuthContext';\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <AuthProvider>\n          {children}\n        </AuthProvider>\n      </body>\n    </html>\n  );\n}\n\n")])])]),t("h3",{attrs:{id:"第-9-步-在组件中使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-9-步-在组件中使用"}},[e._v("#")]),e._v(" 第 9 步：在组件中使用")]),e._v(" "),t("p",[e._v("在任何客户端组件中，通过 "),t("code",[e._v("useAuth")]),e._v(" hook 来获取数据或执行操作。"),t("code",[e._v("authFetch")]),e._v(" 会在后台自动处理所有 Token 刷新逻辑，实现真正的“无感刷新”。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 文件: /app/dashboard/page.tsx\n"use client";\nimport { useAuth } from "../contexts/AuthContext";\nimport { useEffect } from "react";\n\nexport default function Dashboard() {\n    const { authFetch, logout } = useAuth();\n\n    useEffect(() => {\n        const loadData = async () => {\n            try {\n                // 使用我们封装好的 authFetch，它会自动处理认证和刷新\n                const res = await authFetch(\'/api/some-protected-data\');\n                const data = await res.json();\n                console.log(data);\n            } catch (error) {\n                // 刷新失败的错误会在这里被捕获\n                console.error(error);\n            }\n        };\n        loadData();\n    }, [authFetch]);\n\n    return <button onClick={logout}>登出</button>;\n}\n\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);