(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{355:function(v,_,e){"use strict";e.r(_);var o=e(27),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"常见场景题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见场景题"}},[v._v("#")]),v._v(" 常见场景题")]),v._v(" "),_("h2",{attrs:{id:"echarts-的-0-秒无感刷新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#echarts-的-0-秒无感刷新"}},[v._v("#")]),v._v(" ECharts 的“0 秒无感刷新”")]),v._v(" "),_("p",[v._v("要实现 ECharts 的“0 秒无感刷新”只需在 useEffect 中启动一个定时器（setInterval），用它定期轮询 API 获取最新数据，然后直接调用 ECharts 实例的 setOption 方法，不带第二个参数（或者设为 false）。ECharts 就会自动“合并”新旧数据并平滑地更新图表，而不会产生闪烁。\n如果数据量很大，这种方法就不适用了")]),v._v(" "),_("h2",{attrs:{id:"sse-大屏实时化方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sse-大屏实时化方案"}},[v._v("#")]),v._v(" SSE 大屏实时化方案")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("它是什么：")]),v._v(" SSE 是一种"),_("strong",[v._v("单向")]),v._v("的通信协议，允许服务器"),_("strong",[v._v("主动地")]),v._v("将数据“推送”到客户端（浏览器）。")]),v._v(" "),_("li",[_("strong",[v._v("它与 Polling (轮询) 的区别：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("轮询 (Pull)：")]),v._v(" 客户端每 5 秒问一次“有新数据吗？”，99% 的时间服务器都在回答“没有”。")]),v._v(" "),_("li",[_("strong",[v._v("SSE (Push)：")]),v._v(" 客户端建立一个“长连接”，告诉服务器：“有新数据了再叫我”。服务器只在"),_("strong",[v._v("有数据时")]),v._v("才推送，"),_("strong",[v._v("没有")]),v._v("任何浪费的请求。")])])]),v._v(" "),_("li",[_("strong",[v._v("它与 WebSockets 的区别：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("WebSockets：")]),v._v(" "),_("strong",[v._v("双向")]),v._v("通信。客户端可以“推”，服务器也可以“推”。这对于“聊天室”是必须的。")]),v._v(" "),_("li",[_("strong",[v._v("SSE：")]),v._v(" "),_("strong",[v._v("单向")]),v._v("通信（服务器 -> 客户端）。这对于“大屏”（只负责"),_("em",[v._v("展示")]),v._v("数据）来说，功能不多不少，"),_("strong",[v._v("刚刚好")]),v._v("，而且开销更小。")])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"工作机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工作机制"}},[v._v("#")]),v._v(" 工作机制：")]),v._v(" "),_("p",[v._v("要实现 SSE，客户端和服务器必须“串通”，它分为两部分：")]),v._v(" "),_("h4",{attrs:{id:"a-客户端-大屏-订阅者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#a-客户端-大屏-订阅者"}},[v._v("#")]),v._v(" A. 客户端 (大屏) - “订阅者”")]),v._v(" "),_("p",[v._v("客户端的工作"),_("strong",[v._v("极其简单")]),v._v("，这是 SSE 最大的优势之一。")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("关键 API：EventSource")]),v._v(" "),_("ul",[_("li",[v._v("我们在 "),_("code",[v._v("useEffect")]),v._v(" (的 "),_("code",[v._v("mount")]),v._v(" 阶段) 中，创建"),_("strong",[v._v("一个")]),v._v(" "),_("code",[v._v("EventSource")]),v._v(" 实例，指向一个特定的后端 API（比如 "),_("code",[v._v("/api/dashboard-stream")]),v._v("）。")])])]),v._v(" "),_("li",[_("strong",[v._v("监听消息：.onmessage")]),v._v(" "),_("ul",[_("li",[v._v("我们为这个 "),_("code",[v._v("EventSource")]),v._v(" 实例绑定一个 "),_("code",[v._v(".onmessage")]),v._v(" 事件监听器。")])])]),v._v(" "),_("li",[_("strong",[v._v("接收数据")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("当且仅当")]),v._v("服务器推送了新数据，这个 "),_("code",[v._v(".onmessage")]),v._v(" 事件"),_("strong",[v._v("才会触发")]),v._v("。")]),v._v(" "),_("li",[v._v("我们从 "),_("code",[v._v("event.data")]),v._v(" 属性中拿到“数据”（通常是 JSON 字符串），然后 "),_("code",[v._v("JSON.parse")]),v._v("。")])])]),v._v(" "),_("li",[_("strong",[v._v("更新状态")]),v._v(" "),_("ul",[_("li",[v._v("我们用这个新数据去 "),_("code",[v._v("setState")]),v._v("（或更新 React 19 的 "),_("code",[v._v("useOptimistic")]),v._v(" 等）。")])])]),v._v(" "),_("li",[_("strong",[v._v("ECharts 更新")]),v._v(" "),_("ul",[_("li",[v._v("ECharts 组件（或任何其他图表库）监听到 state 变化，自动调用 "),_("code",[v._v("setOption")]),v._v(" 更新视图。")]),v._v(" "),_("li",[_("strong",[v._v("(重点)")]),v._v(" ECharts 的“0 秒无感刷新”（"),_("code",[v._v("setOption")]),v._v(" 合并）这个优点"),_("strong",[v._v("被保留")]),v._v("了。")])])])]),v._v(" "),_("h4",{attrs:{id:"b-服务端-推送者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-服务端-推送者"}},[v._v("#")]),v._v(" B. 服务端 - “推送者”")]),v._v(" "),_("p",[v._v("服务端的工作是 SSE 的"),_("strong",[v._v("核心")]),v._v("。")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("特定的 API 终结点 (Endpoint)")]),v._v(" "),_("ul",[_("li",[v._v("那个 "),_("code",[v._v("/api/dashboard-stream")]),v._v(" 接口"),_("strong",[v._v("不能")]),v._v("是一个普通的 API。")]),v._v(" "),_("li",[v._v("它"),_("strong",[v._v("不能")]),v._v("在收到请求后立刻 "),_("code",[v._v("res.json()")]),v._v(" 并关闭连接。")])])]),v._v(" "),_("li",[_("strong",[v._v("特殊的“响应头” (Headers)")]),v._v(" "),_("ul",[_("li",[v._v("服务器"),_("strong",[v._v("必须")]),v._v("发送一个特殊的 "),_("code",[v._v("Content-Type")]),v._v(" 响应头： "),_("code",[v._v("Content-Type: text/event-stream")])]),v._v(" "),_("li",[v._v("这就是告诉浏览器：“注意，这不是一次性数据，这是一个‘流’，请保持连接！”")]),v._v(" "),_("li",[v._v("服务器还必须发送 "),_("code",[v._v("Cache-Control: no-cache")]),v._v(" 和 "),_("code",[v._v("Connection: keep-alive")]),v._v("。")])])]),v._v(" "),_("li",[_("strong",[v._v("“保持连接” (Long-lived Connection)")]),v._v(" "),_("ul",[_("li",[v._v("服务器**必须“挂起”**这个 HTTP 连接，"),_("strong",[v._v("不能")]),v._v("关闭它。")])])]),v._v(" "),_("li",[_("strong",[v._v("“推送”数据 (The Push)")]),v._v(" "),_("ul",[_("li",[v._v("当后端（比如数据库、Kafka、Redis 消息队列）"),_("strong",[v._v("真的")]),v._v("有了新数据...")]),v._v(" "),_("li",[v._v("服务器"),_("strong",[v._v("立即")]),v._v("通过这个“挂起”的连接，"),_("code",[v._v("res.write()")]),v._v(" 一个"),_("strong",[v._v("特定格式")]),v._v("的纯文本字符串。")]),v._v(" "),_("li",[_("strong",[v._v("SSE 格式：")]),v._v(" "),_("code",[v._v('data: {"chart_id": "A", "value": 123}\\n\\n')])]),v._v(" "),_("li",[v._v("(注意：必须是 "),_("code",[v._v("data:")]),v._v(" 开头，必须是 "),_("code",[v._v("\\n\\n")]),v._v(" 结尾)。")])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"为什么-sse-特别适合-大屏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么-sse-特别适合-大屏"}},[v._v("#")]),v._v(" 为什么 SSE 特别适合“大屏”？")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("真实时，零浪费")]),v._v(" "),_("ul",[_("li",[v._v("解决了 "),_("code",[v._v("setInterval")]),v._v(" 的"),_("strong",[v._v("所有缺陷")]),v._v("。没有浪费的请求，服务器只在需要时才工作，客户端 CPU 占用极低。")])])]),v._v(" "),_("li",[_("strong",[v._v("自动重连")]),v._v(" "),_("ul",[_("li",[v._v("这是 SSE "),_("strong",[v._v("秒杀")]),v._v(" WebSocket 的地方（在“大屏”场景下）。")]),v._v(" "),_("li",[v._v("“大屏”通常会 24/7 运行。如果网络"),_("strong",[v._v("闪断")]),v._v("了一下...")]),v._v(" "),_("li",[_("strong",[v._v("WebSocket：")]),v._v(" 连接会断开，你"),_("strong",[v._v("必须")]),v._v("自己写复杂的“心跳检测”和“重连”逻辑。")]),v._v(" "),_("li",[_("strong",[v._v("SSE (EventSource)：")]),v._v(" 浏览器"),_("strong",[v._v("内置")]),v._v("了“自动重连”机制。如果连接断开，"),_("code",[v._v("EventSource")]),v._v(" 会"),_("strong",[v._v("自动")]),v._v("（在几秒后）尝试重新连接，直到成功。")])])])]),v._v(" "),_("h3",{attrs:{id:"注意"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[v._v("#")]),v._v(" 注意")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("数据格式：")]),v._v(" SSE 只能传输"),_("strong",[v._v("纯文本")]),v._v("。这意味着所有复杂对象（JSON）都"),_("strong",[v._v("必须")]),v._v("在服务器端 "),_("code",[v._v("JSON.stringify")]),v._v("，并在客户端 "),_("code",[v._v("JSON.parse")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("连接数限制：")]),v._v(" 浏览器对 "),_("code",[v._v("EventSource")]),v._v(" 的"),_("strong",[v._v("并发连接数")]),v._v("有限制（比如一个域名下最多 6 个）。这对于“大屏”通常不是问题，因为一个“大屏”页面通常只需要一个“主数据流”。")]),v._v(" "),_("li",[_("strong",[v._v("代理/防火墙：")]),v._v(" "),_("code",[v._v("SSE")]),v._v(" 是一种“长连接”。中间的 Nginx 代理或防火墙"),_("strong",[v._v("必须")]),v._v("被正确配置，允许 "),_("code",[v._v("keep-alive")]),v._v("，并且"),_("strong",[v._v("不能")]),v._v("“缓冲 (buffer)” "),_("code",[v._v("text/event-stream")]),v._v(" 的响应，否则客户端会收不到数据。")])]),v._v(" "),_("h2",{attrs:{id:"ai-实训平台-sse-server-sent-events-的实现与管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ai-实训平台-sse-server-sent-events-的实现与管理"}},[v._v("#")]),v._v(" ai 实训平台-SSE (Server-Sent Events) 的实现与管理")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("概述")]),v._v("：\n与 ai 对话的时候，由于大模型需要时间来思考，如果要让大模型一下输出所有答案的话需要经历长时间的等待，用户体验不好，所以有了 sse 流式输出，就是将一个完整的 sse 事件割到多个数据块中，然后把所有解码后的字符串拼在一个大字符串里面，这个字符串可以称为缓冲区，起到缓冲的作用，检查这个结果中是否有分隔符，这个分隔符就是用来分割要展示的部分，如果你第一次要展示 a，第二次展示 b 那 a 和 b 之间就会有分隔符，如果有分隔符 "),_("code",[v._v("\\n\\n")]),v._v("。如果有分隔符就说明有一个完整事件，然后逐个渲染完整的事件字符串，把已经渲染的部分从缓冲区移出去，通过一个结束的标志 "),_("code",[v._v("data: [DONE]")]),v._v("决定整条回答是否结束")]),v._v(" "),_("p",[v._v("在请求头中设置了 "),_("code",[v._v("Accept: 'text/event-stream'")]),v._v("，返回的是一个响应流通过 "),_("code",[v._v("response.body.getReader()")]),v._v(" 获取流的读取器（reader）。然后在一个循环中不断调用 "),_("code",[v._v("reader.read()")]),v._v(" 来读取数据块。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("实现")]),v._v(":\n我在 "),_("code",[v._v("useChatAPI")]),v._v(" 这个自定义 Hook 中封装了 SSE 的处理逻辑。通过 "),_("code",[v._v("fetch")]),v._v(" API 发起流式请求（利用了 "),_("code",[v._v("apiClient.js")]),v._v(" 中封装的 "),_("code",[v._v("postStream")]),v._v(" 方法），然后使用 "),_("code",[v._v("response.body.getReader()")]),v._v(" 和 "),_("code",[v._v("TextDecoder")]),v._v(" 来逐步读取流数据。为了应对网络传输中数据块可能被分割的情况，我维护了一个缓冲区 ("),_("code",[v._v("buffer")]),v._v(")，累积接收到的数据，直到遇到 SSE 事件的分隔符 ("),_("code",[v._v("\\n\\n")]),v._v(") 才进行处理。解析时需要剥离 "),_("code",[v._v("data:")]),v._v(" 前缀，处理 JSON 解析可能出现的异常，并特别识别流结束的标志 "),_("code",[v._v("[DONE]")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("状态更新")]),v._v(":\n在流式接收过程中，需要实时更新聊天界面的消息状态 ("),_("code",[v._v("setMessagesState")]),v._v(")，将接收到的文本片段累加到对应的机器人消息上，并展示加载（打字）动画。这里使用了 "),_("code",[v._v("useRef")]),v._v(" (如 "),_("code",[v._v("currentBotMessageIdRef")]),v._v(") 来确保在异步回调中能正确地更新对应的消息气泡。")])])]),v._v(" "),_("p",[_("strong",[v._v("错误处理")]),v._v(": SSE 的错误处理比较复杂。不仅要处理请求发起时的 HTTP 错误，还要处理流传输过程中可能出现的错误（比如后端模型报错并通过流返回错误信息）。我增加了逻辑来检测流数据中的错误标识，并在 UI 上将对应的消息标记为错误状态，同时确保在流结束或出错时正确释放读取器 ("),_("code",[v._v("reader.releaseLock()")]),v._v(") 并清理状态。")]),v._v(" "),_("p",[_("strong",[v._v("SSE 错误处理，内置了自动重连。")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("发生的情况")]),v._v("：\n"),_("ol",[_("li",[v._v("你正在接收 AI 的流式回答。")]),v._v(" "),_("li",[v._v("你突然走进了电梯，网络断了。")]),v._v(" "),_("li",[_("code",[v._v("EventSource")]),v._v(" 对象会监听到连接中断 (触发 "),_("code",[v._v("onerror")]),v._v(" 事件)。")]),v._v(" "),_("li",[v._v("此时，它"),_("strong",[v._v("会自动")]),v._v("进入重连模式。")]),v._v(" "),_("li",[v._v("它会每隔几秒钟（这个时间可以由服务器通过 "),_("code",[v._v("retry:")]),v._v(" 字段指定，默认约 3 秒）"),_("strong",[v._v("自动尝试重新向原来的 URL 发起连接")]),v._v("。")]),v._v(" "),_("li",[v._v("当你走出电梯，网络恢复了，它下一次重连尝试就会成功，然后继续接收数据流。")])])]),v._v(" "),_("li",[_("strong",[v._v("需要后端配合")]),v._v("： 这种自动重连也需要后端设计配合。后端需要知道你是“断线重连”的，还是“发起新提问”的。 通常，浏览器重连时会发送一个特殊的 HTTP 头 "),_("code",[v._v("Last-Event-ID")]),v._v("（这个 ID 可以由服务器在上一条消息中用 "),_("code",[v._v("id: ...")]),v._v(" 字段指定）。服务器看到这个 ID，就应该知道“哦，他刚才收到第 500 个字了”，然后从第 501 个字开始继续推流，而不是从头开始回答。")])]),v._v(" "),_("p",[_("strong",[v._v("一些细节")]),v._v("：维护机器人消息的 id，需要用 useref 存储，因为获取消息的函数是异步的，异步代码中就存在一个闭包的问题，它里面可能会获取到旧值，为啥不用 useState，虽然可以用 setState 里面获取到上一次的值处理，但是这个 id 是不变的不需要频繁的更新他，所以这里最好用 useRef")]),v._v(" "),_("p",[v._v("还有就是防止并发请求，也是用 useRef 维护一个值，初始为 false 表示没有请求正在进行，然后请求的开始的时候把这个值设置为 true，")]),v._v(" "),_("h2",{attrs:{id:"ai-实训平台的-token-处理-经典-spa-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ai-实训平台的-token-处理-经典-spa-模式"}},[v._v("#")]),v._v(" ai 实训平台的 token 处理(经典 SPA 模式)")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("登录与存储")]),v._v("：\n"),_("ul",[_("li",[v._v("用户在登录页（"),_("code",[v._v("src/app/register/components/RegisterForm.jsx")]),v._v("）提交表单。")]),v._v(" "),_("li",[_("code",[v._v("handleFinish")]),v._v(" 函数被调用，它使用 "),_("code",[v._v("apiClient.post")]),v._v(" 请求 "),_("code",[v._v("/api/user/login")]),v._v(" 接口。")]),v._v(" "),_("li",[v._v("如果登录成功，后端"),_("strong",[v._v("在响应体（JSON 数据）中")]),v._v("返回 "),_("code",[v._v("access_token")]),v._v(" 和 "),_("code",[v._v("dify_token")]),v._v("。")]),v._v(" "),_("li",[v._v("您的 "),_("code",[v._v("authStore.login")]),v._v(" 方法被调用，它将这个 "),_("code",[v._v("access_token")]),v._v(" 存储到 "),_("strong",[v._v("localStorage")]),v._v(" 中，并同时更新 MobX 的 state ("),_("code",[v._v("this.isLoggedIn = true")]),v._v(")。")])])]),v._v(" "),_("li",[_("strong",[v._v("请求时携带 Token")]),v._v("：\n"),_("ul",[_("li",[v._v("您的 "),_("code",[v._v("src/lib/apiClient.js")]),v._v(" 文件中注册了一个"),_("strong",[v._v("请求拦截器")]),v._v(" ("),_("code",[v._v("addRequestInterceptor")]),v._v(")。")]),v._v(" "),_("li",[v._v("这个拦截器会在"),_("strong",[v._v("每一次 API 请求发送前")]),v._v("自动执行。")]),v._v(" "),_("li",[v._v("它的任务是从 "),_("code",[v._v('localStorage.getItem("authToken")')]),v._v(" 读取 Token。")]),v._v(" "),_("li",[v._v("如果 Token 存在，它会将其添加到请求头（Headers）中："),_("code",[v._v("Authorization: Bearer ${tokenFromStorage}")]),v._v("。")])])]),v._v(" "),_("li",[_("strong",[v._v("应用加载时恢复登录")]),v._v("：\n"),_("ul",[_("li",[v._v("当用户刷新页面时，"),_("code",[v._v("src/app/layout.jsx")]),v._v(" 会加载 "),_("code",[v._v("AuthStore")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("AuthStore")]),v._v(" 的 "),_("code",[v._v("initializeAuth")]),v._v(" 方法会运行，它会去 "),_("code",[v._v("localStorage")]),v._v(' 检查 "authToken" 是否存在。')]),v._v(" "),_("li",[v._v("如果存在，它会立刻尝试调用 "),_("code",[v._v("/api/user/get_user_info")]),v._v("。")]),v._v(" "),_("li",[v._v("如果这个请求成功（因为 "),_("code",[v._v("apiClient")]),v._v(" 自动携带了 Token），则确认登录有效，设置 "),_("code",[v._v("this.isLoggedIn = true")]),v._v(" 并拉取用户信息。如果失败（比如 Token 过期了），则调用 "),_("code",[v._v("this.logout()")]),v._v("。")])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"如何知道用户有没有权限"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何知道用户有没有权限"}},[v._v("#")]),v._v(" 如何知道用户有没有权限")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("客户端的前置检查（UI 层面）")]),v._v("：\n"),_("ul",[_("li",[v._v("这是主动防御。您的组件（如 "),_("code",[v._v("src/components/Navigation.jsx")]),v._v("）会观察 "),_("code",[v._v("authStore.isLoggedIn")]),v._v(" 的状态。")]),v._v(" "),_("li",[v._v("如果 "),_("code",[v._v("isLoggedIn")]),v._v(" 为 "),_("code",[v._v("false")]),v._v("，导航按钮会直接被设置为 "),_("code",[v._v("disabled")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("优点")]),v._v("：用户界面（UI）响应及时，用户甚至没有机会点击一个他无权访问的按钮。")])])]),v._v(" "),_("li",[_("strong",[v._v("服务端的拒绝响应（API 层面）")]),v._v("：\n"),_("ul",[_("li",[v._v("这是真正的权限关卡。如果用户未登录（"),_("code",[v._v("localStorage")]),v._v(" 中没有 Token）或者 Token 已经过期，但他们仍然尝试调用一个需要权限的 API（比如直接访问某个页面触发了 "),_("code",[v._v("useEffect")]),v._v(" 中的 API 请求）：")]),v._v(" "),_("li",[v._v("您的 "),_("code",[v._v("apiClient")]),v._v(" 会发送请求（此时可能没有 "),_("code",[v._v("Authorization")]),v._v(" 头，或者头信息是过期的）。")]),v._v(" "),_("li",[v._v("后端服务器会检查 "),_("code",[v._v("Authorization")]),v._v(" 头。发现无效或缺失，会拒绝请求，并返回一个 "),_("strong",[v._v("HTTP 状态码，通常是 401 Unauthorized")]),v._v("。")]),v._v(" "),_("li",[v._v("您的 "),_("code",[v._v("apiClient.js")]),v._v(" 中的 "),_("code",[v._v("request")]),v._v(" 函数会检查 "),_("code",[v._v("if (!response.ok)")]),v._v("，发现响应状态不是 2xx。")]),v._v(" "),_("li",[v._v("它会抛出一个 "),_("code",[v._v("HttpError")]),v._v("。")]),v._v(" "),_("li",[v._v("在您的 "),_("code",[v._v("AuthStore.js")]),v._v(" 中（比如 "),_("code",[v._v("initializeAuth")]),v._v(" 或 "),_("code",[v._v("refreshUserInfo")]),v._v("），"),_("code",[v._v("try...catch")]),v._v(" 块会捕获这个 "),_("code",[v._v("HttpError")]),v._v("。如果发现 "),_("code",[v._v("error.status === 401")]),v._v("，它就会调用 "),_("code",[v._v("this.logout()")]),v._v("，清空本地状态和 "),_("code",[v._v("localStorage")]),v._v("，强制用户回到未登录状态。")])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"next-js-的做法-server-centric-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#next-js-的做法-server-centric-模式"}},[v._v("#")]),v._v(" Next.js 的做法(Server-Centric 模式)")]),v._v(" "),_("p",[v._v("Next.js（特别是 App Router）推崇一种更安全、更强大的"),_("strong",[v._v("以服务端为中心的认证模式")]),v._v("。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("核心区别")]),v._v("：不使用 "),_("code",[v._v("localStorage")]),v._v("，而是使用 "),_("strong",[v._v("httpOnly Cookie")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("登录")]),v._v("：用户提交登录表单。后端 API 收到请求并验证通过后，"),_("strong",[v._v("不")]),v._v("在 JSON 响应体中返回 Token。相反，它在响应头中设置一个 "),_("code",[v._v("Set-Cookie")]),v._v("，例如： "),_("code",[v._v("Set-Cookie: authToken=...; HttpOnly; Secure; SameSite=Strict; Path=/")])]),v._v(" "),_("li",[_("strong",[v._v("什么是 httpOnly？")]),v._v("：这意味着这个 Cookie "),_("strong",[v._v("不能被任何客户端 JavaScript 访问")]),v._v("（即 "),_("code",[v._v("document.cookie")]),v._v(" 看不到它）。这能极大地防止 XSS 攻击者窃取 Token。")]),v._v(" "),_("li",[_("strong",[v._v("请求")]),v._v("：浏览器在后续向"),_("strong",[v._v("同域名")]),v._v("发送的"),_("strong",[v._v("所有请求")]),v._v("中，都会"),_("strong",[v._v("自动")]),v._v("携带这个 "),_("code",[v._v("httpOnly")]),v._v(" Cookie。您的 "),_("code",[v._v("apiClient")]),v._v(" 不再需要任何请求拦截器来手动添加 "),_("code",[v._v("Authorization")]),v._v(" 头。")]),v._v(" "),_("li",[_("strong",[v._v("权限判断")]),v._v("：\n"),_("ol",[_("li",[_("strong",[v._v("在服务端组件（RSC）中")]),v._v("：Next.js 的 Server Components 可以直接在服务端运行。它们可以读取请求中的 Cookie，判断用户是否登录，然后再决定是否渲染页面或获取数据。")]),v._v(" "),_("li",[_("strong",[v._v("在 Middleware 中")]),v._v("：这是 Next.js 最强大的功能之一。您可以在 "),_("code",[v._v("src/middleware.js")]),v._v(" 文件中编写一个函数。这个函数会在"),_("strong",[v._v("所有")]),v._v("（或您指定的 "),_("code",[v._v("matcher")]),v._v(" 匹配的）路由被访问"),_("strong",[v._v("之前")]),v._v("在服务器上运行。\n"),_("ul",[_("li",[v._v("它可以检查请求中是否存在 "),_("code",[v._v("httpOnly")]),v._v(" 的 "),_("code",[v._v("authToken")]),v._v(" Cookie。")]),v._v(" "),_("li",[v._v("如果 Cookie 不存在，它可以"),_("strong",[v._v("直接将用户重定向")]),v._v("到登录页面，用户甚至永远不会看到受保护页面的内容。")])])])])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"如何将-next-js-的做法-融合到您的项目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何将-next-js-的做法-融合到您的项目"}},[v._v("#")]),v._v(' 如何将 "Next.js 的做法" 融合到您的项目')]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("后端 API 修改 (最重要)")]),v._v(" "),_("ul",[_("li",[v._v("修改您的 "),_("code",[v._v("/api/user/login")]),v._v(" 接口。当登录成功时，不再返回 "),_("code",[v._v("access_token")]),v._v("。")]),v._v(" "),_("li",[v._v("改为在响应头中设置 "),_("code",[v._v("httpOnly")]),v._v(" Cookie。")]),v._v(" "),_("li",[v._v("创建一个 "),_("code",[v._v("/api/user/logout")]),v._v(" 接口，该接口的唯一作用是返回一个清除 "),_("code",[v._v("authToken")]),v._v(" Cookie 的响应头。")])])]),v._v(" "),_("li",[_("strong",[v._v("src/lib/apiClient.js 修改")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("移除")]),v._v(" "),_("code",[v._v("addRequestInterceptor")]),v._v(" 中从 "),_("code",[v._v("localStorage")]),v._v(" 读取并设置 "),_("code",[v._v("Authorization")]),v._v(" 头的整段逻辑。")]),v._v(" "),_("li",[v._v("（如果您的 API 和 Next.js 应用不在同一个子域下）在 "),_("code",[v._v("fetch")]),v._v(" 的 "),_("code",[v._v("options")]),v._v(" 中添加 "),_("code",[v._v("credentials: 'include'")]),v._v("，以确保浏览器在跨域请求时也会发送 Cookie。")])])]),v._v(" "),_("li",[_("strong",[v._v("src/stores/AuthStores.js 修改")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("login 方法")]),v._v("：不再需要接收 "),_("code",[v._v("accessToken")]),v._v(" 和 "),_("code",[v._v("difyToken")]),v._v("（如果 "),_("code",[v._v("difyToken")]),v._v(" 也改用 Cookie）。它只需要在 API 调用成功后，设置 "),_("code",[v._v("isLoggedIn = true")]),v._v("，然后调用 "),_("code",[v._v("refreshUserInfo")]),v._v(" (或 "),_("code",[v._v("initializeAuth")]),v._v(") 来获取用户信息。")]),v._v(" "),_("li",[_("strong",[v._v("logout 方法")]),v._v("：在清空 MobX 状态之前，"),_("strong",[v._v("必须")]),v._v("先 "),_("code",[v._v("await apiClient.post('/api/user/logout')")]),v._v(" 来通知后端清除 "),_("code",[v._v("httpOnly")]),v._v(" Cookie。同时移除 "),_("code",[v._v("localStorage.removeItem")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("initializeAuth 方法")]),v._v("：这是变化最大的地方。\n"),_("ul",[_("li",[_("strong",[v._v("移除")]),v._v("所有 "),_("code",[v._v("localStorage.getItem")]),v._v(" 的逻辑。")]),v._v(" "),_("li",[v._v("它的唯一工作就是："),_("code",[v._v("this.setLoading(true)")]),v._v("，然后直接尝试调用 "),_("code",[v._v('apiClient.get("/api/user/get_user_info")')]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("如果成功")]),v._v("：说明浏览器自动发送了有效的 "),_("code",[v._v("httpOnly")]),v._v(" Cookie，后端验证通过。此时 "),_("code",[v._v("runInAction")]),v._v(" 设置 "),_("code",[v._v("this.userInfo")]),v._v(" 和 "),_("code",[v._v("this.isLoggedIn = true")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("如果失败 (catch 到 401)")]),v._v("：说明没有 Cookie 或 Cookie 无效，调用 "),_("code",[v._v("this.logout(false)")]),v._v(" (确保不再次调用 "),_("code",[v._v("localStorage.removeItem")]),v._v(")。")])])])])]),v._v(" "),_("li",[_("strong",[v._v("(推荐) 增加 src/middleware.js")]),v._v(" "),_("ul",[_("li",[v._v("在您的 "),_("code",[v._v("src/")]),v._v(" 目录下创建一个新文件 "),_("code",[v._v("middleware.js")]),v._v("。")]),v._v(" "),_("li",[v._v("在里面，您可以定义哪些路由是受保护的（比如 "),_("code",[v._v("/modelWorkbench")]),v._v(" 和 "),_("code",[v._v("/personalCenter")]),v._v("）。")]),v._v(" "),_("li",[_("code",[v._v("middleware")]),v._v(" 会检查请求中是否有 "),_("code",[v._v("authToken")]),v._v(" Cookie。如果没有，它会直接返回一个重定向响应，将用户踢到登录页面。")])])])]),v._v(" "),_("p",[_("strong",[v._v("融合后的好处：")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("更安全")]),v._v("："),_("code",[v._v("httpOnly")]),v._v(" Cookie 无法被 JS 窃取。")]),v._v(" "),_("li",[_("strong",[v._v("更优雅")]),v._v("："),_("code",[v._v("apiClient")]),v._v(" 变得更干净，不再需要手动管理 Token 注入。")]),v._v(" "),_("li",[_("strong",[v._v("服务端保护")]),v._v("："),_("code",[v._v("middleware")]),v._v(" 提供了真正的路由级保护，而不是像现在这样仅仅在客户端隐藏/禁用 UI 元素。")])]),v._v(" "),_("p",[v._v("希望这个分析对您有帮助！您想先从哪一步开始讨论修改呢？例如，我们可以先看看如何修改 "),_("code",[v._v("AuthStore.js")]),v._v(" 的 "),_("code",[v._v("initializeAuth")]),v._v(" 方法。")]),v._v(" "),_("h3",{attrs:{id:"拦截器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拦截器"}},[v._v("#")]),v._v(" 拦截器")]),v._v(" "),_("p",[_("strong",[v._v("拦截器注册表 (一个数组)")])]),v._v(" "),_("ul",[_("li",[v._v("在 "),_("code",[v._v("apiClient.js")]),v._v(" 文件的顶部，定义了一个全局数组 "),_("code",[v._v("requestInterceptors = []")]),v._v("。")]),v._v(" "),_("li",[v._v("文件还导出了一个函数 "),_("code",[v._v("export function addRequestInterceptor(fn)")]),v._v("，任何其他文件都可以调用这个函数，将一个自定义的函数（即一个“拦截器”）添加到 "),_("code",[v._v("requestInterceptors")]),v._v(" 数组中。")])]),v._v(" "),_("p",[_("strong",[v._v("拦截器执行 (在核心请求函数中)")])]),v._v(" "),_("ul",[_("li",[v._v("在 "),_("code",[v._v("apiClient.js")]),v._v(" 文件的核心 "),_("code",[v._v("request")]),v._v(" 函数中，"),_("strong",[v._v("在真正发起 fetch 请求之前")]),v._v("，它会使用一个 "),_("code",[v._v("for...of")]),v._v(" 循环来遍历 "),_("code",[v._v("requestInterceptors")]),v._v(" 数组。")]),v._v(" "),_("li",[v._v("它会执行（"),_("code",[v._v("await")]),v._v("）数组中的每一个拦截器函数，并把当前的请求配置对象（"),_("code",[v._v("currentOptions")]),v._v("）传递给它。")]),v._v(" "),_("li",[v._v("拦截器函数会修改这个 "),_("code",[v._v("currentOptions")]),v._v(" 对象（比如添加请求头），然后再将其返回，传递给下一个拦截器或最终的 "),_("code",[v._v("fetch")]),v._v(" 调用。")])]),v._v(" "),_("p",[_("strong",[v._v("您的 Token 拦截器 (具体实现)")])]),v._v(" "),_("ul",[_("li",[v._v("在 "),_("code",[v._v("apiClient.js")]),v._v(" 文件的底部，它立即调用了 "),_("code",[v._v("addRequestInterceptor")]),v._v(" 注册了一个默认的拦截器。这就是您关心的 Token 注入逻辑。")]),v._v(" "),_("li",[v._v("这个拦截器的实现步骤是：\n"),_("ul",[_("li",[v._v("a. 从 "),_("code",[v._v('localStorage.getItem("authToken")')]),v._v(" 读取 Token。")]),v._v(" "),_("li",[v._v("b. 检查 Token 是否存在 ("),_("code",[v._v("if (tokenFromStorage)")]),v._v(")。")]),v._v(" "),_("li",[v._v("c. 确保 "),_("code",[v._v("config.headers")]),v._v(" 是一个可写的 "),_("code",[v._v("Headers")]),v._v(" 对象。")]),v._v(" "),_("li",[v._v("d. 检查是否"),_("strong",[v._v("尚未")]),v._v("存在 "),_("code",[v._v("Authorization")]),v._v(" 请求头 ("),_("code",[v._v('if (!headers.has("Authorization"))')]),v._v(")。")]),v._v(" "),_("li",[v._v('e. 如果不存在，它会检查 Token 是否已包含 "Bearer " 前缀，如果不包含，则手动添加，然后设置 '),_("code",[v._v('headers.set("Authorization", authorizationValue)')]),v._v("。")]),v._v(" "),_("li",[v._v("f. 返回被修改后的 "),_("code",[v._v("config")]),v._v(" 对象。")])])])]),v._v(" "),_("h2",{attrs:{id:"结合-ai-实训平台谈谈路由拦截-nextjs-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结合-ai-实训平台谈谈路由拦截-nextjs-模式"}},[v._v("#")]),v._v(" 结合 ai 实训平台谈谈路由拦截（nextjs 模式）")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("您的项目中目前有没有路由拦截？")]),v._v(" "),_("strong",[v._v("答：")]),v._v(" 您的项目目前"),_("strong",[v._v("没有")]),v._v("真正意义上的“路由拦截”（Route Interception）或“路由守卫”（Route Guard）。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("那您的项目是如何防止未授权访问的？")]),v._v(" 您的项目目前依赖两层“保护”，这是一种非常典型的纯客户端 SPA（单页应用）的实现方式：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("第 1 层：UI 层的“导航守卫” (在 Navigation.jsx 中)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("原理：")]),v._v(" 您的 "),_("code",[v._v("Navigation")]),v._v(" 组件 会从 "),_("code",[v._v("authStore")]),v._v(" 侦听 "),_("code",[v._v("isLoggedIn")]),v._v(" 状态。如果用户未登录 ("),_("code",[v._v("!isLoggedIn")]),v._v(")，它会直接给“模型工作台”和“智能体工作台”等链接对应的 "),_("code",[v._v("GradientButton")]),v._v(" 组件传递 "),_("code",[v._v("disabled={true}")]),v._v(" 属性。")]),v._v(" "),_("li",[_("strong",[v._v("优点：")]),v._v(" 界面响应非常快，用户能立刻看到自己无权访问某些区域。")]),v._v(" "),_("li",[_("strong",[v._v("缺点：")]),v._v(" 这"),_("strong",[v._v("极其不安全")]),v._v("。这只是“隐藏了门把手”，但门没有锁。如果用户知道 URL（例如，直接在浏览器地址栏输入 "),_("code",[v._v("/modelWorkbench/modelTrain")]),v._v("），他可以"),_("strong",[v._v("完全绕过")]),v._v("这个 UI 守卫并直接访问页面。")])])]),v._v(" "),_("li",[_("strong",[v._v("第 2 层：API 层的“数据守卫” (在 apiClient.js 和 AuthStores.js 中)")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("原理：")]),v._v(" 这是您的"),_("strong",[v._v("实际安全防线")]),v._v("。当用户（如上所述）绕过 UI 守卫直接访问 "),_("code",[v._v("/modelWorkbench/modelTrain")]),v._v(" 页面时：\n"),_("ol",[_("li",[_("code",[v._v("modelTrain/page.jsx")]),v._v(" 组件会加载。")]),v._v(" "),_("li",[v._v("它的 "),_("code",[v._v("useEffect")]),v._v(" 会调用 "),_("code",[v._v("getData()")]),v._v(" 来获取数据。")]),v._v(" "),_("li",[_("code",[v._v("getData()")]),v._v(" 使用 "),_("code",[v._v("apiClient")]),v._v(" 发起请求。")]),v._v(" "),_("li",[v._v("您的 "),_("code",[v._v("apiClient.js")]),v._v(" 中的"),_("strong",[v._v("请求拦截器")]),v._v(" 会尝试从 "),_("code",[v._v("localStorage")]),v._v(' 读取 "authToken"。')]),v._v(" "),_("li",[v._v("由于用户未登录，"),_("code",[v._v("localStorage")]),v._v(" 中没有 Token。")]),v._v(" "),_("li",[v._v("后端 API 收到一个没有 "),_("code",[v._v("Authorization")]),v._v(" 头的请求，并返回 "),_("strong",[v._v("401 Unauthorized")]),v._v(" 错误。")]),v._v(" "),_("li",[v._v("您的 "),_("code",[v._v("AuthStore.js")]),v._v(" 在 "),_("code",[v._v("initializeAuth")]),v._v(" 或 "),_("code",[v._v("refreshUserInfo")]),v._v(" 的 "),_("code",[v._v("catch")]),v._v(" 块中捕获到这个 401 错误，并调用 "),_("code",[v._v("this.logout()")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("logout()")]),v._v(" 会清空状态，"),_("code",[v._v("isLoggedIn")]),v._v(" 变为 "),_("code",[v._v("false")]),v._v("，"),_("code",[v._v("layout.jsx")]),v._v(" 监听到变化，将顶部的 "),_("code",[v._v("PersonalCenter")]),v._v(" 切换为“登录/注册”按钮，从而在"),_("em",[v._v("事实上")]),v._v("将用户“踢”出了登录状态。")])])]),v._v(" "),_("li",[_("strong",[v._v("优点：")]),v._v(" 提供了真正的安全兜底，未授权的 API 请求绝对不会成功。")]),v._v(" "),_("li",[_("strong",[v._v("缺点：")]),v._v(" "),_("strong",[v._v("用户体验极差")]),v._v("。用户会先加载一个（可能是空的或显示加载中的）受保护页面，然后数据请求失败，最后 UI 才响应并“跳”回到未登录状态。这就是所谓的“页面闪烁”。")])])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("Next.js 的推荐方法")]),v._v("：中间件 (Middleware)")]),v._v(" "),_("p",[v._v("Next.js 推荐使用"),_("strong",[v._v("中间件（Middleware）")]),v._v(" 来实现真正、安全的路由拦截。这是在服务器端执行的，远在客户端 JavaScript 加载之前。")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("原理：")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("您需要在您的 "),_("code",[v._v("src/")]),v._v(" 目录下创建一个文件，命名为 "),_("code",[v._v("middleware.js")]),v._v(" (或 "),_("code",[v._v(".ts")]),v._v(")。")])]),v._v(" "),_("li",[_("p",[v._v("在这个文件中，您可以导出一个 "),_("code",[v._v("config")]),v._v(" 对象，其中包含一个 "),_("code",[v._v("matcher")]),v._v(" 数组，用来定义哪些路由需要被这个中间件“拦截”。")]),v._v(" "),_("div",{staticClass:"language-JavaScript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("export")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" config "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),_("span",{pre:!0,attrs:{class:"token literal-property property"}},[v._v("matcher")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'/modelWorkbench/:path*'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 拦截所有模型工作台的子路由")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'/personalCenter'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("       "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 拦截个人中心")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// ... 其他需要登录的路由")]),v._v("\n  "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("然后，您导出一个 "),_("code",[v._v("middleware(request)")]),v._v(" 函数。这个函数会在"),_("strong",[v._v("服务器上")]),v._v("（在边缘网络）运行，"),_("strong",[v._v("在您的页面（Page）或布局（Layout）开始渲染之前")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("在这个函数中，您可以检查请求中的 "),_("strong",[v._v("Cookie")]),v._v("（Next.js 推荐使用 "),_("code",[v._v("httpOnly")]),v._v(" Cookie 存储 Token，而不是 "),_("code",[v._v("localStorage")]),v._v("）。")])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("优点 (相比您当前的方法)：")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("绝对安全：")]),v._v(" 拦截发生在服务器端。未授权的用户"),_("strong",[v._v("永远不会")]),v._v("收到受保护页面的任何 HTML 或 JavaScript。")]),v._v(" "),_("li",[_("strong",[v._v("无闪烁：")]),v._v(" 用户会被立即、干净地重定向到登录页，根本没有机会看到受保护页面的布局。")]),v._v(" "),_("li",[_("strong",[v._v("集中管理：")]),v._v(" 所有受保护的路由都在 "),_("code",[v._v("matcher")]),v._v(" 中统一定义，而不是分散在各个组件的 "),_("code",[v._v("disabled")]),v._v(" 属性中。")]),v._v(" "),_("li",[_("strong",[v._v("兼容 httpOnly Cookie：")]),v._v(" 这是最安全的存储 Token 方式，因为它无法被客户端的 JavaScript（XSS 攻击）读取，但中间件在服务器上可以读取它")])])])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);