[{"id":"v-36e44725","path":"/Html+Css/","pageTitle":"HTML+Css 概述","headerTitle":null,"text":"# HTML+Css 概述 HTML 是一门超文本标记语言而不是编程语言，其包括诸多标签可以用于构建基本的网页，而浏览器可以通过其内核去解析这些标签，将其界面正确的展示出来； HTML 的标签是由尖括号包围的关键词; HTML 的标签一般是成对出现的，如 div 标签,类似这种的称为双标签；当然也有单标签，如 br 换行标签； ```Html <div></div> <br> ``` 标签的关系有包含关系和并列关系,如下所示： - 包含关系：html 标签里包含着 head 标签，因此可以称为是包含关系（父子关系） - 并列关系：head 标签和 body 标签不存在包含关系，而是并列在一起的，因此称为并列关系（兄弟关系） ```Html <html> <head></head> <body></body> </html> ``` ##"},{"id":"v-36e44725#块元素-行内元素-行内块元素","path":"/Html+Css/#块元素-行内元素-行内块元素","pageTitle":"HTML+Css 概述","headerTitle":"块元素，行内元素，行内块元素","text":"块元素，行内元素，行内块元素 - 块元素（div、p、hr、h1-h6、header、footer、ul>li 、 dl dt dd）：可设宽高，padding，border，margin，line-height。 - 块级元素以块的形式显示在页面上，它们会独占一行或多行空间，并且默认情况下会在前后创建换行。块级元素可以设置宽度、高度、内外边距等样式属性。 - 注意：块级元素的宽度默认是自动撑开到容器的宽度，而不是默认为 100% 可以容纳内联元素和其他块元素。 默认情况下会在前后创建换行。 可以设置宽度、高度、内外边距等样式属性。 - 行内元素（span 、i、b-strong、u、s、a）： 不可设置宽高、可设置水平方向的 padding，border，margin，垂直方向不行，多个行内在同一行显示，里面一般仅放文本，但 a 标签除外。 - 行内元素 行内元素不会独占一行，它们会在同一行内显示，并且大小由内容决定，无法设置宽度和高度，其宽度随着内容增加，高度随字体大小而改变。通常情况下，行内元素不能设置上下内外边距，只能设置左右内外边距。 - 特点 多个行内在同一行内显示，里面一般仅放文本，但 a 标签除外。相邻的行内元素会排列在同一行里，直到一行排不下，才会换行。行内元素的宽度由其中包含的内容决定，内容越多，宽度越大，可以随内容自动扩展，不需要设置宽度属性。 行内元素只能容纳文本或者其他行内元素。 由于行内元素是在同一行内显示的，所以通常只能设置左右内外边距，上下内外边距在默认情况下是不起作用的。 示例行内元素 - 行内块元素（input、button、select、img）：可设置宽高，padding，border，margin，line-height，多个行内块在一行显示。行内块级元素 - 行内块级元素在同一行内显示，但是它们可以设置宽度和高度，并且可以像块级元素一样设置内外边距。它们不会强制换行，可以在一行内显示多个行内块级元素。 - 特点 在同一行内显示。 可以设置宽度和高度。 可以设置内外边距。 不会强制换行。 示例行内块级元素 - 如何转换，通过 display 设置：display: block | inline-block | line - 区别 - 显示方式：块级元素和行内块级元素会独占一行或多行空间，而行内元素会在同一行内显示。 - 尺寸设置：块级元素和行内块级元素可以设置宽度和高度，而行内元素的尺寸由其内容决定。 - 内外边距：块级元素和行内块级元素可以设置上下内外边距，而行内元素通常只能设置左右内外边距。 - 换行行为：块级元素和行内块级元素会在其前后创建换行，而行内元素不会。 通过深入理解这三种元素类型的特性、区别以及转换方法，我们能够更有效地管理页面的结构和外观，从而实现更具丰富性和灵活性的网页设计。 ##"},{"id":"v-36e44725#渲染帧","path":"/Html+Css/#渲染帧","pageTitle":"HTML+Css 概述","headerTitle":"渲染帧","text":"渲染帧 由于现在广泛使用的屏幕都有固定的刷新率（比如最新的一般在 60Hz）， 在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能。 浏览器会利用这个间隔 16ms（1000ms/60）适当地对绘制进行节流， 因此 16ms 就成为页面渲染优化的一个关键时间。 尤其在异步渲染中，要利用 流式渲染 就必须考虑到这个渲染帧间隔。 为方便查阅源码和相关资料，本文以 Chromium 的 Blink 引擎为例分析。如下是一些分析结论： 一个渲染帧内 commit 的多次 DOM 改动会被合并渲染； 耗时 JS 会造成丢帧； 渲染帧间隔为 16ms 左右； 避免耗时脚本、交错读写样式以保证流畅的渲染。 渲染帧的流程 渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情： - 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等 - 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。 - 布局（Layout）：计算布局，执行渲染算法 - 重绘（Paint）：各层分别进行绘制（比如 3D 动画） 合成（Composite）：合成各层的渲染结果 最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 使用显示器的 vsync 信号控制渲染（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。 耗时 JS 会造成丢帧 JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的： 执行 JS -> 空闲 -> 绘制（16ms）-> 执行 JS -> 空闲 -> 绘制（32ms）-> ... 如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制： 执行很多 JS...（20ms）-> 空闲 -> 绘制（32ms）-> ... 例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。 ```Html <div id=\"message\"></div> <script> var then = Date.now() var i = 0 var el = document.getElementById('message') while (true) { var now = Date.now() if (now - then > 1000) { if (i++ >= 5) { break; } el.innerText += 'hello!\\n' console.log(i) then = now } } </script> ``` 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。 测量渲染帧间隔 浏览器的渲染间隔其实是很难测量的。即使通过 clientHeight 这样的接口也只能强制进行 Layout，是否 Paint 上屏仍未可知。 幸运的是，最新的浏览器基本都支持了 requestAnimationFrame 接口。 使用这个 API 可以请求浏览器在下一个渲染帧执行某个回调，于是测量渲染间隔就很方便了： ```JavaScript var then = Date.now(); var count = 0; function nextFrame(){ requestAnimationFrame(function(){ count ++ if(count % 20 === 0){ var time = (Date.now() - then) / count var ms = Math.round(time\\*1000) / 1000 var fps = Math.round(100000/ms) / 100 console.log(`count: ${count}\\t${ms}ms/frame\\t${fps}fps`) } nextFrame() }) } nextFrame() ``` 每次 requestAnimationFrame 回调执行时发起下一个 requestAnimationFrame，统计一段时间即可得到渲染帧间隔，以及 fps。逼近 16.6 ms 渲染优化建议 现在我们知道浏览器需要在 16ms 内完成整个 JS->Style->Layout->Paint->Composite 流程，那么基于此有哪些页面渲染的优化方式呢？ 避免耗时的 JavaScript 代码 耗时超过 16ms 的 JavaScript 可能会丢帧让页面变卡。如果有太多事情要做可以把这些工作重新设计，分割到各个阶段中执行。并充分利用缓存和懒初始化等策略。不同执行时机的 JavaScript 有不同的优化方式： 初始化脚本（以及其他同步脚本）。对于大型 SPA 中首页卡死浏览器也是常事，建议增加服务器端渲染或者应用懒初始化策略。 事件处理函数（以及其他异步脚本）。在复杂交互的 Web 应用中，耗时脚本可以优化算法或者迁移到 Worker 中。Worker 在移动端的兼容性已经不很错了，可以生产环境使用。 避免交错读写样式 在编写涉及到布局的脚本时，常常会多次读写样式。比如： ```JavaScript // 触发一次 Layout var h = div.clientHeight div.style.height = h + 20 // 再次触发 Layout var w = div.clientWidth div.style.width = w + 20 ``` 因为浏览器需要给你返回正确的宽高，上述代码片段中每次 Layout 触发都会阻塞当前脚本。 如果把交错的读写分隔开，就可以减少触发 Layout 的次数： ```JavaScript // 触发一次 Layout var h = div.clientHeight var w = div.clientWidth div.style.height = h + 20 div.style.width = w + 20 ``` 小心事件触发的渲染 我们知道 DOM 事件的触发 是异步的，但事件处理器的执行是可能在同一个渲染帧的， 甚至就在同一个 Tick。例如异步地获取 HTML 并拼接到当前页面上， 通过监听 XHR 的 onprogress 事件 来模拟流式渲染： ```JavaScript var xhr = new XMLHttpRequest(), method = 'GET', url = 'https://harttle.land' xhr.open(method, url, true) xhr.onprogress = function () { div.innerHTML = xmlhttp.responseText }; xhr.send() ``` 上述渲染算法在网络情况较差时是起作用的，但不代表它是正确的。 比如当 https://harttle.land 对应的 HTML 非常大而且网络很好时， onprogress 事件处理器可能碰撞在同一个渲染帧中，或者干脆在同一个 Tick。 这样页面会长时间空白，即使 onprogress 早已被调用过。 ##"},{"id":"v-36e44725#常见问题","path":"/Html+Css/#常见问题","pageTitle":"HTML+Css 概述","headerTitle":"常见问题","text":"常见问题 ##"},{"id":"v-36e44725#弹性盒","path":"/Html+Css/#弹性盒","pageTitle":"HTML+Css 概述","headerTitle":"弹性盒","text":"弹性盒 display:flex; - flex-direction: row 横 | column | 主轴⽅向 - flex-wrap: nowrap 不换⾏ | wrap | wrap-reverse 是否⾃动换⾏ - justify-content: flex-start 左或上 | flex-end | center |space-between | space-around 主轴对⻬⽅式 - align-items: stretch ⾼度不设置则占满 | flex-start | flex-end | center | baseline 交叉轴对⻬⽅式 - flex-shrink: 默认 1，空间不⾜按⽐缩⼩，设为 0 不缩⼩ - flex-basis: 默认 auto，占据主轴多少空间 - flex-grow：默认为 0，属性定义项⽬的放⼤⽐例，即如果存在剩余空间，也不放⼤。 - flex: 0 1 auto， ## **"},{"id":"v-36e44725#如何让元素水平垂直居中-最多问到","path":"/Html+Css/#如何让元素水平垂直居中-最多问到","pageTitle":"HTML+Css 概述","headerTitle":"如何让元素⽔平垂直居中（最多问到）","text":"如何让元素⽔平垂直居中（最多问到）** 1. 定位偏移 top，left 为 50%，margin-left，margin-top 为⼩元素的-50% 2. 定位平均 top，left，bottom，right 为 0，margin 为 auto 3. 定位平移 top，left 为 50%，transform：translate(⼩元素的 50%) 4. 弹性盒 主轴与交叉轴居中 5. 表格 ⽗ block，⼦ table-cell ## **"},{"id":"v-36e44725#flex-的几个默认属性","path":"/Html+Css/#flex-的几个默认属性","pageTitle":"HTML+Css 概述","headerTitle":"flex 的⼏个默认属性","text":"flex 的⼏个默认属性** 第⼀个值为默认值 - flex-direction: row 横 | column | 主轴⽅向 - flex-wrap: nowrap 不换⾏ | wrap | wrap-reverse 是否⾃动换⾏ - justify-content: flex-start 左或上 | flex-end | center |space-between | space-around 主轴对⻬⽅式 - align-items: stretch ⾼度不设置则占满 | flex-start | flex-end | center | baseline 交叉轴对⻬⽅式 - flex-shrink: 默认 1，空间不⾜按⽐缩⼩，设为 0 不缩⼩ - flex-basis: 默认 auto，占据主轴多少空间 - flex-grow：默认为 0，属性定义项⽬的放⼤⽐例，即如果存在剩余空间，也不放⼤。 - flex: 0 1 auto， ## **"},{"id":"v-36e44725#清除浮动","path":"/Html+Css/#清除浮动","pageTitle":"HTML+Css 概述","headerTitle":"清除浮动","text":"清除浮动** 1. 给高度塌陷的元素加 overflow: hidden （触发 BFC） 2. 给高度塌陷的元素里面的最下面加一个空 div，div 属性 clear:both 3. 万能清除法 div::after{ content:''; height:0; overflow:hidden; visibility:hidden; display:block; clear:both; } ##"},{"id":"v-36e44725#浏览器是如何渲染页面的","path":"/Html+Css/#浏览器是如何渲染页面的","pageTitle":"HTML+Css 概述","headerTitle":"浏览器是如何渲染页面的？","text":"浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 ------ 整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 ------ **解析 HTML**。 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。 如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 ------ **样式计算**。 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px` 这一步完成后，会得到一棵带有样式的 DOM 树。 ------ **布局**，布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分时候，DOM 树和布局树并非一一对应。 比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 ------ **分层** 主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。 ------ **绘制** 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 ------ 完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 它会从线程池中拿取多个线程来完成分块工作。 ------ 分块完成后，进入**光栅化**阶段。 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图 ------ 最后一个阶段就是**画**了 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 ##"},{"id":"v-36e44725#什么是-reflow-回流","path":"/Html+Css/#什么是-reflow-回流","pageTitle":"HTML+Css 概述","headerTitle":"什么是 reflow(回流)？","text":"什么是 reflow(回流)？ reflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 ##"},{"id":"v-36e44725#什么是-repaint-重绘","path":"/Html+Css/#什么是-repaint-重绘","pageTitle":"HTML+Css 概述","headerTitle":"什么是 repaint(重绘)？","text":"什么是 repaint(重绘)？ repaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。 ## **"},{"id":"v-36e44725#本地存储-缓存","path":"/Html+Css/#本地存储-缓存","pageTitle":"HTML+Css 概述","headerTitle":"本地存储 缓存","text":"本地存储 缓存** - 存储大小 cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 - 有效时间 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 - 数据与服务器之间的交互方式 cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 ## **"},{"id":"v-36e44725#css-盒模型的理解","path":"/Html+Css/#css-盒模型的理解","pageTitle":"HTML+Css 概述","headerTitle":"Css 盒模型的理解","text":"Css 盒模型的理解** 当对⼀个⽂档进⾏布局的时候，浏览器的渲染引擎会将所有元素表示为⼀个个矩形的盒⼦。CSS 决定这些盒⼦的⼤⼩、位置以及属性（例如颜⾊、背 景、边框尺⼨…） 盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。 ⽽ IE 怪异盒模型 width 的宽度并不是 content 的宽度，⽽是 border + padding + content 的宽度值 元素占据的宽度 = margin+ width ##"},{"id":"v-36e44725#bfc","path":"/Html+Css/#bfc","pageTitle":"HTML+Css 概述","headerTitle":"BFC","text":"BFC - 概念： BFC 块状格式化上下文 （block formatting context），是一个独立空间，只有块状元素参与，规定了里面的块状元素如何布局，与外界毫不相干 - 如何触发 BFC 1. 根元素 html 2. float 除了 none 选项之外 3. position : absolute/fixed 4. display: inline-block/table-cell/flex/inline-flex 5. overflow 除了 visible 选项之外 - BFC 布局规则 1. 内部的块状元素从上往下排列 2. 垂直方向的距离由 margin 控制 属于同一个 BFC 的元素，上下 margin 会重叠 3. 每个元素的 margin-left 会和父元素的 border-left 相接触 4. BFC 的区域不会和浮动元素相重叠 5. BFC 区域和外界空间毫不相干 6. 计算 BFC 元素高度，浮动元素也参与计算 - BFC 应用 1. 两栏布局 2. 清除 margin 重叠 3. 清除浮动 ## **"},{"id":"v-36e44725#常见浏览器兼容问题","path":"/Html+Css/#常见浏览器兼容问题","pageTitle":"HTML+Css 概述","headerTitle":"常见浏览器兼容问题？","text":"常见浏览器兼容问题？** 1. 不同浏览器下的 padding 和 margin 不同 解决方法：使用通配符(\\*)将 padding 和 margin 设置为 0 2. 块属性标签 float 之后，又有横向的 margin 值，在 IE6 中显示会比设置的大（IE6 双边距 bug） 解决方法：在 float 标签样式控制中加入 display:inline; 3. 设置较小的高度标签（一般小于 10px），在 IE6，IE7，遨游中超出自己设置的高度 解决方法：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。 4. 行内标签设置 display:block;后又采用 float 布局，再设置横向 margin 值时，在 IE6 中显示会比设置的大（IE6 双边距 bug） 解决方法：在 display:block;后面加上 display:inline;display:table; ##"},{"id":"v-36e44725#清除图片间隙","path":"/Html+Css/#清除图片间隙","pageTitle":"HTML+Css 概述","headerTitle":"清除图片间隙","text":"清除图片间隙 - 清除图片左右的间隙 - 将图片挨着写（中间没有空格，也没有回车） - 将图片的父元素的 font-size 设置成 0 - 给图片设置浮动 - 清除图片的上下间距 - 将图片设置成 display: block - 给图片设置 vertical-align: top / middle / bottom ## CSS `transform: rotate` 导致的布局问题与通用解决方案 **问题的通用描述** 当你对一个元素（例如一个“矮胖”的矩形）应用 `transform: rotate(90deg)` 后，它在视觉上虽然变成了“瘦高”的形状，但它在父容器中的布局表现却不正确。 **常见症状：** 1. **父容器尺寸错误：** 包裹旋转元素的父容器，其尺寸（`width`/`height`）依然维持着子元素**旋转前**的“矮胖”尺寸，不会自动收缩来适应旋转后的“瘦高”形状。 2. **布局压缩/变形：** 如果将多个旋转后的元素放在一个 Flex 或 Grid 容器中，它们会被严重压缩或变形。这是因为布局系统仍然在尝试将它们（旋转前的“矮胖”尺寸）塞进父容器。 ### 核心原因：布局 (Layout) 与 绘制 (Paint) 分离 这个问题的根本原因在于浏览器渲染页面的两个核心阶段是分离的： 1. **布局阶段 (Layout)：** 浏览器计算每个元素应该在页面上占据多大的空间（即“盒子模型”）。**`transform` 属性在此阶段被完全忽略。** 浏览器只会看到你旋转前的“矮胖”尺寸，并为它保留一块“矮胖”的空间。 2. **绘制阶段 (Paint)：** 布局确定后，浏览器才开始“画”出元素。在这个阶段，它才看到了 `transform: rotate(90deg)` 指令，并把已经摆好位置的元素在视觉上旋转。 **结论：** `transform` 只是一个“事后”的视觉特效，它**不会**影响第一阶段就已经计算好的布局空间。 ### 通用的根源性解决方案 既然问题的根源在于 `transform` 无法影响布局，那么最直接的解决方案就是： **放弃使用 `transform` 来改变布局，转而直接改变布局本身。** **通用实现方式：** 1. **使用 JavaScript 状态：** 在你的组件中（例如 React 中的 `useState`），维护一个状态来决定元素是“宽”还是“高”。 ```javascript // 示例：React const [isTall, setIsTall] = useState(false); ``` 2. **动态切换 CSS 类：** 根据这个状态，动态地切换元素上的 CSS 类名。 ```jsx // 示例：JSX <div className={isTall ? 'shape-tall' : 'shape-wide'}> {/* ...内容... */} </div> ``` 3. **在 CSS 中定义布局：** 在 CSS 中，为这两个类分别定义**真正影响布局**的属性（如 `width/height` 或 `grid-template-*`）。 ```css /* 方案 A: 直接改变宽高 */ .shape-wide { width: 200px; height: 100px; } .shape-tall { width: 100px; height: 200px; } /* 方案 B: 改变 Grid 布局 */ .shape-wide { display: grid; grid-template-rows: repeat(2, 1fr); grid-template-columns: repeat(4, 1fr); } .shape-tall { display: grid; grid-template-rows: repeat(4, 1fr); grid-template-columns: repeat(2, 1fr); } ``` ### 总结 * **`transform` 用于视觉：** 当你只需要一个纯粹的视觉效果（如动画、悬停放大），并且**不希望**它干扰其他元素的布局时，`transform` 是最佳选择。 * **布局属性用于结构：** 当你需要一个元素的改变能**影响**到周边的布局（如推开其他元素、改变父容器大小）时，**不要**使用 `transform`。请优先考虑改变 `width`、`height`、`grid-template-columns/rows`、`flex-direction` 等真正的布局属性。"},{"id":"v-62a78390","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html","pageTitle":"函数对象","headerTitle":null,"text":"##"},{"id":"v-62a78390#函数对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#函数对象","pageTitle":"函数对象","headerTitle":"函数对象","text":"函数对象 - 概念：在 JavaScript 里，函数实际上是对象 , 同时也是对象的构造器 ###"},{"id":"v-62a78390#函数的种类细分","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#函数的种类细分","pageTitle":"函数对象","headerTitle":"函数的种类细分","text":"函数的种类细分 - 普通函数：带有函数名称 - 函数赋值给变量(常量)：函数表达式的一种 - 自执行函数：声明和调用写到一起 - 事件处理函数：给事件使用 - 构造函数：类 - 递归函数：函数调用函数自身 - 回调函数：函数做参数，传递给另外一个函数调用 - 箭头函数特点：简洁，this 不变，匿名函数，尽量不要外层使用，适合简单的函数 ###"},{"id":"v-62a78390#函数的好处及注意事项","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#函数的好处及注意事项","pageTitle":"函数对象","headerTitle":"函数的好处及注意事项","text":"函数的好处及注意事项 - 好处：函数是用来帮助我们封装、重用、可扩展的最方便的工具！ - 函数注意事项： - 函数名等于函数体 - typeof 函数 返回 function - 声明的函数如果不调用，函数相当于不存在。通过调用找函数 - 函数的参数和返回值 - 函数的参数（形参和实参） - 函数的参数相当于函数内部的变量 - arguments 操作函数的参数 - return 返回值的两种功能(返回结果，终止函数) - 函数内部的两个特殊的对象 - arguments 对象：类数组，具有 length 和非负整数的索引下标 - this：JavaScript 的关键字，存在于函数内部，随着函数调用的不同，指向会发生变化，总的指向原则，谁调用函数 this 指向谁。 ##"},{"id":"v-62a78390#数组对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#数组对象","pageTitle":"函数对象","headerTitle":"数组对象","text":"数组对象 - 概念：数组即一组任意类型或者相同类型的数据 - 数组的创建 - 构造函数创建数组对象 - 字面量创建数组对象 - 函数的下标和 length 属性 - 使用索引(index)下标来读取数组的值--下标是固定的，从 0 开始 - 数组的 length 属性 ，代表长度，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项 ###"},{"id":"v-62a78390#数组的方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#数组的方法","pageTitle":"函数对象","headerTitle":"数组的方法","text":"数组的方法 #### push()可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度 √ - 返回值：新数组的长度 - 示例：`[1, 2].push(3, 4)` 返回 `4` #### pop()从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项 √ - 返回值：被移除的项 - 示例：`[1, 2, 3].pop()` 返回 `3` #### unshift()可以接收任意数量的参数，把它们逐个添加到数组前面，并返回修改后数组的长度 - 返回值：新数组的长度 - 示例：`[2, 3].unshift(0, 1)` 返回 `4` #### shift()从数组前面移除一项，减少数组的 length 值，然后返回移除的项。 - 返回值：被移除的项 - 示例：`[1, 2, 3].shift()` 返回 `1` #### reverse()方法会反转数组项的顺序。 - 返回值：反转后的数组（修改原数组） - 示例：`[1, 2, 3].reverse()` 返回 `[3, 2, 1]` #### sort()方法按字母表升序排列数组项。 如果按其他方式而非字母表顺序进行数组排列，必须给 sort 方法传递一个比较函数做参数。√ - 返回值：排序后的数组（修改原数组） - 示例：`[3, 1, 2].sort()` 返回 `[1, 2, 3]`；`[3, 1, 2].sort((a, b) => b - a)` 返回 `[3, 2, 1]` #### concat()方可以基于当前数组中的所有项创建一个新数组，参数可以是数组项或者数组。 - 返回值：新数组（不修改原数组） - 示例：`[1, 2].concat([3, 4], 5)` 返回 `[1, 2, 3, 4, 5]` #### slice()方法基于当前数组中的一或多个项创建一个新数组。可以接受一或两个参数，起始和结束位置，不包括结束位置。 - 返回值：新数组（不修改原数组） - 示例：`[1, 2, 3, 4].slice(1, 3)` 返回 `[2, 3]` #### splice()方法对数组进行删除、插入、替换，是最强大的数组方法，返回值是数组，改变原数组(重要)。 - 返回值：被删除的项组成的数组（修改原数组） - 示例：`[1, 2, 3, 4].splice(1, 2, 'a', 'b')` 返回 `[2, 3]`，原数组变为 `[1, 'a', 'b', 4]` #### join()方法，将数组转换成对应的字符串。参数就是连接符。 - 返回值：字符串 - 示例：`[1, 2, 3].join('-')` 返回 `'1-2-3'` #### indexOf() 方法从数组的开头开始向后查找。√ - 返回值：找到的第一个元素的索引，未找到返回 `-1` - 示例：`[1, 2, 3, 2].indexOf(2)` 返回 `1` #### lastIndexOf() 方法则从数组的末尾开始向前查找。 - 返回值：找到的最后一个元素的索引，未找到返回 `-1` - 示例：`[1, 2, 3, 2].lastIndexOf(2)` 返回 `3` #### every()对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true - 返回值：布尔值 - 示例：`[2, 4, 6].every(x => x % 2 === 0)` 返回 `true` #### some()对数组中的每一项运行给定函数，如果该函数对任意一项返回 true，则返回 true - 返回值：布尔值 - 示例：`[1, 2, 3].some(x => x > 2)` 返回 `true` #### filter()对数组中的每一项运行给定函数，返回该函数结果为 true 的项组成的数组 √ - 返回值：新数组（不修改原数组） - 示例：`[1, 2, 3, 4].filter(x => x > 2)` 返回 `[3, 4]` #### map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组，返回就是数组，不考虑 true 或者 false√ - 返回值：新数组（不修改原数组） - 示例：`[1, 2, 3].map(x => x * 2)` 返回 `[2, 4, 6]` #### forEach()对数组中的每一项运行给定函数。这个方法没有返回值 √ - 返回值：`undefined` - 示例：`[1, 2, 3].forEach(x => console.log(x))` 依次输出 `1, 2, 3` #### reduce() 方法从数组的第一项开始，逐个遍历到最后 - 返回值：累加结果 - 示例：`[1, 2, 3, 4].reduce((sum, x) => sum + x, 0)` 返回 `10` #### reduceRight() 方法从数组的最后一项开始，向前遍历到第一项 - 返回值：累加结果 - 示例：`[1, 2, 3, 4].reduceRight((sum, x) => sum + x, 0)` 返回 `10` #### includes():查找字符串的是否存在某个字符，返回布尔值 √ - 返回值：布尔值 - 示例：`[1, 2, 3].includes(2)` 返回 `true` #### flat()方法，将多维数组扁平化为一维数组，参数是扁平的数组维度，可以设为 Infinity√ - 返回值：扁平化后的新数组（不修改原数组） - 示例：`[1, [2, [3, 4]]].flat(2)` 返回 `[1, 2, 3, 4]` #### Array.from():将对象转换成数组(数字做 key 值，具有 length 属性)，将类数组转真正的数组 √ - 返回值：新数组 - 示例：`Array.from('hello')` 返回 `['h', 'e', 'l', 'l', 'o']`；`Array.from({0: 'a', 1: 'b', length: 2})` 返回 `['a', 'b']` #### Array.isArray():确定括号中的某个值到底是不是数组 √ - 返回值：布尔值 - 示例：`Array.isArray([1, 2])` 返回 `true`；`Array.isArray('hello')` 返回 `false` - 值传递和引用传递 - 基本类型遵循值传递，引用类型遵循引用传递（地址传递） - 解决方式拷贝传值 ##"},{"id":"v-62a78390#对象-自定义对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#对象-自定义对象","pageTitle":"函数对象","headerTitle":"对象(自定义对象)","text":"对象(自定义对象) - 概念：一切皆对象，对象是属性的无序集合(属性值是函数，变成方法),可通过名字访问这些值. - 自定义对象的创建 - 构造函数创建对象 - 字面量创建对象 ###"},{"id":"v-62a78390#对象的特点","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#对象的特点","pageTitle":"函数对象","headerTitle":"对象的特点","text":"对象的特点 - 对象的属性名一定是字符串。 - 读写对象的属性值可以使用点和中括号,区别是点后面跟字符串，中括号里面可以是变量和字符串。 - 对象的属性值可以被覆盖的 - 对象的值是固定的，返回[object Object] ###"},{"id":"v-62a78390#对象的遍历","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#对象的遍历","pageTitle":"函数对象","headerTitle":"对象的遍历","text":"对象的遍历 - 因为对象是无序的，必须采用 for...in...遍历 ###"},{"id":"v-62a78390#对象的静态方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#对象的静态方法","pageTitle":"函数对象","headerTitle":"对象的静态方法","text":"对象的静态方法 #### Object.keys(obj) - 返回值：包含对象所有属性名的数组 - 示例：`Object.keys({name: 'Tom', age: 20})` 返回 `['name', 'age']` #### Object.values(obj) - 返回值：包含对象所有属性值的数组 - 示例：`Object.values({name: 'Tom', age: 20})` 返回 `['Tom', 20]` #### Object.entries - 返回值：包含对象所有 [键, 值] 对的二维数组 - 示例：`Object.entries({name: 'Tom', age: 20})` 返回 `[['name', 'Tom'], ['age', 20]]` ##"},{"id":"v-62a78390#字符串对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#字符串对象","pageTitle":"函数对象","headerTitle":"字符串对象","text":"字符串对象 ###"},{"id":"v-62a78390#包装对象的概念","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#包装对象的概念","pageTitle":"函数对象","headerTitle":"包装对象的概念","text":"包装对象的概念 - 当要操作字符串、数字、布尔值的属性时，js 会在内存中自动创建一个对象，用来对内置类 型进行包装，使内置类型暂时拥有普通对象功能，可以存取属性，一旦引用结束，包装对象自动销毁。 ###"},{"id":"v-62a78390#类数组的概念","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#类数组的概念","pageTitle":"函数对象","headerTitle":"类数组的概念","text":"类数组的概念 - 也叫伪数组，在 js 中有一些对象它也拥有 length 属性，且拥有为非负整数的属性(索引)，但是它又不能调用数组的方法，这种对象被称为类数组对象 ###"},{"id":"v-62a78390#字符串的方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#字符串的方法","pageTitle":"函数对象","headerTitle":"字符串的方法","text":"字符串的方法 #### substring():截取字符串 - 返回值：截取后的字符串 - 示例：`'hello'.substring(1, 4)` 返回 `'ell'` #### split():将字符串转换成数组 - 返回值：字符串分割后的数组 - 示例：`'a-b-c'.split('-')` 返回 `['a', 'b', 'c']` #### toUpperCase():将字符串转换大写字母 - 返回值：大写字母组成的新字符串 - 示例：`'hello'.toUpperCase()` 返回 `'HELLO'` #### toLowerCase():将字符串转换小写字母 - 返回值：小写字母组成的新字符串 - 示例：`'HELLO'.toLowerCase()` 返回 `'hello'` #### trim():去掉字符串首尾的空格 - 返回值：去掉首尾空格的新字符串 - 示例：`' hello '.trim()` 返回 `'hello'` #### indexOf()/lastIndexOf():查找字符串的索引位置，没有找到返回-1 - 返回值：找到的字符位置（整数）或 `-1` - 示例：`'hello'.indexOf('l')` 返回 `2`；`'hello'.lastIndexOf('l')` 返回 `3` #### includes():查找字符串的是否存在某个字符，返回布尔值 - 返回值：布尔值 - 示例：`'hello'.includes('el')` 返回 `true` #### charAt():通过索引位置返回对应的字符 - 返回值：字符（字符串） - 示例：`'hello'.charAt(1)` 返回 `'e'` #### charCodeAt():通过索引位置返回对应字符的 unicode 编码的值 - 返回值：Unicode 编码值（整数） - 示例：`'hello'.charCodeAt(0)` 返回 `104` #### String.fromCharCode():通过 unicode 编码返回对应的字符 - 返回值：对应的字符 - 示例：`String.fromCharCode(104, 101, 108, 108, 111)` 返回 `'hello'` #### substr():截取字符串，第二个参数表示截取的长度 - 返回值：截取后的字符串 - 示例：`'hello'.substr(1, 3)` 返回 `'ell'` #### slice():截取字符串 - 返回值：截取后的字符串 - 示例：`'hello'.slice(1, 4)` 返回 `'ell'` #### concat():根据当前的字符串生成新的字符串，参数可以是字符串或者变量 - 返回值：新字符串 - 示例：`'hello'.concat(' ', 'world')` 返回 `'hello world'` #### replace():替换字符串 - 返回值：替换后的新字符串 - 示例：`'hello'.replace('l', 'L')` 返回 `'heLlo'`（只替换第一个） #### match():查找匹配到的字符串，放入数组返回 - 返回值：匹配结果的数组或 `null` - 示例：`'hello123'.match(/\\d+/)` 返回 `['123']` #### search():查找第一个出现的字符的位置 - 返回值：字符位置或 `-1` - 示例：`'hello'.search('l')` 返回 `2` ###"},{"id":"v-62a78390#数组和字符串共有的方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#数组和字符串共有的方法","pageTitle":"函数对象","headerTitle":"数组和字符串共有的方法","text":"数组和字符串共有的方法 #### indexOf()/lastIndexOf():查找字符串的索引位置，没有找到返回-1 - 返回值：找到的位置（整数）或 `-1` - 示例：`'hello'.indexOf('l')` 返回 `2`；`[1, 2, 3].indexOf(2)` 返回 `1` #### slice():截取字符串 - 返回值：截取后的字符串或数组 - 示例：`'hello'.slice(1, 4)` 返回 `'ell'`；`[1, 2, 3, 4].slice(1, 3)` 返回 `[2, 3]` #### concat():根据当前的字符串生成新的字符串，参数可以是字符串或者变量 - 返回值：新字符串或新数组 - 示例：`'hello'.concat(' ', 'world')` 返回 `'hello world'`；`[1, 2].concat([3, 4])` 返回 `[1, 2, 3, 4]` #### includes():查找字符串的是否存在某个字符，返回布尔值 - 返回值：布尔值 - 示例：`'hello'.includes('el')` 返回 `true`；`[1, 2, 3].includes(2)` 返回 `true` ##"},{"id":"v-62a78390#数学对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#数学对象","pageTitle":"函数对象","headerTitle":"数学对象","text":"数学对象 - 数学对象的概念：单体内置对象( Global 和 Math),由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。\"意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。 ###"},{"id":"v-62a78390#数学的方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#数学的方法","pageTitle":"函数对象","headerTitle":"数学的方法","text":"数学的方法 #### Math.round() ：将括号里面的数字采用四舍五入形式取整。 - 返回值：取整后的整数 - 示例：`Math.round(4.5)` 返回 `5`；`Math.round(4.4)` 返回 `4` #### Math.abs()：求绝对值 - 返回值：绝对值 - 示例：`Math.abs(-5)` 返回 `5` #### Math.ceil()：将括号里面的小数采用向上取整 - 返回值：向上取整后的整数 - 示例：`Math.ceil(4.1)` 返回 `5` #### Math.floor()：将括号里面的小数采用向下取整 - 返回值：向下取整后的整数 - 示例：`Math.floor(4.9)` 返回 `4` #### Math.pow()：求幂，第一个参数是底数，第二个参数是指数。 - 返回值：幂运算结果 - 示例：`Math.pow(2, 3)` 返回 `8` #### Math.max()：求括号里面数字的最大值，数字之间逗号隔开。 - 返回值：最大值 - 示例：`Math.max(3, 1, 4, 1, 5)` 返回 `5` #### Math.min()：求括号里面数字的最小值，数字之间逗号隔开。 - 返回值：最小值 - 示例：`Math.min(3, 1, 4, 1, 5)` 返回 `1` #### Math.sqrt()：开根号。 - 返回值：平方根结果 - 示例：`Math.sqrt(16)` 返回 `4` #### Math.random()：随机数 -- [0,1) - 返回值：0 到 1 之间的随机小数 - 示例：`Math.random()` 可能返回 `0.7231234567` #### Math.PI：表示 π(3.14) - 返回值：π 的值 - 示例：`Math.PI` 返回 `3.141592653589793` ##"},{"id":"v-62a78390#日期对象","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#日期对象","pageTitle":"函数对象","headerTitle":"日期对象","text":"日期对象 - 日期对象的概念：ECMAScript 中的 Date 类型是在早期 Java 中的类基础上构建的。Date 类型使用自 UTC（国际协调时间）1970 年 1 月 1 日午夜零时开始经过的毫秒数来保存日期。 ###"},{"id":"v-62a78390#日期对象的方法","path":"/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.html#日期对象的方法","pageTitle":"函数对象","headerTitle":"日期对象的方法","text":"日期对象的方法 #### getTime()返回表示日期的毫秒数；与 valueOf() 方法返回的值相同 - 返回值：毫秒数（整数） - 示例：`new Date('2023-01-01').getTime()` 返回 `1672531200000` #### getFullYear()取得 4 位数的年份（如 2007 而非仅 07） - 返回值：年份（四位数） - 示例：`new Date('2023-01-01').getFullYear()` 返回 `2023` #### setFullYear()设置日期的年份。传入的年份值必须是 4 位数字（如 2007 而非仅 07） - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setFullYear(2024);` 将年份设置为 `2024` #### getMonth()返回日期中的月份，其中 0 表示一月，11 表示十二月 - 返回值：月份（0-11） - 示例：`new Date('2023-03-15').getMonth()` 返回 `2` #### setMonth()设置日期的月份。传入的月份值必须大于 0，超过 11 则增加年份 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setMonth(11);` 将月份设置为十二月 #### getDate()返回日期月份中的天数（1 到 31） - 返回值：天数（1-31） - 示例：`new Date('2023-03-15').getDate()` 返回 `15` #### setDate()设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setDate(20);` 将天数设置为 `20` #### getDay()返回日期中星期的星期几（其中 0 表示星期日，6 表示星期六） - 返回值：星期几（0-6） - 示例：`new Date('2023-01-01').getDay()` 返回 `0`（星期日） #### getHours()返回日期中的小时数（0 到 23） - 返回值：小时数（0-23） - 示例：`new Date('2023-01-01 14:30:00').getHours()` 返回 `14` #### setHours()设置日期中的小时数。传入的值超过了 23 则增加月份中的天数 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setHours(18);` 将小时设置为 `18` #### getMinutes()返回日期中的分钟数（0 到 59） - 返回值：分钟数（0-59） - 示例：`new Date('2023-01-01 14:30:00').getMinutes()` 返回 `30` #### setMinutes()设置日期中的分钟数。传入的值超过 59 则增加小时数 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setMinutes(45);` 将分钟设置为 `45` #### getSeconds()返回日期中的秒数（0 到 59） - 返回值：秒数（0-59） - 示例：`new Date('2023-01-01 14:30:45').getSeconds()` 返回 `45` #### setSeconds()设置日期中的秒数。传入的值超过了 59 会增加分钟数 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setSeconds(30);` 将秒数设置为 `30` #### getMilliseconds()返回日期中的毫秒数 - 返回值：毫秒数（0-999） - 示例：`new Date('2023-01-01 14:30:45.500').getMilliseconds()` 返回 `500` #### setMilliseconds() 设置日期中的毫秒数 - 返回值：设置后的毫秒数 - 示例：`let d = new Date(); d.setMilliseconds(999);` 将毫秒数设置为 `999` #### Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数 - 返回值：解析后的毫秒数，解析失败返回 `NaN` - 示例：`Date.parse('2023-01-01')` 返回 `1672531200000`"},{"id":"v-081edea9","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":null,"text":"## **"},{"id":"v-081edea9#如何让元素水平垂直居中-最多问到","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#如何让元素水平垂直居中-最多问到","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"如何让元素⽔平垂直居中（最多问到）","text":"如何让元素⽔平垂直居中（最多问到）** 1. 定位偏移 top，left 为 50%，margin-left，margin-top 为⼩元素的-50% 2. 定位平均 top，left，bottom，right 为 0，margin 为 auto 3. 定位平移 top，left 为 50%，transform：translate(⼩元素的 50%) 4. 弹性盒 主轴与交叉轴居中 5. 表格 ⽗ block，⼦ table-cell ## **"},{"id":"v-081edea9#flex-的几个默认属性","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#flex-的几个默认属性","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"flex 的⼏个默认属性","text":"flex 的⼏个默认属性** 问三个答划线三个： 第⼀个值为默认值 flex-direction: row 横 | column | 主轴⽅向 flex-wrap: nowrap 不换⾏ | wrap | wrap-reverse 是否⾃动换⾏ justify-content: flex-start 左或上 | flex-end | center |space-between | space-around 主轴对⻬⽅式 align-items: stretch ⾼度不设置则占满 | flex-start | flex-end | center | baseline 交叉轴对⻬⽅式 flex-shrink: 默认 1，空间不⾜按⽐缩⼩，设为 0 不缩⼩ flex-basis: 默认 auto，占据主轴多少空间 flex-grow：默认为 0，属性定义项⽬的放⼤⽐例，即如果存在剩余空间，也不放⼤。 flex: 0 1 auto， ## **"},{"id":"v-081edea9#清除浮动","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#清除浮动","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"清除浮动","text":"清除浮动** 1. 给高度塌陷的元素加 overflow: hidden （触发 BFC） 2. 给高度塌陷的元素里面的最下面加一个空 div，div 属性 clear:both 3. 万能清除法 div::after{ content:''; height:0; overflow:hidden; visibility:hidden; display:block; clear:both; } ## **"},{"id":"v-081edea9#回流重绘","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#回流重绘","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"回流重绘","text":"回流重绘** **_什么是回流_** 当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建 render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 **_什么是重绘_** 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。 ## **"},{"id":"v-081edea9#本地存储-缓存","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#本地存储-缓存","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"本地存储 缓存","text":"本地存储 缓存** 1.存储大小 cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 2.有效时间 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 3. 数据与服务器之间的交互方式 cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 ## **"},{"id":"v-081edea9#css-盒模型的理解","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#css-盒模型的理解","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"Css 盒模型的理解","text":"Css 盒模型的理解** 当对⼀个⽂档进⾏布局的时候，浏览器的渲染引擎会将所有元素表示为⼀个个矩形的盒⼦。CSS 决定这些盒⼦的⼤⼩、位置以及属性（例如颜⾊、背 景、边框尺⼨… 盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。 ⽽ IE 怪异盒模型 width 的宽度并不是 content 的宽度，⽽是 border + padding + content 的宽度值 元素占据的宽度 = margin+ width ##"},{"id":"v-081edea9#bfc","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#bfc","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"BFC","text":"BFC - 概念： BFC 块状格式化上下文 （block formatting context），是一个独立空间，只有块状元素参与，规定了里面的块状元素如何布局，与外界毫不相干 - 如何触发 BFC 1. 根元素 html 2. float 除了 none 选项之外 3. position : absolute/fixed 4. display: inline-block/table-cell/flex/inline-flex 5. overflow 除了 visible 选项之外 - BFC 布局规则 1. 内部的块状元素从上往下排列 2. 垂直方向的距离由 margin 控制 属于同一个 BFC 的元素，上下 margin 会重叠 3. 每个元素的 margin-left 会和父元素的 border-left 相接触 4. BFC 的区域不会和浮动元素相重叠 5. BFC 区域和外界空间毫不相干 6. 计算 BFC 元素高度，浮动元素也参与计算 - BFC 应用 1. 两栏布局 2. 清除 margin 重叠 3. 清除浮动 ## **"},{"id":"v-081edea9#常见浏览器兼容问题","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#常见浏览器兼容问题","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"常见浏览器兼容问题？","text":"常见浏览器兼容问题？** 1、不同浏览器下的 padding 和 margin 不同 解决方法：使用通配符(\\*)将 padding 和 margin 设置为 0 2、块属性标签 float 之后，又有横向的 margin 值，在 IE6 中显示会比设置的大（IE6 双边距 bug） 解决方法：在 float 标签样式控制中加入 display:inline; 3、设置较小的高度标签（一般小于 10px），在 IE6，IE7，遨游中超出自己设置的高度 解决方法：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。 4、行内标签设置 display:block;后又采用 float 布局，再设置横向 margin 值时，在 IE6 中显示会比设置的大（IE6 双边距 bug） 解决方法：在 display:block;后面加上 display:inline;display:table; ##"},{"id":"v-081edea9#手机端上图片长时间点击会选中图片-如何处理","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#手机端上图片长时间点击会选中图片-如何处理","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"手机端上图片长时间点击会选中图片，如何处理？","text":"手机端上图片长时间点击会选中图片，如何处理？ img{ pointer-events:none }，禁止事件，但会把整个标签的事件都禁用掉，不建议使用 img{ -webkit-user-select:none }，用户选中状态 推荐： img{ -webkit-touch-callout: none; //触摸 -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } ##"},{"id":"v-081edea9#清除图片间隙","path":"/Html+Css/%E9%9D%A2%E8%AF%95.html#清除图片间隙","pageTitle":"如何让元素⽔平垂直居中（最多问到）","headerTitle":"清除图片间隙","text":"清除图片间隙 - 清除图片左右的间隙 - 将图片挨着写（中间没有空格，也没有回车） - 将图片的父元素的 font-size 设置成 0 - 给图片设置浮动 - 清除图片的上下间距 - 将图片设置成 display: block - 给图片设置 vertical-align: top / middle / bottom"},{"id":"v-5e7589e2","path":"/","pageTitle":"Home","headerTitle":null,"text":"<ParticleBackground /> <div class=\"custom-hero\"> <p class=\"hero-title\"> 技术成长之路 </p> <p class=\"hero-tagline\">一个前端开发者的笔记，记录、分享、成长.</p> <RouterLink to=\"/Html+Css/\" class=\"hero-button\"> 快速开始 → </RouterLink> </div> <!-- --- home: true heroImage: /R-C.png heroText: 技术成长之路 tagline: 记录前端开发的点点滴滴 actionText: 快速上手 → actionLink: /Html+Css/ # features: # - title: 系统化学习 # details: 从基础到进阶，构建完整知识体系 # - title: 实战案例 # details: 结合真实项目，掌握核心开发技能 # - title: 持续更新 # details: 跟踪技术前沿，保持内容最新 footer: MIT Licensed | Copyright © 2023-present 贾滨旭 --- <VantaBackground /> -->"},{"id":"v-54ff7a0f","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html","pageTitle":"常见面试题","headerTitle":null,"text":"# 常见面试题 ##"},{"id":"v-54ff7a0f#基础算法","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#基础算法","pageTitle":"常见面试题","headerTitle":"基础算法","text":"基础算法 ###"},{"id":"v-54ff7a0f#算法实现对象中-url-拼接成数组","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#算法实现对象中-url-拼接成数组","pageTitle":"常见面试题","headerTitle":"算法实现对象中 url 拼接成数组","text":"算法实现对象中 url 拼接成数组 ```JavaScript const sidebarMenus = [ { url: \"\", children: [ { url: \"/app\", children: [ { url: \"/:id/info\", children: [], }, { url: \"/:id/detail\", children: [ { url: \"/group\", }, ], }, ], }, ], }, ]; ['', '/app', '/app/:id/info', '/app/:id/detail', '/app/:id/detail/group']; function fn(arr, currentPath = \"\") { let result = []; arr.forEach((element) => { const newPath = currentPath + element.url; // 当前节点的新路径 result.push(newPath); // 无论是否有子节点，都记录当前路径 // 递归处理子节点，并合并结果(注意：element.children最后一个children中并没有children属性，需要判断是否存在children属性) if (element.children && element.children.length > 0) { result = result.concat(fn(element.children, newPath)); } }); return result; } ``` ###"},{"id":"v-54ff7a0f#过滤出对象数组中符合条件的数组","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#过滤出对象数组中符合条件的数组","pageTitle":"常见面试题","headerTitle":"过滤出对象数组中符合条件的数组","text":"过滤出对象数组中符合条件的数组 - 年龄大于等于 18 岁的用户 - 将用户姓名转换为大写 - 按照年龄升序排序 - 返回处理后的新数组 ```JavaScript const users = [ { name: \"alice\", age: 22 }, { name: \"bob\", age: 17 }, { name: \"charlie\", age: 19 }, { name: \"david\", age: 15 }, ]; function fn(users) { let result result = users.filter(item => { return item.age >= 18; }).map(item =>{ return {...item,name:item.name.toUpperCase()} }).sort((a,b)=>{ return a.age - b.age; }) return result; } ``` ##"},{"id":"v-54ff7a0f#常见函数原理","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#常见函数原理","pageTitle":"常见面试题","headerTitle":"常见函数原理","text":"常见函数原理 ###"},{"id":"v-54ff7a0f#call-函数的实现","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#call-函数的实现","pageTitle":"常见面试题","headerTitle":"call()函数的实现","text":"call()函数的实现 第一个参数为 null 或者 undefined 时，this 指向全局对象 window，值为原始值的指向该原始值的自动包装对象，如 String、Number、Boolean 为了避免函数名与上下文(context)的属性发生冲突，使用 Symbol 类型作为唯一值 将函数作为传入的上下文(context)属性执行 函数执行完成后删除该属性 返回执行结果 call 函数实例： ```JavaScript var obj = { value: 1 }; function bar() { console.log(this.value); } bar.call(obj); // 1 ``` - 模拟实现该效果 试想当调用 call 的时候，把 obj 对象改造成如下： ```JavaScript var obj = { value: 1, bar: function() { console.log(this.value) } }; obj.bar(); // 1 ``` 这个时候 this 就指向了 obj,但是也为 obj 添加了一个多余的属性，所以需要删除多余的属性 ```JavaScript // 第一步 obj.fn = bar // 第二步 obj.fn() // 第三步 delete obj.fn ``` myCall 函数中的 this 指向 fn，所以把 obj.fn = this（myCall 中的 this） - 注意 return，函数可以有返回值 判断传入参数 context 可能存在多个参数，解构多个参数 ```JavaScript Function.prototype.myCall = function(context,...args){ let cxt = context || window; //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this) //新建一个唯一的Symbol变量避免重复 let func = Symbol() cxt[func] = this; args = args ? args : [] //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向 const res = args.length > 0 ? cxt[func](...args) : cxt[func](); //删除该方法，不然会对传入对象造成污染（添加该方法） delete cxt[func]; return res; } ``` ###"},{"id":"v-54ff7a0f#实现-promisealsettled-方法","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#实现-promisealsettled-方法","pageTitle":"常见面试题","headerTitle":"实现 PromisealSettled()方法","text":"实现 PromisealSettled()方法 - 说明：PromisealSettled() 方法返回一个 Promise，该 Promise 在所有给定的 Promise 都已经成功解决(fulfilled) 或拒绝(rejected)之后解决，并返回一个对象数组，每个对象都描述了每个 Promise 的结果。与 Promise 不同的是, Promise.all 一旦遇到错误就会立即拒绝，而 PromisealSettled 则会等待所有 Promise 都结束(无论成功还是失败) ```JavaScript ``` ###"},{"id":"v-54ff7a0f#实现一个简单的promise","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#实现一个简单的promise","pageTitle":"常见面试题","headerTitle":"实现一个简单的Promise","text":"实现一个简单的Promise 思考:首先要手写一个promise就需要思考原生的promise执行的过程是什么样的？ - Promise 三个状态，pending ，fulfilled(resolve)，reject 只能从pending>fulfilled 只能从pending>reject 并且状态一单改变就会凝固不能再被改变 我们先来看看原生promise的使用 ```JavaScript let p = new Promise((resolve,reject)=>{ resolve(result) }) p.then((result)=>{ console.log(\"result\") }) ``` - 在promise类中 我们可以看到，他接受一个参数，在promiseA+范式中 我们把它称作executor(执行器),executor的执行是同步的， 我们还需要准备resolve和reject方法，以及他的三个状态，并添加判断只有是pending状态的时候才可以去改变状态 创建出执行队列以便异步操作使用 注意：这里使用#state,# 的作用的是防止从外部直接修改类内部的状态 ```JavaScript // Promise 的三种状态常量 const PENDING = 'pending'; // 等待状态 const FULFILLED = 'fulfilled'; // 成功状态 const REJECTED = 'rejected'; // 失败状态 class MyPromise { // 私有属性，使用 # 前缀表示 #state = PENDING; // 当前状态，初始为 pending #value = undefined; // 成功时保存的值 #reason = undefined; // 失败时保存的原因 /** * 构造函数 * @param {Function} executor 执行器函数，接收 resolve 和 reject 两个参数 */ constructor(executor) { // 定义 resolve 函数 const resolve = (value) => { // 只有 pending 状态可以转换 if (this.#state === PENDING) { this.#state = FULFILLED; // 转换状态 this.#value = value; // 保存值 // 执行所有成功回调 this.#onFulfilledCallbacks.forEach(cb => cb()); this.#onFulfilledCallbacks = []; // 清空队列 } }; // 定义 reject 函数 const reject = (reason) => { // 只有 pending 状态可以转换 if (this.#state === PENDING) { this.#state = REJECTED; // 转换状态 this.#reason = reason; // 保存原因 // 执行所有失败回调 this.#onRejectedCallbacks.forEach(cb => cb()); this.#onRejectedCallbacks = []; // 清空队列 } }; try { // 立即执行 executor executor(resolve, reject); } catch (error) { // 如果执行器抛出异常，直接 reject reject(error); } } } ``` 此时实现了最基本的 Promise 骨架，但缺少： - then 方法实现 - 链式调用支持 - 异步处理能力 我们来一个一个解决他们，首先我们来为类添加一个then方法 在我们使用的时候可能只会使用到他的第一个参数，也就是获取成功的结果， 但是其实在A+范式中他是有两个参数onFulfilled, onRejected ```JavaScript class MyPromise { #state = PENDING; // 私有状态字段 #value = null; // 成功值 #reason = null; // 失败原因 constructor(executor) { const resolve = (value) => { if (this.#state === PENDING) { this.#state = FULFILLED; this.#value = value; } }; const reject = (reason) => { if (this.#state === PENDING) { this.#state = REJECTED; this.#reason = reason; } }; try { executor(resolve, reject); } catch (error) { reject(error); } } then(onFulfilled, onRejected) { // 参数校验 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value; onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; }; if (this.#state === FULFILLED) { setTimeout(() => { onFulfilled(this.#value); }); } else if (this.#state === REJECTED) { setTimeout(() => { onRejected(this.#reason); }); } } } ``` 异步的处理 异步处理的核心：添加成功/失败队列，当触发then/catch(目前还没有添加catch方法)的时候 先把要执行的onFulfilled, onRejected函数添加到队列当中，只有触发了resolve方法在取出存储的方法并执行 ```JavaScript then(onFulfilled, onRejected) { // ...参数校验同上... // 添加回调队列 if (this.#state === PENDING) { this.#onFulfilledCallbacks.push(() => { setTimeout(() => { onFulfilled(this.#value); }); }); this.#onRejectedCallbacks.push(() => { setTimeout(() => { onRejected(this.#reason); }); }); } } ``` 现在我们为类添加了一个基础的then，我们又会发现新的问题 没有返回新的 Promise，无法链式调用 解决：链式调用的核心处理思想就是return一个新的promise ```JavaScript then(onFulfilled, onRejected) { // ...参数校验同上... // 返回新的 Promise 以实现链式调用 const promise2 = new newPromise((resolve,reject)=>{ //链式调用的核心，promise.then需要返回一个新的promise，才能链式接着. if (this.#state === FULFILLED) { setTimeout(()=>{ // 注意：这里的代码需要是异步的因为如果deepPromise中的代码是同步的 resolvePromise中需要传deepPromise，还没有生成完就传会报错 let result = onFulfilled(this.#value); // 这里获取到当前.then回调的返回值 resolvePromise(result,resolve,reject,deepPromise); // 执行下一次的resolve,并且判断可能return promise的情况 如果是promise 需要把值传递给promise }) } if (this.#state === REJECT) { let rej = onRejected(this.#value); reject(rej); } if(this.#state === PENDING){//异步的核心代码，当触发then方法的时候把执行函数放在队列中，触发了resolve/reject的时候再去执行 this.#onResolveCallbacks.push(()=>{ onFulfilled(this.#value); }) this.#onRejectedCallbacks.push(()=>{ onRejected(this.#value); }) } }) return promise2; } ``` 这个时候，我们需要去解析判断一下传进来的x，而不是直接传进去，他有可能是promise对象，我们来添加一个解析promise的函数 ```JavaScript /** * 用于判断return类型是promise还是普通值 * @param result 判断的对象 * @param resolve result为promise的情况要执行的resolve * @param reject result为promise的情况要执行的reject * @param deepPromise 用来解决return自己的错误 * @return {number} 数组的总和 */ function resolvePromise(result,resolve,reject,deepPromise){ if(result === deepPromise){ reject(new TypeError(`Uncaught TypeError TypeError: Chaining cycle detected for promise #<Promise> --- Promise.then ---`)) // } if(result instanceof newPromise){ // 简写(value=>resolve(value), err => reject(err)) 等同于(resolve,reject) // result.then(value=>resolve(value), err => reject(err)) result.then(resolve,reject); } else{ resolve(result) } } } ``` 判断过后我们来整合一下现在的then方法 ```JavaScript then = function (onFulfilled, onRejected) { // 参数校验 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value; onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; }; let deepPromise = new newPromise((resolve,reject)=>{ //链式调用的核心，promise.then需要返回一个新的promise，才能链式接着. if (this.#state === FULFILLED) { setTimeout(()=>{ // 注意：这里的代码需要是异步的因为如果deepPromise中的代码是同步的 resolvePromise中需要传deepPromise，还没有生成完就传会报错 let result = onFulfilled(this.#value); // 这里获取到当前.then回调的返回值 resolvePromise(result,resolve,reject,deepPromise); // 执行下一次的resolve,并且判断可能return promise的情况 如果是promise 需要把值传递给promise }) } if (this.#state === REJECT) { let rej = onRejected(this.#value); reject(rej); } if(this.#state === PENDING){//异步的核心代码，当触发then方法的时候把执行函数放在队列中，触发了resolve/reject的时候再去执行 this.#onResolveCallbacks.push(()=>{ onFulfilled(this.#value); }) this.#onRejectedCallbacks.push(()=>{ onRejected(this.#value); }) } }) return deepPromise; }; ``` 到这里就实现了一个简单的promise，其中还缺乏了很多校验和静态方法，只作为理解promise使用。 ##"},{"id":"v-54ff7a0f#leetcode-系列","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#leetcode-系列","pageTitle":"常见面试题","headerTitle":"leetCode 系列","text":"leetCode 系列 ###"},{"id":"v-54ff7a0f#无重复字符的最长子串-力扣华为面试题库-中等难度","path":"/JavaScript/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98.html#无重复字符的最长子串-力扣华为面试题库-中等难度","pageTitle":"常见面试题","headerTitle":"无重复字符的最长子串(力扣华为面试题库-中等难度)","text":"无重复字符的最长子串(力扣华为面试题库-中等难度) - 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 - 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 - 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 1. 题解 1：暴力解法 双重 for 循环双指针移动，存储结果找到最长字串（O(n²)复杂度） ```JavaScript var lengthOfLongestSubstring = function (s) { if(s.length === 1)return 1; let str = \"\"; const len = s.length; for (let i = 0; i < s.length; i++) { let currentStr = s[i]; for (let j = i + 1; j < len; j++) { if (currentStr.indexOf(s[j]) !== -1) { break; } else { currentStr += s[j]; } } if (currentStr.length > str.length) str = currentStr; } return str.length; }; ``` 2. 题解 2：使用滑块思想，移动滑块存储当前最长字符串（O(n²)复杂度） ```JavaScript var lengthOfLongestSubstring = function (s) { let str = \"\"; let len = s.length; if (len === 1) return 1; for (let i = 0; i < len; i++) { let currentStr = s[i]; let j = i + 1; while (currentStr.indexOf(s[j]) == -1) { currentStr += s[j]; j++; // 处理越界 if (j >= len) { j = len - 1; } } if (currentStr.length > str.length) str = currentStr; // 如果j走到头了就不用判断了 if (j === len - 1) { break; } i = s.indexOf(s[j], i); } return str.length; }; ``` 3. 题解 3：使用滑块思想+Set 结构去除重复值（O(n)复杂度） ```JavaScript var lengthOfLongestSubstring = function (s) { let seen = new Set(); // 存储当前窗口的字符 let left = 0, maxLen = 0; for (let right = 0; right < s.length; right++) { while (seen.has(s[right])) { seen.delete(s[left]); left++; } seen.add(s[right]); maxLen = maxLen > seen.size ? maxLen : seen.size; } return maxLen; }; ```"},{"id":"v-84a86fb6","path":"/JavaScript/","pageTitle":"JavaScript","headerTitle":null,"text":"# JavaScript ##"},{"id":"v-84a86fb6#闭包原理-优点-缺点-使用场景","path":"/JavaScript/#闭包原理-优点-缺点-使用场景","pageTitle":"JavaScript","headerTitle":"闭包原理/优点/缺点/使用场景","text":"闭包原理/优点/缺点/使用场景 1. 什么是闭包（外层函数调用时，外层函数的函数作用域对象被内层函数引用着，无法释放，就形成了闭包。） - 函数嵌套函数 - 内层函数中使用了外层函数的变量或参数 - 内层函数作为返回值返回到外部 2. 优缺点 优点： - 保护具有共享意义的变量 - 隔离作用域 避免(全局)作用域污染 - 为变量提供访问和操作的相关接口 - 便于进行模块化开发 - 减少形参个数，延长了形参的生命周期 缺点： 占用过多的资源(内存) 大量使用不利于代码优化 【解决方式：清除变量】 3. 闭包的应用场景 - 通过循环给页面上多个 dom 节点绑定事件 - 封装私有变量(计数器) - 延续局部变量的寿命 - 高阶组件 - [函数防抖/节流](#防抖节流) - [柯里化](#函数柯里化) 4. 闭包原理 内层函数通过作用域链使用了外层函数的变量或参数，从而导致内存无法释放，需要手动设置为 null 进行清除 模块化就是以闭包为基础构建的; ##"},{"id":"v-84a86fb6#promise","path":"/JavaScript/#promise","pageTitle":"JavaScript","headerTitle":"promise","text":"promise - ES6-Promise(承诺) Promise 异步编程的一种解决方案，比传统的解决方案（回调函数）更合理和更强大。 Promise 可以解决回调地狱的问题 - 状态 Promise 对象代表一个异步操作，有三种状态：pending 进行中、fulfilled(resolve)成功、rejected 失败 Promise 一旦状态设定，就不会再变. Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected,只要这两种情况发生，状态就凝固了。 - 编写 promise ```js let promise = new Promise((resolve, reject) => { //resolve 成功 reject 失败 resolve(); //设定成功，找 promise 下面的 then 方法,resolve 传递参数值给 then reject(); //设定失败，找 promise 下面的 catch 方法,reject 传递参数值给 catch }); ``` - promise 原型下面两个方法 - then 方法的作用：resolve 函数将 Promise 对象的状态从“未完成”变为“成功”，找 then 方法，将 resolve 函数的参数值传递给 then 方法。 - catch 方法的作用：reject 函数将 Promise 对象的状态从“ 未完成” 变为“ 失败”，找 catch 方法，将 reject 函数的参数值传递给 catch 方法。 ```js promise .then((data) => { console.log(\"11111111\"); }) .catch(() => { console.log(\"22222222\"); }); ``` Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，所有的 promise 成功才成功，只要有一个失败了那就是失败 使用场景：发送多个请求并根据请求顺序获取和使用数据 Promise.race():是一个数组，返回一个新的 promise，第一个完成的状态就是结果状态 - 缺点： 一旦新建立即执行，无法中途取消 pending 状态时，无法知道当前处于哪一个状态，是开始还是结束 不设置回调，内部抛出的错误，不会反应到外部 ###"},{"id":"v-84a86fb6#promise-async-await-以及两者区别","path":"/JavaScript/#promise-async-await-以及两者区别","pageTitle":"JavaScript","headerTitle":"promise async await 以及两者区别","text":"promise async await 以及两者区别 - Promise 概念： - Promise 是用来做异步的，Promise 好比容器，里面存放着一些异步的事件的结果，而这些结果一旦生成是无法改变的 - Promise 的出现解决了传统 callback 函数导致的“地域回调”问题 - async await 概念： - async await 也是异步编程的一种解决方案，拥有 promise 的风格，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，async 修饰过的函数也有 then 和 catch ⽅法，await 只能放在 async 中，只能修饰 promise 对象.它返回的是一个 Promise 对象。 - 两者的区别： - Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。 - async await 与 Promise 一样，是非阻塞的。 - async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。 ##"},{"id":"v-84a86fb6#设计模式-发布订阅模式-单例模式","path":"/JavaScript/#设计模式-发布订阅模式-单例模式","pageTitle":"JavaScript","headerTitle":"设计模式 - 发布订阅模式 - 单例模式","text":"设计模式 - 发布订阅模式 - 单例模式 发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 发布订阅模式的基础实现 ```JS // 利用发布订阅模式实现自定义事件(买菜，买车，买房子...) // 例如：买菜 - 买青菜，买白菜，买番茄..... // this.message['买菜'] = [function(){买青菜},function(){买白菜}...] // this.message['买车'] = [function(){买宝马},function(){买奔驰}...] // this.message['买房'] = [function(){买别墅},function(){买大平层}...] // 买菜：事件类型 + 事件处理函数 //利用Observer进行自定义事件的开发。 //添加事件 - on //执行事件 - emit //删除事件 - remove class Ob { constructor() { this.message = []; //记录事件的记事本 } // 添加事件 - on // type:事件类型 fn:事件处理函数。 type事件类型存在追加，不存在创建。 on(type, fn) { if (!this.message[type]) { //不存在创建 this.message[type] = [fn]; } else { //存在追加 this.message[type].push(fn); } } // 执行事件 - emit emit(type) { if (!this.message[type]) return; //事件类型不存在，退出 this.message[type].forEach((item) => { item(); }); } // 删除事件 - remove - 事件类型，那个事件处理函数 remove(type, fn) { if (!this.message[type]) return; //事件类型不存在，退出 for (let i = 0; i < this.message[type].length; i++) { if (this.message[type][i] == fn) { this.message[type].splice(i, 1); //改变原数组 i--; } } } } function fn1() { console.log(\"买奔驰\"); } function fn2() { console.log(\"买宝马\"); } function fn3() { console.log(\"买奥迪\"); } function fn4() { console.log(\"买白菜\"); } let observer = new Ob(); observer.on(\"买车\", fn1); //绑定事件 observer.on(\"买车\", fn2); observer.on(\"买车\", fn3); observer.on(\"cai\", fn4); observer.remove(\"买车\", fn2); //删除事件 observer.emit(\"买车\"); //执行事件 observer.emit(\"cai\"); ``` 单例模式 单例模式就是一个实例在整个网页的生命周期里只创建一次，后续再调用实例创建函数的时候，返回的仍是之前创建的实例。在实际开发中应用十分广泛，例如页面中的登录框，显示消息的提示窗 ##"},{"id":"v-84a86fb6#es6-新增了那些语法","path":"/JavaScript/#es6-新增了那些语法","pageTitle":"JavaScript","headerTitle":"Es6 新增了那些语法","text":"Es6 新增了那些语法 1. let 和 const 2. 解构赋值 let{一一对应} = {一一对应} 3. 扩展运算符... 将数组拆分成一个一个数字的形式 4. 模板字符串 `` 5. 箭头函数 ()=>{} 6. promise 概述和应用 7. class 面向对象的一种写法 比原型+构造函数好 8. 模块化 - export/import/解构赋值 9. async+await promise 的语法糖 10. for...of... 最好的遍历方式 不能遍历对象 遍历对象用 for in 11. 对象的简写风格 - 如果属性名和属性值名称相同，写一个。 - 属性值是函数可以省略 function ###"},{"id":"v-84a86fb6#let-const-var-区别","path":"/JavaScript/#let-const-var-区别","pageTitle":"JavaScript","headerTitle":"let const var 区别","text":"let const var 区别 - let 关键字 - 块作用域，声明的变量绑定在这个区域里面。 - 不存在变量提升(暂时性死区：先声明再使用)。 - 相同的作用域内不能重复声明(熟悉报错:Identifier 'a' has already been declared) - var 关键字 - 局部和全局作用域，函数内部是局部，函数外面是全局。 - 变量提升 - 相同的作用域内可以重复声明 - 预解析(1.预编译 var,function 2.代码逐行执行) - var 声明的变量也是 window 的属性 - const 关键字 - 声明的常量值不能被改变 - 对象的值不能改变，对象里面的属性可以改变的。 - 使用场景(存储不变的值，存储函数，存储元素对象，存储对象) ###"},{"id":"v-84a86fb6#箭头函数和普通函数有什么差异","path":"/JavaScript/#箭头函数和普通函数有什么差异","pageTitle":"JavaScript","headerTitle":"箭头函数和普通函数有什么差异？","text":"箭头函数和普通函数有什么差异？ - 相比普通函数更简洁的语法 - 没有 this,捕获其所在上下文的 this 值，作为自己的 this 值 - 不能使用 new,箭头函数作为匿名函数,是不能作为构造函数的,不能使用 new - 不绑定 arguments，用 rest 参数...解决 let test3=(...a)=>{console.log(a[1])} //22 - 使用 call()和 apply()调用:由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响： - 箭头函数没有原型属性 - 不能简单返回对象字面量 let fun5 = ()=>({ foo: x }) //如果 x => { foo: x } //则语法出错 - 箭头函数不能当做 Generator 函数,不能使用 yield 关键字 - 箭头函数不能换行 ```JS let a = () =>1; //SyntaxError: Unexpected token => ``` - 使用箭头函数应该注意什么？ - 不要在对象里面定义函数，对象里面的行数应该用传统的函数方法 - 不要在对原型对象上定义函数，在对象原型上定义函数也是遵循着一样的规则 - 不要用箭头定义构造函数 - 不要用箭头定义事件回调函数 ###"},{"id":"v-84a86fb6#for-in-for-of-的区别","path":"/JavaScript/#for-in-for-of-的区别","pageTitle":"JavaScript","headerTitle":"for in. for of 的区别","text":"for in. for of 的区别 1. for...in 循环：只能获得对象的键名，不能获得键值，for...of 循环：允许遍历获得键值 2. 对于普通对象，没有部署原生的 iterator 接口，直接使用 for...of 会报错，可以使用 for...in 循环遍历键名 3. for...in 循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键。for...of 则不会这样 4. 无论是 for...in 还是 for...of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法 ##"},{"id":"v-84a86fb6#异步解决方案有哪些-回调函数-callback-promise-generator","path":"/JavaScript/#异步解决方案有哪些-回调函数-callback-promise-generator","pageTitle":"JavaScript","headerTitle":"异步解决方案有哪些？ - 回调函数 callback Promise Generator","text":"异步解决方案有哪些？ - 回调函数 callback Promise Generator - 回调函数 callback：回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。 - 事件发布订阅:消耗内存，过度使用会使代码难以维护和理解 - Promise:无法取消 promise。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 Pending 状态时，无法得知目前进展到哪一个阶段 - Generator:Generator 是 es6 提出的另一种异步编程解决方案，需要在函数名之前加一个\\*号，函数内部使用 yield 语句。Generaotr 函数会返回一个遍历器，可以进行遍历操作执行每个中断点 yield,不能自动执行异步操作，需要写多个 next()方法. - async/await:es2017 引入的异步操作解决方案，可以理解为 Generator 的语法糖，最重要的好处是同步编程风格,async 函数返回一个 Promise。内置执行器，比 Generator 操作更简单。async/await 比\\*yield 语义更清晰。返回值是 Promise 对象，可以用 then 指定下一步操作。代码更整洁。可以捕获同步和异步的错误。 ##"},{"id":"v-84a86fb6#什么是事件委托-什么是事件冒泡","path":"/JavaScript/#什么是事件委托-什么是事件冒泡","pageTitle":"JavaScript","headerTitle":"什么是事件委托 什么是事件冒泡","text":"什么是事件委托 什么是事件冒泡 - 事件流：事件流就是事件冒泡和事件捕获 - 事件冒泡：事件开始时由最具体的元素接收(操作元素)，然后逐级向上传播到较为不具体的节点,一直到文档 document - 事件捕获：反过来从最不具体的到最具体的 - 事件委托就是将自身要添加的事件委托给其他元素 从而实现相同的效果 原生 js 里面添加事件委托是 addEventListener 移出是 removeEventListener - 事件委托的优缺点： - 优点：减少事件注册次数，节约内存，提升性能。 - 缺点：所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。 ##"},{"id":"v-84a86fb6#事件轮询","path":"/JavaScript/#事件轮询","pageTitle":"JavaScript","headerTitle":"事件轮询","text":"事件轮询 **核心定义：事件循环是主线程的工作基石** 事件循环（Event Loop），也称消息循环（Message Loop），是浏览器渲染主线程的核心工作机制。其本质可以理解为一个永不停止的 for 循环，持续地从“任务队列”中取出任务来执行。其他线程（如处理定时器、网络请求的线程）负责在任务完成后，将相应的回调任务放入任务队列中，等待主线程的调度。 - 宏任务 (Macrotask): - JavaScript 的同步代码 - I/O 操作 - setTimeout - setInterval - setImmediate - requestAnimationFrame - 微任务 (Microtask): - Promise (具体如 Promise.then, catch 和 finally) - process.nextTick - MutationObserver ###"},{"id":"v-84a86fb6#执行顺序-过程","path":"/JavaScript/#执行顺序-过程","pageTitle":"JavaScript","headerTitle":"执行顺序/过程","text":"执行顺序/过程 1. 执行同步代码（宏任务）： 事件循环开始，首先会执行主线程上的同步代码。比如 console.log('script start') 会被立即执行。 2. 分发异步任务： 在执行同步代码的过程中，如果遇到异步任务，主线程会把它们分发出去。 - 比如 setTimeout，它的回调会被放到一个“宏任务”（macrotask）队列中。 - 比如 Promise.then，它的回调会被放到“微队列”（microtask queue）中。 3. 同步代码执行完毕： 当主线程的同步代码（即当前的第一个宏任务）全部执行完毕后，主线程会立即检查微队列。 4. 清空微队列（Microtask Checkpoint）： 这是最关键的一步。主线程会查看微队列，如果里面有任务，主线程会一次性将微队列中的所有任务全部执行完毕。如果在执行微任务的过程中，又产生了新的微任务，那么这些新的微任务也会被加到微队列的末尾，并在这个同一个阶段被执行，直到微队列被彻底清空为止。 5. 执行下一个宏任务： 只有在微队列被完全清空之后，事件循环才会去宏任务队列中取出一个任务来执行。 6. 重复循环： 当这个宏任务（setTimeout 回调）执行完毕后，事件循环会再次重复第 4 步：立即检查微队列，清空所有微任务。然后再去执行第 5 步：取下一个宏任务。 **模型的演进：告别简单的“宏/微任务”二分法** 过去常将任务队列简单地分为“宏队列”（Macrotask Queue）和“微队列”（Microtask Queue）。但在现代复杂的浏览器环境下，这种二分法已不再适用。现代浏览器采用了更灵活、精细的多队列任务处理模型。 **现代 W3C 模型：多队列与优先级调度** 根据 W3C 官方规范，现代事件循环的任务调度遵循以下原则： - 浏览器内部存在多个任务队列，每个任务按类型（如用户交互、渲染、网络等）划分到不同队列。 - 不同队列拥有不同优先级，由浏览器根据当前页面状态智能调度。 - 微队列（Microtask Queue）拥有绝对最高优先级，在每次事件循环中只要微队列有任务，必须全部执行完后再处理其他队列任务。 **执行过程实例分析** 下面用一个具体的例子，详细说明现代浏览器事件循环的执行过程： ```javascript console.log(\"script start\"); setTimeout(() => { console.log(\"timeout\"); }, 0); Promise.resolve() .then(() => { console.log(\"microtask1\"); }) .then(() => { console.log(\"microtask2\"); }); console.log(\"script end\"); ``` 执行流程及输出分析： 1. 首先同步执行主线程中的代码，输出： ``` script start script end ``` 2. `setTimeout` 的回调被放入 macrotask 队列。 3. `Promise.then` 的回调被加入微队列（microtask queue）。 4. 主线程同步任务执行完毕，事件循环开始下一个阶段。 5. 检查微队列，发现有两个微任务，按照顺序依次全部执行，输出： ``` microtask1 microtask2 ``` 6. 微队列执行完毕，事件循环继续处理 macrotask 队列中的任务，即 setTimeout 的回调，输出： ``` timeout ``` 最终输出顺序为： ``` script start script end microtask1 microtask2 timeout ``` 这个例子清晰地展现了微队列在事件循环中的绝对优先级：只要微队列有任务，主线程会优先全部执行完微任务，然后再去处理其他类型的任务队列。这正是现代浏览器事件循环模型的核心特征。 ##"},{"id":"v-84a86fb6#本地存储-缓存","path":"/JavaScript/#本地存储-缓存","pageTitle":"JavaScript","headerTitle":"本地存储 缓存","text":"本地存储 缓存 - 存储大小 cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 - 有效时间 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 - 数据与服务器之间的交互方式 cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 cookie 验证不安全易遭到 CSRF 攻击： 当你当前网站没有退出，而恰好漏洞网站又已你当前网站为漏洞，并添加转账信息或各种增删改查信息等，你的数据就会被篡改，导致不安全，CSRF 攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式。 方法： 通常使用 Anti CSRF Token 来防御 CSRF 攻击，同时要注意 Token 的保密性和随机性。 - 尽量使用 POST，限制 GET - 将 cookie 设置为 HttpOnly - 增加 token - 并且 CSRF 攻击问题一般是由服务端解决。 ##"},{"id":"v-84a86fb6#get-和-post-的区别","path":"/JavaScript/#get-和-post-的区别","pageTitle":"JavaScript","headerTitle":"get 和 post 的区别","text":"get 和 post 的区别 - 语义化：get 获取 post 传输 - 数据长度：get 地址栏，地址栏仅能传输 2000 多个字符，post 理论上无限。 - 安全性：get 不安全，地址栏显示，post 安全。 - 传输数据：get 通过地址栏?和& post 通过请求头和 send 方法 - 缓存问题：get 有缓存，post 没有缓存。 清除缓存：浏览器设置 - 清除数据。 快捷方式：ctrl+h 左侧查看清除按钮 ##"},{"id":"v-84a86fb6#http-请求过程","path":"/JavaScript/#http-请求过程","pageTitle":"JavaScript","headerTitle":"http 请求过程","text":"http 请求过程 用户输入网址 → 域名解析 → 建立连接 → 发送 HTTP 请求 → 服务器处理 → 返回响应 → 浏览器渲染 http 请求流程 浏览器端，客户端，前端 - 用户在浏览器地址栏输入域名 例如输入：https://www.taobao.com - 域名解析（DNS 解析） 浏览器首先检查本地缓存（浏览器 DNS 缓存、操作系统 DNS 缓存）是否有该域名的 IP 地址。 如果没有，则向本地 DNS 服务器发起请求，逐级递归或迭代查询，最终获取到 www.taobao.com 对应的 IP 地址。 域名和服务器的 IP 地址建立绑定关系。 - 建立 TCP 连接（三次握手） 浏览器和目标服务器（如淘宝服务器）在目标端口（通常是 80/443）上建立 TCP 连接。 HTTPS 协议还会有 TLS/SSL 握手过程，协商加密方式和密钥。 - 浏览器向服务器发送 HTTP 请求 包括请求方法（GET/POST 等）、请求头（headers）、请求体（body，POST 时有）等。 服务器处理请求，返回响应 服务器收到请求后，查找对应的资源，处理业务逻辑，并生成响应内容（HTML、CSS、JS、图片等）。 - 浏览器接收响应，渲染页面 浏览器解析返回的 HTML，遇到 CSS、JS、图片等资源会继续发起新的 HTTP 请求。 解析和执行 CSS 样式、JavaScript 代码，最终渲染出完整的网页供用户交互。 ##"},{"id":"v-84a86fb6#http-状态码","path":"/JavaScript/#http-状态码","pageTitle":"JavaScript","headerTitle":"http 状态码","text":"http 状态码 200：成功，所有数据都在响应主体中 300：有多个资源地址，选择要访问的资源便可链接过去 301:被请求的资源已经永久移动到新位置 302:请求的资源临时从不同的 url 响应请求 304：如果客户端发送了⼀个带条件的请求，请求被允许后⽂档内容却没有改变 400:请求参数错误 401:未授权，请登录 403:跨域拒绝访问 404:请求失败，请求的资源在服务器上没有被找到 408:请求超时 500：通常为服务器源代码出错⽽⽆法响应请求 501:error.message = 服务未实现; 502:网关错误; 503:服务不可用; 504:网关超时; ##"},{"id":"v-84a86fb6#什么是跨域","path":"/JavaScript/#什么是跨域","pageTitle":"JavaScript","headerTitle":"什么是跨域?","text":"什么是跨域? 所谓的同源是指，域名、协议、端口均为相同。 所谓的跨域，不同的域名、协议、端口皆为不同域 一个域与另一个域名、协议或者端口不同的域的之间访问都叫跨域 **解决跨域的方法和方案：** - 配置本地开发环境（环境代理） - **原理**：通过前端开发服务器（如 webpack-dev-server、Vite、create-react-app 等工具）配置 `proxy` 字段，将接口请求代理到后端服务器，实现“同源”效果，从而规避浏览器的同源策略限制。 - **特点**：仅适用于本地开发环境，生产环境不可用。 - **示例**（以 Vite 为例）： ```js // vite.config.js export default { server: { proxy: { \"/api\": \"http://backend-server.com\", }, }, }; ``` --- - JSONP 跨域 - **原理**：利用 `<script>` 标签不受同源策略限制的特点，通过动态创建 `<script>` 标签，加载携带参数的请求，服务器返回一段 JavaScript 代码并调用事先定义好的回调函数实现数据传递。 - **实现步骤**： 1. 前端声明一个全局回调函数。 2. 动态创建 `<script>` 标签，将请求地址（带回调函数名参数）赋值给 `src` 属性。 3. 插入页面，触发请求，服务端返回形如 `callback(data)` 的 JS 代码，自动执行。 - **注意事项**： - 仅支持 GET 请求，无法处理 POST、PUT 等。 - 服务器需要支持 JSONP 格式的响应。 - 返回内容会作为 JS 脚本执行，有一定安全隐患。 - **示例**： ```js function handleResponse(data) { console.log(data); } var script = document.createElement(\"script\"); script.src = \"http://example.com/api?callback=handleResponse\"; document.body.appendChild(script); ``` --- - CORS（跨域资源共享，Cross-Origin Resource Sharing） - **原理**：服务器通过设置 `Access-Control-Allow-Origin` 等响应头，允许特定源的请求跨域访问资源。现代浏览器在发起跨域请求时会自动遵循 CORS 协议。 - **特点**： - 支持多种 HTTP 方法（GET、POST、PUT、DELETE 等）。 - 对开发者而言，前端代码和同源 AJAX 通信基本一致。 - 需要后端服务器配合设置响应头。 - **常见配置**（Node.js Express 示例）： ```js app.use((req, res, next) => { res.header(\"Access-Control-Allow-Origin\", \"*\"); // 允许所有域名 res.header(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE,OPTIONS\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\"); next(); }); ``` --- - Nginx 反向代理跨域 - **原理**：通过 Nginx 服务器配置反向代理，将前端请求转发到目标后端服务器，实现跨域资源访问。前端与 Nginx 同源，Nginx 代前端发起请求。 - **特点**： - 适用于生产环境，性能优良。 - 不改变前端和后端代码，仅需配置 Nginx。 - **示例配置**： ```nginx server { listen 80; server_name www.frontend.com; location /api/ { proxy_pass http://backend-server.com/api/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } ``` --- - 其他常见的跨域解决方案 - **后端中间件代理**：如 Node.js 的 http-proxy-middleware，原理类似于 Nginx 代理。 - **WebSocket**：WebSocket 协议本身不受同源策略的限制，可以进行跨域通信。 - **window.name、postMessage 跨域**：适用于 iframe 或多窗口间通信。 --- ##"},{"id":"v-84a86fb6#null-和-undefined-区别","path":"/JavaScript/#null-和-undefined-区别","pageTitle":"JavaScript","headerTitle":"null 和 undefined 区别","text":"null 和 undefined 区别 `null` 和 `undefined` 都表示“空值”，但在 JavaScript 中，它们代表了两种不同的“空”状态。 1. 核心含义和本质 | 属性 | `undefined` (未定义) | `null` (空值) | | :--- | :--- | :--- | | **含义** | **变量已声明，但尚未赋值。** | **变量已被赋值，但该值是空的。** | | **本质** | 表示*缺少*值 (A variable has been declared but not defined/assigned a value)。 | 表示*故意*没有对象值 (A value that is intentionally set to be empty or non-existent)。 | | **产生者** | JavaScript 引擎（系统）默认赋予。 | 开发者必须手动赋值。 | **记忆要点：** - **`undefined`**：系统默认值，表示**“变量存在，值待定”**。 - **`null`**：人为赋予值，表示**“变量存在，值为空/无对象”**。 2. 类型检查 (`typeof`) 使用 `typeof` 运算符进行检查时，它们的结果不同： | 表达式 | 结果 | 备注 | | :----------------- | :------------ | :----------------------------------------------------------------------- | | `typeof undefined` | `\"undefined\"` | 自身类型。 | | `typeof null` | `\"object\"` | **⚠️ 注意：** 这是一个历史遗留的 Bug，但实际进行类型检查时需记住此结果。 | 3. 常见产生场景 | `undefined` 的常见场景 | `null` 的常见场景 | | :---------------------------------------------------- | :--------------------------------------------------------------------- | | 1. **未初始化的变量：** `let x;` | 1. **手动清空变量：** `let data = null;` | | 2. **函数没有返回值：** 函数体中没有 `return` 语句。 | 2. **DOM 查询没有匹配项：** `document.getElementById()` 未找到元素。 | | 3. **函数参数未传值：** 调用函数时省略了参数。 | 3. **JSON 传输空值：** 接口返回数据中表示值为空。 | | 4. **对象中不存在的属性：** `obj.nonExistentProperty` | 4. **原型链末端：** `Object.getPrototypeOf(Object.prototype)` 的结果。 | 4. 相等性比较 在比较时，区分**宽松相等** (`==`) 和**严格相等** (`===`) 至关重要： | 比较方式 | 表达式 | 结果 | 解释 | | :----------- | :------------------- | :------ | :----------------------------------------------------- | | **严格相等** | `null === undefined` | `false` | 类型和值都不同。**（推荐使用此方式）** | | **宽松相等** | `null == undefined` | `true` | 宽松相等认为它们属于同一类“空值”，会进行隐式类型转换。 | 在实际开发中，**始终推荐使用严格相等 (`===`)**，因为它能更精确地判断值和类型的真实情况。 ##"},{"id":"v-84a86fb6#数组去重的方法","path":"/JavaScript/#数组去重的方法","pageTitle":"JavaScript","headerTitle":"数组去重的方法","text":"数组去重的方法 - 利用 set 数据结构里面没有重复的项的特点定义一个新数组用扩展运算符后面接一个 newSet 外面包一个[]在赋值给一个新数组 return 出去 ```js function one(arr) { let newarr = [...new Set(params)]; return newarr; } ``` - 遍历数组 并且把每一项 push 到新数组中去 push 的时候做判断 如果新数组中没有这项就 push 用 indexOf(item)=== -1 做判断 ```js function two(params) { let newarr = []; params.forEach((item) => { if (newarr.indexOf(item) === -1) { newarr.push(item); } }); return newarr; } ``` - 利用两层 for 循环 第一层直接遍历 第二层从 i+1 开始遍历 就是吧数组中的一项和数组中的每一项做对比 如果有一样的 那么就截取掉 ```js function three(params) { let arr = params; for (let i = 0; i < arr.length; i++) { for (let j = i + 1; j < arr.length; j++) { if (arr[j] === arr[i]) { arr.splice(j, 1); j--; } } } return arr; } ``` - 利用 filter 筛选 筛选索引 如果 indexof(item)等于 index 原理是 indexOf 是从前往后找 找到了之后他就不找了 如果这时候做个比较 只有相等的时候满足条件就可以去重了 ```js function four(params) { return params.filter((item, index) => { return params.indexOf(item) === index; }); } ``` - 两层 for 循环 把数组中的一项和数组中的每一项做对比 重复的把 flag 赋值为 2 下面做个判断 当 flag 为 1 的时候才 push ```js function five(item) { var newarr = []; //去重后新的数组 for (var i = 0, len1 = arr.length; i < len1; i++) { var flag = 1; //标记 //arr 的一项和所有的 newarr 里面的数组项进行比较 for (var j = 0, len2 = newarr.length; j < len2; j++) { if (arr[i] === newarr[j]) { //满足条件，新数组里面存在。不需要的 flag = 2; break; } } //如果到这里 flag=1,不满足上面的 if 判断，新数组不存在，需要的 if (flag === 1) { newarr.push(arr[i]); } } return newarr; } ``` - 对象数组去重原理第一层直接遍历 第二层从 i+1 开始遍历 就是吧把数组中的一项的 key 和数组中的每一项的 key 做对比 如果有一样的 那么就截取掉这一项 ```js function obj(item) { for (let i = 0; i < item.length; i++) { for (let j = i + 1; j < item.length; j++) { if (item[j].key === item[i].key) { item.splice(j, 1); j--; } } } return item; } ``` ##"},{"id":"v-84a86fb6#类数组概念-怎么转换成真正的数组","path":"/JavaScript/#类数组概念-怎么转换成真正的数组","pageTitle":"JavaScript","headerTitle":"类数组概念 怎么转换成真正的数组？","text":"类数组概念 怎么转换成真正的数组？ 也叫伪数组，在 js 中有一些对象它也拥有 length 属性，且拥有为非负整数的属性(索引)，但是它又不能调用数组的方法，这种对象被称为类数组对象 常见的伪数组 - DOM 方法返回的 NodeList（比如 document.querySelectorAll() 的结果） - arguments 对象 **类数组转换成真正的数组** 1. let 定义一个类数组 把类数组拆分成一系列用逗号隔开的值 arr =[一系列用逗号隔开的值] 2. Array.from()方法用于将对象转为真正的数组(类数组转数组) 3. 遍历类数组 将取到的每一项值添加到新数组 ##"},{"id":"v-84a86fb6#js-数据类型检测","path":"/JavaScript/#js-数据类型检测","pageTitle":"JavaScript","headerTitle":"js 数据类型检测","text":"js 数据类型检测 - typeof 引用数据类型（如：Array）是不起作用的。 - instanceof 检测基本数据类型的话会返回 false 引用数据类型则会是 true 但是用 new 关键字 new 出来的基本数据类型是可以的 - constructor 声明了一个构造函数，并且把他的原型指向了其他类型的原型 这种情况下会失效 - Object.prototype.toString.call() - 最好的数据类/型检测方式 ##"},{"id":"v-84a86fb6#this-指向哪里","path":"/JavaScript/#this-指向哪里","pageTitle":"JavaScript","headerTitle":"this 指向哪里","text":"this 指向哪里 - 普通函数的 this 指向调用这个函数的对象，默认是 window - 构造函数的 this 指向 new 出来的实例对象，而且优先级是最高的，不能被改变 - 箭头函数的 this 指向的是它外面的第一个不是箭头函数的函数的 this， 在定义时就确定了，不能被改变 - 事件处理函数的 this 指向事件对象 ##"},{"id":"v-84a86fb6#如何改变-this-指向","path":"/JavaScript/#如何改变-this-指向","pageTitle":"JavaScript","headerTitle":"如何改变 this 指向","text":"如何改变 this 指向 - 利用 call,apply,bind 改变 this 的指向。 - 利用变量将正确的 this 存储为变量。 - new 关键字改变 this 的指向。 - 箭头函数 ##"},{"id":"v-84a86fb6#call-apply-bind-区别","path":"/JavaScript/#call-apply-bind-区别","pageTitle":"JavaScript","headerTitle":"call, apply, bind 区别","text":"call, apply, bind 区别 - call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 - 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 - bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 ##"},{"id":"v-84a86fb6#常用的-git-命令","path":"/JavaScript/#常用的-git-命令","pageTitle":"JavaScript","headerTitle":"常用的 git 命令","text":"常用的 git 命令 **git** git 是目前世界上最先进分布式的版本控制系统 ```bash **配置** - 仓库账号的用户名和邮箱 git config --global user.name '远程仓库的账号' git config --global user.email '远程仓库的邮箱' **上传本地文件** git init 初始化 git add index.html 或者 git add . 提交到暂存区 git commit -m 'init index.html' 提交到本地仓库 git status 查看 git 的状态 git diff 查看版本的差别 git log 或者 git log --pretty=oneline 查看版本信息 git reset HEAD^ 回退一个版本(回退到的是暂存区的版本) git reset --hard cc56901 回退到指定版本 git reflog 查看所有的历史版本 **分支** git branch 查看分支 git branch dev 创建分支 git checkout dev 或者 git switch dev 切换分支 git checkout -b dev2 创建并切换 git merge dev2 合并分支内容 git branch -d dev2 删除分支 git log --graph --pretty=oneline 查看分支记录 **关联远程仓库** 生成密钥对 ssh-keygen -t rsa -C 'pudge_wj@163.com' 创建项目 git init git add . git commit -m 'init' git remote add origin git@github.com:pudge-w/taobao.git git push -u origin master 邀请组员 setting -> manage access 组员开发 不要在 master 做开发!!!! git checkout -b zhengguo git add . git commit -m 'xxx' git pull git push 组长 git fetch --all git checkout zhengguo git pull git checkout master git merge zhengguo git push ``` ##"},{"id":"v-84a86fb6#git-克隆速度慢的解决办法及科学上网代理配置","path":"/JavaScript/#git-克隆速度慢的解决办法及科学上网代理配置","pageTitle":"JavaScript","headerTitle":"Git 克隆速度慢的解决办法及科学上网代理配置","text":"Git 克隆速度慢的解决办法及科学上网代理配置 在中国大陆等地区，使用 `git clone` 从 GitHub 等国外仓库拉取代码时，常常会遇到速度较慢、甚至连接超时的问题。如果没有使用全局加速器（如全局 VPN），可以通过配置 Git 的代理端口，快速实现“科学上网”，显著提升 Git 操作速度。 --- ###"},{"id":"v-84a86fb6#_1-问题现象","path":"/JavaScript/#_1-问题现象","pageTitle":"JavaScript","headerTitle":"1. 问题现象","text":"1. 问题现象 - `git clone`、`git fetch`、`git pull` 等指令速度极慢，甚至失败。 - 原因：国内网络对 GitHub 等国外源访问受限，速度被大幅降低。 - 解决思路：为 Git 单独配置代理端口，让其流量通过本地加速器的 HTTP(S) 代理端口转发。 --- ###"},{"id":"v-84a86fb6#_2-解决办法-为-git-配置代理","path":"/JavaScript/#_2-解决办法-为-git-配置代理","pageTitle":"JavaScript","headerTitle":"2. 解决办法：为 Git 配置代理","text":"2. 解决办法：为 Git 配置代理 #### 2.1 选择合适的本地代理端口 - 常见的科学上网工具（如 Clash、V2RayN、Surfboard 等）都支持本地 HTTP(S) 代理，端口号一般为 `7890`、`7897`、`1080` 等（以实际工具配置为准）。 - 例如 Clash 默认 HTTP 代理端口为 `7890`，部分工具自定义端口为 `7897`。 #### 2.2 全局配置 Git 代理 可以直接在命令行设置： ```bash git config --global http.proxy http://127.0.0.1:7897 git config --global https.proxy http://127.0.0.1:7897 ``` - 这样配置后，所有 Git 操作都会通过本地的 7897 端口进行 HTTP/HTTPS 请求，实现加速。 #### 2.3 取消 Git 代理 ```bash git config --global --unset http.proxy git config --global --unset https.proxy ``` --- ###"},{"id":"v-84a86fb6#_3-快速开启-关闭-git-代理-推荐-alias","path":"/JavaScript/#_3-快速开启-关闭-git-代理-推荐-alias","pageTitle":"JavaScript","headerTitle":"3. 快速开启/关闭 Git 代理（推荐 alias）","text":"3. 快速开启/关闭 Git 代理（推荐 alias） 为了方便日常切换，可以将开启和关闭代理的操作写成 shell alias： ```bash # 快速开启 Git 科学上网代理 alias proxy_on=\"git config --global http.proxy http://127.0.0.1:7897 && git config --global https.proxy http://127.0.0.1:7897 && echo 'Git proxy has been turned ON.'\" # 快速关闭 Git 科学上网代理 alias proxy_off=\"git config --global --unset http.proxy && git config --global --unset https.proxy && echo 'Git proxy has been turned OFF.'\" ``` > **提示**：可以将上述 alias 写入 `~/.bashrc`、`~/.zshrc` 等 shell 配置文件中，重开终端即可生效。 > > - 之后只需运行 `proxy_on` 即可开启代理，`proxy_off` 关闭代理。 --- ###"},{"id":"v-84a86fb6#_4-检查-git-代理状态","path":"/JavaScript/#_4-检查-git-代理状态","pageTitle":"JavaScript","headerTitle":"4. 检查 Git 代理状态","text":"4. 检查 Git 代理状态 可以通过以下命令查看当前 git 的代理配置： ```bash git config --global --get http.proxy git config --global --get https.proxy ``` 如果返回为空，则说明当前未配置代理。 --- ###"},{"id":"v-84a86fb6#_5-其他说明","path":"/JavaScript/#_5-其他说明","pageTitle":"JavaScript","headerTitle":"5. 其他说明","text":"5. 其他说明 - 该方法仅影响 Git 命令（不影响其它终端流量）。 - 记得本地代理工具必须已启动并监听对应端口，否则配置后 Git 会连接失败。 - 若使用 SSH 协议（如 `git@github.com:xxx`），本配置**无效**，建议改用 HTTPS 协议（如 `https://github.com/xxx`）克隆仓库。 - 若需临时代理（只对单条命令生效），可用如下方式： ```bash git -c http.proxy=http://127.0.0.1:7897 -c https.proxy=http://127.0.0.1:7897 clone https://github.com/xxx/xxx.git ``` --- ###"},{"id":"v-84a86fb6#_6-参考资料","path":"/JavaScript/#_6-参考资料","pageTitle":"JavaScript","headerTitle":"6. 参考资料","text":"6. 参考资料 - [Git 官方文档：git-config](https://git-scm.com/docs/git-config) - [Clash 使用说明](https://docs.cfw.lbyczf.com/contents/proxy.html) - [提高 GitHub 访问速度的几种方法](https://juejin.cn/post/6844904186715285512) ##"},{"id":"v-84a86fb6#垃圾回收机制","path":"/JavaScript/#垃圾回收机制","pageTitle":"JavaScript","headerTitle":"垃圾回收机制","text":"垃圾回收机制 垃圾回收方式 - 标记清除 工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 - 引用计数 工作原理：跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。 - 内存管理 什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。 - 合理的 GC 方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。 - GC 缺陷： (1)、停止响应其他操作； - GC 优化策略： (1)、分代回收（Generation GC）;(2)、增量 GC ##"},{"id":"v-84a86fb6#深浅拷贝","path":"/JavaScript/#深浅拷贝","pageTitle":"JavaScript","headerTitle":"深浅拷贝","text":"深浅拷贝 - 浅拷贝,拷贝一级，如果是对象里面还有对象,无法解决 1. for… in… 循环 2. Object.assgin() 缺点：非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable 3. ...扩展运算符 - 深拷贝 1. JSON.parse(JSON.stringify( )) 缺点：当对象的 value 是函数 或者 undefined 时会失效 2. 用 for…in…+递归 - 递归实现深拷贝代码 思路： 1. 创建一个空对象 一个 if 条件判断一下这个传进来的是不是个对象 2. 然后遍历对象 用一个 obj.hasOwnProperty(key)判断这个 key 是不是自身的属性 3. 如果 obj[key]还是一个对象就递归调用这个函数 如果不是对象就把他赋值给新对象 ```JavaScript function deepCopy(obj) { let objArray = Array.isArray(obj) ? [] : {}; //定义空数组或者空对象 if (obj && typeof obj === \"object\") { //判断是否是对象 for (key in obj) { //遍历数组或者对象e if (obj.hasOwnProperty(key)) { //判断当前key是不是对象自身的属性。不包括原型链 if (obj[key] && typeof obj[key] === \"object\") { objArray[key] = deepCopy(obj[key]); } else { objArray[key] = obj[key]; } } } } return objArray; } ``` ##"},{"id":"v-84a86fb6#构造函数详解与总结","path":"/JavaScript/#构造函数详解与总结","pageTitle":"JavaScript","headerTitle":"构造函数详解与总结","text":"构造函数详解与总结 **什么是构造函数？** 构造函数（Constructor Function）是 JavaScript 中用于创建对象的一种特殊函数。它主要用于在实例化对象时，初始化对象的属性和方法。 - 构造函数通常**首字母大写**，以示区别于普通函数。 - 构造函数需要与 `new` 关键字一起使用。 **构造函数的执行流程** 当使用 `new` 关键字调用构造函数时，执行过程如下： 1. 在内存中创建一个新的空对象。 2. 将构造函数内部的 `this` 指向这个新对象。 3. 执行构造函数内的代码（给新对象添加属性和方法）。 4. 返回新对象（如果构造函数没有显式返回对象，则返回步骤 1 创建的对象）。 **构造函数的示例** ```js function Person(name, age) { this.name = name; this.age = age; this.sayHello = function () { console.log(\"Hello, I am \" + this.name); }; } const p1 = new Person(\"Alice\", 18); p1.sayHello(); // 输出：Hello, I am Alice ``` **注意事项** - 构造函数必须和 `new` 一起使用，否则 `this` 指向全局对象（在严格模式下为 undefined）。 - 构造函数可以不用 `return` 返回值；如果返回的是非对象类型，仍然返回新对象本身；如果返回的是对象，则返回该对象。 - 通过构造函数创建的多个对象实例，**各自拥有独立的属性和方法**。 **构造函数和普通函数的区别** | 区别 | 构造函数 | 普通函数 | | --------- | ----------------------- | ------------------ | | 命名 | 通常首字母大写 | 通常首字母小写 | | 调用方式 | 必须用 `new` 关键字调用 | 直接调用 | | this 指向 | 指向新创建的对象 | 由调用方式决定 | | 返回值 | 默认返回新对象 | 默认返回 undefined | **总结** - 构造函数本质上就是一个普通函数，但用来创建对象实例。 - 使用 `new` 关键字调用构造函数可以自动完成对象的创建和初始化。 - 合理使用构造函数可以提高代码的复用性和可维护性，是 JS 面向对象编程的基础。 ##"},{"id":"v-84a86fb6#原型链","path":"/JavaScript/#原型链","pageTitle":"JavaScript","headerTitle":"原型链","text":"原型链 **原型（prototype）的概念** - **每一个函数都有一个 prototype 属性** - 这个属性指向一个对象，称为“原型对象”。 - 当函数作为构造函数（即用 `new` 创建对象）时，新创建的对象会自动拥有对这个原型对象的引用。 - **原型对象的作用** - 所有定义在 prototype 上的属性和方法，都会被该构造函数的实例继承和共享。 - 适合将不变（公用）的属性和方法定义在 prototype 上，节省内存，提高复用性。 - **this 的指向** - 在构造函数内部，`this` 指向实例对象。 - 在原型对象内部，`this` 也指向调用该方法的实例对象。 - **示例代码** ```js function Person(name) { this.name = name; } Person.prototype.sayHello = function () { console.log(\"Hello, I am \" + this.name); }; const p1 = new Person(\"Alice\"); p1.sayHello(); // 输出：Hello, I am Alice ``` --- **原型链的概念** - **什么是原型链？** - 原型链是 JavaScript 实现继承的主要机制。 - 每个对象都有一个内部属性 `__proto__`（标准写法为 [[Prototype]]），指向它的原型对象。 - 多个对象通过 `__proto__` 属性串联在一起，形成链状结构，称为“原型链”。 - **查找规则** - 当访问一个对象的属性或方法时，如果对象本身没有，就会去它的原型对象（即 `__proto__` 指向的对象）查找。 - 如果原型对象也没有，再继续沿着它的 `__proto__` 查找，直到找到 `Object.prototype`，其 `__proto__` 为 `null`，原型链到此结束。 - **原型链结构图** ``` 实例对象 ——> 构造函数.prototype ——> Object.prototype ——> null | | | |__proto__ |__proto__ |__proto__ ``` - **示例代码** ```js function Animal() {} Animal.prototype.eat = function () { console.log(\"eating\"); }; function Dog() {} Dog.prototype = new Animal(); Dog.prototype.bark = function () { console.log(\"bark\"); }; const dog = new Dog(); dog.bark(); // bark dog.eat(); // eating ``` --- **核心要点总结** - 每个函数都有 prototype 属性，每个对象（除 null）都有 **proto** 属性。 - 构造函数的 prototype 上定义的方法和属性，会被所有实例共享。 - 原型链让对象可以“继承”到上层原型对象的属性和方法。 - 属性/方法的查找顺序：对象本身 → 原型对象 → 原型链上一层... → Object.prototype → null ##"},{"id":"v-84a86fb6#js-的几种模块规范","path":"/JavaScript/#js-的几种模块规范","pageTitle":"JavaScript","headerTitle":"js 的几种模块规范","text":"js 的几种模块规范 **ES Module（ESM，ES6 模块规范）** - **应用场景**：现代浏览器和 Node.js（支持 .mjs 或 \"type\": \"module\"）。 - **核心思想**：JavaScript 官方标准的模块系统，静态分析，编译时确定依赖关系。 - **特点**： - 使用 `export` 导出，`import` 导入。 - 支持异步和静态引入，最适合前端工程化。 - 代码示例： ```js // a.js export const foo = \"bar\"; // b.js import { foo } from \"./a.js\"; console.log(foo); // 输出 'bar' ``` --- **CommonJS** - **应用场景**：主要用于 Node.js 服务器端开发。 - **核心思想**：每个文件就是一个模块，模块内部通过 `module.exports` 导出成员，通过 `require` 导入模块。 - **特点**： - 同步加载模块（适合服务器，文件都在本地）。 - 代码示例： ```js // a.js module.exports = { foo: \"bar\", }; // b.js const a = require(\"./a.js\"); console.log(a.foo); // 输出 'bar' ``` --- **AMD（Asynchronous Module Definition）** - **应用场景**：主要用于浏览器端，代表库有 RequireJS。 - **核心思想**：异步加载模块，适合浏览器环境。 - **特点**： - 使用 `define` 定义模块，`require` 加载模块。 - 支持依赖前置，异步加载。 - 代码示例： ```js // 定义模块 define([\"dep1\", \"dep2\"], function (dep1, dep2) { return { foo: function () {}, }; }); // 使用模块 require([\"moduleA\"], function (moduleA) { moduleA.foo(); }); ``` --- **CMD（Common Module Definition）** - **应用场景**：主要用于浏览器端，代表库有 SeaJS（国内较流行）。 - **核心思想**：按需加载（延迟执行），依赖就近。 - **特点**： - 使用 `define` 定义模块，`require` 加载模块。 - 依赖可以写在使用的地方，延迟执行。 - 代码示例： ```js define(function (require, exports, module) { var $ = require(\"jquery\"); exports.foo = function () {}; }); ``` --- **总结** - **ESM**：ES6 官方标准，现代浏览器和 Node.js 推荐使用。 - **CommonJS**：服务端 Node.js 标准，同步加载。 - **AMD/CMD**：浏览器端异步加载，前者依赖前置，后者依赖就近。 ###"},{"id":"v-84a86fb6#commonjs-和-es6-模块的区别","path":"/JavaScript/#commonjs-和-es6-模块的区别","pageTitle":"JavaScript","headerTitle":"CommonJS 和 ES6 模块的区别","text":"CommonJS 和 ES6 模块的区别 **加载方式** - **CommonJS**：同步加载模块，适用于服务器端（如 Node.js），因为本地文件读取速度快。 - **ES6 Module**：静态分析，编译时加载，支持异步和静态引入，适合浏览器和现代前端工程 **导入导出语法** - **CommonJS** - 导出：`module.exports = ...` 或 `exports.xxx = ...` - 导入：`const xxx = require('...')` - **ES6 Module** - 导出：`export` 或 `export default` - 导入：`import { xxx } from '...'` 或 `import xxx from '...'` **导出本质** - **CommonJS**：导出的是值的**拷贝**（require 时会执行一遍，被缓存；后续 require 拿到缓存的对象）。 - **ES6 Module**：导出的是**引用**（export 的变量和 import 的变量实时绑定，动态更新）。 **语法特性** - **CommonJS** - 动态语法，可以在运行时任意位置调用 `require`。 - 导出可以是任意类型的数据（对象、函数、字符串等）。 - **ES6 Module** - 静态语法，`import` 和 `export` 必须写在顶层，不能放在逻辑块或函数内部。 - 支持静态分析和 Tree Shaking（按需打包）。 **执行时机** - **CommonJS**：模块是**运行时加载**，require 时同步读取、立即执行一遍。 - **ES6 Module**：模块是**编译时解析**，提前确定依赖关系，提升性能。 **总结** | 对比点 | CommonJS | ES6 Module | | -------- | ---------------------- | -------------- | | 加载方式 | 同步 | 静态、异步支持 | | 导入导出 | require/module.exports | import/export | | 导出本质 | 值的拷贝 | 引用绑定 | | 执行时机 | 运行时 | 编译时 | | this | 指向 exports | undefined | | 兼容性 | Node.js（服务端） | 浏览器+Node.js | ##"},{"id":"v-84a86fb6#防抖节流","path":"/JavaScript/#防抖节流","pageTitle":"JavaScript","headerTitle":"防抖节流","text":"防抖节流 **函数的防抖（Debounce）** - **定义**：当事件被触发后，等待一段指定时间再执行回调。如果在等待时间内事件再次被触发，则重新计时，只有最后一次触发后等待时间到了才执行。 - **应用场景**：输入框实时搜索、窗口大小变化、滚动加载等频繁触发场景，减少无效调用。 - **实现示例**： ```js function debounce(fn, delay) { let timer = null; return function (...args) { clearTimeout(timer); timer = setTimeout(() => { fn.apply(this, args); }, delay); }; } // 使用方式 window.addEventListener( \"resize\", debounce(function () { console.log(\"窗口大小变化\"); }, 500) ); ``` **函数节流（Throttle）** - **定义**：在指定的时间间隔内，不管事件被触发多少次，只会执行一次回调函数。 - **应用场景**：页面滚动、按钮点击、窗口缩放等高频事件，控制函数的执行频率，提升性能。 - **实现示例**： ```js function throttle(fn, interval) { let lastTime = 0; return function (...args) { const now = Date.now(); if (now - lastTime > interval) { fn.apply(this, args); lastTime = now; } }; } // 使用方式 window.addEventListener( \"scroll\", throttle(function () { console.log(\"页面滚动\"); }, 200) ); ``` ##"},{"id":"v-84a86fb6#js-实现继承的方式有哪些","path":"/JavaScript/#js-实现继承的方式有哪些","pageTitle":"JavaScript","headerTitle":"js 实现继承的方式有哪些","text":"js 实现继承的方式有哪些 - 构造函数继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） - 原型链继承-----核心： 将父类的实例作为子类的原型\\*\\* - 组合（混合）继承----核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 - class 继承----核心：class 是 ES6 新增的语法 直接 class 创建一个类，使用 extends 来继承 - 实例继承----核心：为父类实例添加新特性，作为子类实例返回 - 拷贝继承-----核心：Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。 - 寄生组合继承----核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 ##"},{"id":"v-84a86fb6#严格模式下有哪些限制-规则","path":"/JavaScript/#严格模式下有哪些限制-规则","pageTitle":"JavaScript","headerTitle":"严格模式下有哪些限制（规则）","text":"严格模式下有哪些限制（规则） - 变量必须声明后再使用 - 函数的参数不能有同名属性，否则报错 - 不能使用 with 语句 - 不能对只读属性赋值，否则报错 - 不能使用前缀 0 表示八进制数，否则报错 - 不能删除不可删除的属性，否则报错 - 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] - eval 不会在它的外层作用域引入变量 - eval 和 arguments 不能被重新赋值 - arguments 不会自动反映函数参数的变化 - 不能使用 arguments.callee - 不能使用 arguments.caller - 禁止 this 指向全局对象 - 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 - 增加了保留字（比如 protected、static 和 interface） ##"},{"id":"v-84a86fb6#函数缓存的方法","path":"/JavaScript/#函数缓存的方法","pageTitle":"JavaScript","headerTitle":"函数缓存的方法","text":"函数缓存的方法 **基本思想** - 当函数被调用时，先检查传入的参数是否有对应的结果已被缓存。 - 如果有，直接返回缓存的结果。 - 如果没有，执行计算，把结果缓存起来，下次遇到相同参数直接取用。 **常见实现方式** - 闭包实现 ```js function memoize(fn) { const cache = {}; return function (...args) { const key = JSON.stringify(args); if (cache[key]) { return cache[key]; } const result = fn.apply(this, args); cache[key] = result; return result; }; } // 示例：斐波那契数列 function fibonacci(n) { if (n <= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } const memoFibonacci = memoize(fibonacci); console.log(memoFibonacci(40)); // 比直接递归快得多 ``` **Map 实现（更适合复杂参数）** ```js function memoize(fn) { const cache = new Map(); return function (...args) { const key = JSON.stringify(args); if (cache.has(key)) { return cache.get(key); } const result = fn.apply(this, args); cache.set(key, result); return result; }; } ``` **应用场景** - 递归函数（如斐波那契数列、阶乘等） - 重复计算但参数不变的复杂运算 - 前端数据转换、过滤等纯函数操作 **注意事项** - 适用于“纯函数”（相同参数总是返回相同结果，无副作用） - 参数复杂时需要设计好缓存 key，避免缓存污染或内存泄漏 - 不适合缓存大量或不断变化的数据 **相关扩展** - Lodash 等第三方库提供了 `_.memoize` 方法 - ES6 WeakMap 可用于缓存对象参数，避免内存泄漏 ##"},{"id":"v-84a86fb6#内存泄漏是什么-内存泄露造成的原因","path":"/JavaScript/#内存泄漏是什么-内存泄露造成的原因","pageTitle":"JavaScript","headerTitle":"内存泄漏是什么 内存泄露造成的原因","text":"内存泄漏是什么 内存泄露造成的原因 内存泄漏也称作\"存储渗漏\"，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束 简单来说就是该内存空间使用完毕后未回收 **_内存泄露造成的原因_** 1. 单例造成的内存泄漏 2. 静态集合类 3. 资源未关闭造成的内存泄漏 4. 改变哈希值 5. 缓存泄露 6. 监听器和回调 7. 不合理的使用闭包 ##"},{"id":"v-84a86fb6#函数柯里化","path":"/JavaScript/#函数柯里化","pageTitle":"JavaScript","headerTitle":"函数柯里化","text":"函数柯里化 柯里化（Currying） 柯里化（Currying）是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。 柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。 柯里化不会调用函数。它只是对函数进行转换。 让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。 我们将创建一个辅助函数 curry(f)，该函数将对两个参数的函数 f 执行柯里化。换句话说，对于两个参数的函数 f(a, b) 执行 curry(f) 会将其转换为以 f(a)(b) 形式运行的函数： ```JavaScript function curry(f) { // curry(f) 执行柯里化转换 return function(a) { return function(b) { return f(a, b); }; }; } // 用法 function sum(a, b) { return a + b; } let curriedSum = curry(sum); alert( curriedSum(1)(2) ); // 3 ``` 正如你所看到的，实现非常简单：只有两个包装器（wrapper）。 curry(func) 的结果就是一个包装器 function(a)。 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。 柯里化更高级的实现，例如 lodash 库的 \\_.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用： ```JavaScript function sum(a, b) { return a + b; } let curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry alert( curriedSum(1, 2) ); // 3，仍可正常调用 alert( curriedSum(1)(2) ); // 3，以偏函数的方式调用 ``` 柯里化？目的是什么？ 要了解它的好处，我们需要一个实际中的例子。 例如，我们有一个用于格式化和输出信息的日志（logging）函数 log(date, importance, message)。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 alert： ```JavaScript function log(date, importance, message) { alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`); } //让我们将它柯里化！ log = _.curry(log); // 柯里化之后，log 仍正常运行： log(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c) // ……但是也可以以柯里化形式运行： log(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c) // 现在，我们可以轻松地为当前日志创建便捷函数： // logNow 会是带有固定第一个参数的日志的偏函数 let logNow = log(new Date()); // 使用它 logNow(\"INFO\", \"message\"); // [HH:mm] INFO message // 现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。 // 我们可以更进一步，为当前的调试日志（debug log）提供便捷函数： let debugNow = logNow(\"DEBUG\"); debugNow(\"message\"); // [HH:mm] DEBUG message ``` 所以： 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。 高级柯里化实现 如果你想了解更多细节，下面是用于多参数函数的“高级”柯里化实现，我们也可以把它用于上面的示例。 它非常短： ```JavaScript function curry(func) { return function curried(...args) { if (args.length >= func.length) { return func.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); } } }; } // 用例： function sum(a, b, c) { return a + b + c; } let curriedSum = curry(sum); alert( curriedSum(1, 2, 3) ); // 6，仍然可以被正常调用 alert( curriedSum(1)(2,3) ); // 6，对第一个参数的柯里化 alert( curriedSum(1)(2)(3) ); // 6，全柯里化 // 新的 curry 可能看上去有点复杂，但是它很容易理解。 // curry(func) 调用的结果是如下所示的包装器 curried： // func 是要转换的函数 function curried(...args) { if (args.length >= func.length) { // (1) return func.apply(this, args); } else { return function(...args2) { // (2) return curried.apply(this, args.concat(args2)); } } }; ``` 当我们运行它时，这里有两个 if 执行分支： 如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，那么只需要使用 func.apply 将调用传递给它即可。 否则，获取一个偏函数：我们目前还没调用 func。取而代之的是，返回另一个包装器 pass，它将重新应用 curried，将之前传入的参数与新的参数一起传入。 然后，如果我们再次调用它，我们将得到一个新的偏函数（如果没有足够的参数），或者最终的结果。 只允许确定参数长度的函数 柯里化要求函数具有固定数量的参数。 使用 rest 参数的函数，例如 f(...args)，不能以这种方式进行柯里化。 比柯里化多一点 根据定义，柯里化应该将 sum(a, b, c) 转换为 sum(a)(b)(c)。 但是，如前所述，JavaScript 中大多数的柯里化实现都是高级版的：它们使得函数可以被多参数变体调用。 总结 柯里化 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。 柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"},{"id":"v-20e3ed6c","path":"/React/Hooks.html","pageTitle":"hocks","headerTitle":null,"text":"# hocks ##"},{"id":"v-20e3ed6c#简介","path":"/React/Hooks.html#简介","pageTitle":"hocks","headerTitle":"简介","text":"简介 从 react 中解构出以 use 开头的函数 让函数式组件拥有类组件的功能 ##"},{"id":"v-20e3ed6c#usestate","path":"/React/Hooks.html#usestate","pageTitle":"hocks","headerTitle":"useState","text":"useState useState 是一个 React 钩子，可让你将 状态变量 添加到组件中。 ```jsx const [state, setState] = useState(initialState); ``` - ["},{"id":"v-20e3ed6c#参考","path":"/React/Hooks.html#参考","pageTitle":"hocks","headerTitle":"参考","text":"参考](#参考) - [useState (initialState)](<#useState(initialState)>) - [set 函数与 setSomething(nextState) 类似](<#set函数与setSomething(nextState)类似>) - 用法 - [向组件添加状态](#向组件添加状态) - [根据之前的状态更新状态](#根据之前的状态更新状态) - [更新状态中的对象和数组](#更新状态中的对象和数组) - [避免重新创建初始状态](#避免重新创建初始状态) - [使用键来重置状态](#使用键来重置状态) - [存储以前渲染的信息](#存储以前渲染的信息) - [故障排除](#故障排除) - [我更新了状态，但日志记录给了我旧值](#我更新了状态，但日志记录给了我旧值) - [我已经更新了状态，但是屏幕没有更新](#我已经更新了状态，但是屏幕没有更新) - [我收到错误：“太多的重新渲染”](#我收到错误：“太多的重新渲染”) - [我的初始化或更新函数运行两次](#我的初始化或更新函数运行两次) - [我正在尝试将状态设置为一个函数，但它被调用了](#我正在尝试将状态设置为一个函数，但它被调用了) ### 参考 #### useState (initialState) useState(initialState) 在组件的顶层调用 useState 以声明 状态变量。 ```jsx import { useState } from 'react'; function MyComponent() { const [age, setAge] = useState(28); const [name, setName] = useState('Taylor'); const [todos, setTodos] = useState(() => createTodos()); // ... ``` 约定是使用 数组解构 命名状态变量，例如 [something, setSomething]。 - 参数 initialState：你希望状态的初始值。它可以是任何类型的值，但函数有特殊的行为。这个参数在初始渲染后被忽略。 如果你将函数作为 initialState 传递，它将被视为初始化函数。它应该是纯粹的，不带任何参数，并且应该返回任何类型的值。React 在初始化组件时会调用你的初始化函数，并将其返回值存储为初始状态。请参见下面的示例。 - 返回 Returns useState 返回一个恰好包含两个值的数组： 当前状态。在第一次渲染期间，它将与你传递的 initialState 相匹配。 set 函数 允许你将状态更新为不同的值并触发重新渲染。 - 注意事项 useState 是一个 Hook，所以你只能在你的组件的顶层或者你自己的钩子中调用它。你不能在循环或条件内调用它。如果需要，提取一个新组件并将状态移入其中。 在严格模式下，React 将调用你的初始化函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的初始化函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。 #### set 函数与 setSomething(nextState) 类似 useState 返回的 set 函数允许你将状态更新为不同的值并触发重新渲染。你可以直接传递下一个状态，或从前一个状态计算它的函数： ```jsx const [name, setName] = useState('Edward'); function handleClick() { setName('Taylor'); setAge(a => a + 1); // ... ``` - 参数 nextState：你希望状态成为的值。它可以是任何类型的值，但函数有特殊的行为。 如果你将函数作为 nextState 传递，它将被视为更新函数。它必须是纯粹的，应该将挂起状态作为其唯一参数，并且应该返回下一个状态。React 会将你的更新程序函数放入队列中并重新渲染你的组件。在下一次渲染期间，React 将通过将所有排队的更新器应用于前一个状态来计算下一个状态。请参见下面的示例。 - 返回 set 函数没有返回值。 - 注意事项 set 函数仅更新下一次渲染的状态变量。如果你在调用 set 函数后读取状态变量，则 你仍然会得到旧的值 在你调用之前显示在屏幕上。 如果你提供的新值与当前的 state 相同（通过 Object.is 比较确定），React 将跳过重新渲染组件及其子组件。这是一个优化。尽管在某些情况下 React 可能仍需要在跳过子级之前调用你的组件，但这不应该影响你的代码。 React 批量状态更新。 在所有事件处理程序运行并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在极少数情况下，你需要强制 React 提前更新屏幕，例如访问 DOM，你可以使用 flushSync。 set 函数具有稳定的标识，因此你经常会看到它从副作用依赖中省略，但包含它不会导致副作用触发。如果 linter 允许你在没有错误的情况下省略依赖，那么这样做是安全的。详细了解如何删除副作用依赖。 在渲染期间调用 set 函数只能从当前渲染组件中调用。React 将丢弃其输出并立即尝试使用新状态再次渲染它。这种模式很少需要，但你可以使用它来存储先前渲染的信息。请参见下面的示例。 在严格模式下，React 将调用你的更新程序函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的更新程序函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。 ##"},{"id":"v-20e3ed6c#useeffect","path":"/React/Hooks.html#useeffect","pageTitle":"hocks","headerTitle":"useEffect","text":"useEffect 一般这样写 const [count, setCount] = useState(10); useEffect 的第一个参数是一个函数 第二个参数是一个数组（依赖） 1. 如果只有一个参数的时候，相当于是 componentDidMount, componentDidUpdate 直接执行 2. 如果第二个参数是一个空数组，相当于 componentDidMount 刚开始执行一次 之后就不会在执行了 3. 如果不是空数组，相当于 componentDidMount 和 watch 依赖的值改变了里面就执行 4. 里面 return 一个函数，相当于 componentWillUnmount return 一个函数 在里面做清除定时器 卸载插件等操作 *如果在 useEffect 里面写封装好的数据请求 *会报警告 但是不会报错 说让数据请求写在 useEffect 里面 这是因为请求数据的时候 return 一个 fetch 如果 useEffect 里面 return 一个结果 那就相当于第 4 条变成 componentWillUnmount 了 解决办法： 第一参数里面写一个自执行函数 函数自执行了就没有 return 了 useEffect(() => { (async () => { const res = await getData(); console.log(res); })(); }, []); ##"},{"id":"v-20e3ed6c#uselayouteffect-和-useeffect-类似-大部分情况下-使用-useeffect","path":"/React/Hooks.html#uselayouteffect-和-useeffect-类似-大部分情况下-使用-useeffect","pageTitle":"hocks","headerTitle":"useLayoutEffect 和 useEffect 类似 大部分情况下 使用 useEffect","text":"useLayoutEffect 和 useEffect 类似 大部分情况下 使用 useEffect 区别： 简单来说就是调用时机不同，`useLayoutEffect`和原来`componentDidMount`&`componentDidUpdate`一致，在 react 完成 DOM 更新后马上**同步**调用的代码，会阻塞页面渲染。而`useEffect`是会在整个页面渲染完才会调用的代码 什么时候会用到呢 当你需要用 useEffect 去操作 dom 元素的时候 比如 useEfftct 让一个盒子在零秒内向右平移 100px 会出现闪屏 这时候就需要用到 useLayoutEffect ##"},{"id":"v-20e3ed6c#usememo-类似于-vue-中的计算属性","path":"/React/Hooks.html#usememo-类似于-vue-中的计算属性","pageTitle":"hocks","headerTitle":"useMemo - 类似于 vue 中的计算属性","text":"useMemo - 类似于 vue 中的计算属性 当函数式组件中的一个数据改变的时候 整个函数式组件都会重新渲染 如果不想让其他的函数也跟着重新渲染 这时候就需要给他加 useMemo 缓存起来 useMemo 类似于 vue 中的计算属性 区别"},{"id":"v-20e3ed6c#usecallback","path":"/React/Hooks.html#usecallback","pageTitle":"hocks","headerTitle":"useCallback","text":"useCallback 缓存的是函数本身 useMemo 缓存的是函数的返回值 useMemo 和 useCallback 也是可以互相改写的 利用上面的特性和函数柯理化 ## useCallback 是用来缓存函数的 当组件的数据改变的时候 默认是会全部重新渲染的 因为生命周期数据更新之后会重新 render 想让类组件里面的数据改变 并且引入的子组件不重新渲染 用 PureComponent 比较前后两次是否有变化 由于里面是对象 所以地址不同 所以把对象提出去定义成一个常量就好了 想让函数式组件里面的数据改变 并且引入的子组件不重新渲染 需要引入 memo memo 是一个高阶组件 给子组件套上 相当于类组件中的 PureComponent 然后把对象提到外面写 但是 如果函数式组件有一个自定义事件传参 需要用到函数里面的 state 就不能提到外面去写又由于函数式组件本身就相当于一个 render 他会把里面的所有东西从上往下执行 memo 将新的组件和旧的组件做对比的时候 这时候所产生的函数就又不是同一个函数了 地址不同 这时候就要用到 useCallback 来缓存函数 第一个参数是要缓存的函数，第二个参数是依赖- _只要函数式组件做自定义事件传参就要写_ 当一个事件要作为属性传递的时候使用它 写法 ： ```jsx import React, { useState, memo, useCallback } from \"react\"; // const fn2 = () => { // console.log(\"fn2\"); // }; const Child = memo(() => { console.log(\"Child\"); return ( <> <span> Child</span> </> ); }); const obj = { fontSize: 14 }; const App = () => { let [count, setCount] = useState(1); const fn = () => { setCount((count) => { return (count = count + 1); }); }; const fn2 = useCallback(() => { console.log(123); }, []); return ( <> <div> <Child style={obj} doSomething={fn2} /> <div>{count}</div> <button onClick={fn}>btn</button> {/_ <button onClick={fn2}>btn</button> _/} </div> </> ); }; ``` ##"},{"id":"v-20e3ed6c#浅谈-usememo-与-usecallback","path":"/React/Hooks.html#浅谈-usememo-与-usecallback","pageTitle":"hocks","headerTitle":"浅谈 useMemo 与 useCallback","text":"浅谈 useMemo 与 useCallback 简单的说 都是用来监听数据变化 来进行控制渲染、减少不必要的渲染 、优化性能 usecallback()是用来监听数据变化从而调用方法 usememo()是用来监听数据变化从而改变数据 使用 return 返回变化的数据 当然 return 也可以返回方法 所以 usememo()可以代替 usecallback() 下面详解 useCallback：缓存回调函数 在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。 比如下面的代码中，我们在加号按钮上定义了一个事件处理函数，用来让计数器加 1。但是因为定义是在函数组件内部，因此在多次渲染之间，是无法重用 handleIncrement 这个函数的，而是每次都需要创建一个新的： ```JavaScript function Counter() { const [count, setCount] = useState(0); const handleIncrement = () => setCount(count + 1); // ... return <button onClick={handleIncrement}>+</button> } ``` 你不妨思考下这个过程。每次组件状态发生变化的时候，函数组件实际上都会重新执行一遍。在每次执行的时候，实际上都会创建一个新的事件处理函数 handleIncrement。 这个事件处理函数中呢，包含了 count 这个变量的闭包，以确保每次能够得到正确的结果。 这也意味着，即使 count 没有发生变化，但是函数组件因为其它状态发生变化而重新渲染时，这种写法也会每次创建一个新的函数。 创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。因为这样做不仅增加了系统的开销，更重要的是：每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染。 比如这个例子中的 button 组件，接收了 handleIncrement ，并作为一个属性。如果每次都是一个新的，那么这个 React 就会认为这个组件的 props 发生了变化，从而必须重新渲染。因此，我们需要做到的是：**只有当 count 发生变化时，我们才需要重新定一个回调函数。**而这正是 useCallback 这个 Hook 的作用。 ```JavaScript import React, { useState, useCallback } from 'react'; function Counter() { const [count, setCount] = useState(0); const handleIncrement = useCallback( () => setCount(count + 1), [count], // 只有当 count 发生变化时，才会重新创建回调函数 ); // ... return <button onClick={handleIncrement}>+</button> } ``` 在这里，我们把 count 这个 state ，作为一个依赖传递给 useCallback。这样，只有 count 发生变化的时候，才需要重新创建一个回调函数，这样就保证了组件不会创建重复的回调函数。而接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。 useMemo：缓存计算的结果 如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算。 举个例子，对于一个显示用户信息的列表，现在需要对用户名进行搜索，且 UI 上需要根据搜索关键字显示过滤后的用户，那么这样一个功能需要有两个状态： 1.用户列表数据本身：来自某个请求。 2.搜索关键字：用户在搜索框输入的数据。 无论是两个数据中的哪一个发生变化，都需要过滤用户列表以获得需要展示的数据。那么如果不使用 useMemo 的话，就需要用这样的代码实现： ```JavaScript import React, { useState, useEffect } from \"react\"; export default function SearchUserList() { const [users, setUsers] = useState(null); const [searchKey, setSearchKey] = useState(\"\"); useEffect(() => { const doFetch = async () => { // 组件首次加载时发请求获取用户数据 const res = await fetch(\"https://reqres.in/api/users/\"); setUsers(await res.json()); }; doFetch(); }, []); let usersToShow = null; if (users) { // 无论组件为何刷新，这里一定会对数组做一次过滤的操作 usersToShow = users.data.filter((user) => user.first_name.includes(searchKey), ); } return ( <div> <input type=\"text\" value={searchKey} onChange={(evt) => setSearchKey(evt.target.value)} /> <ul> {usersToShow && usersToShow.length > 0 && usersToShow.map((user) => { return <li key={user.id}>{user.first_name}</li>; })} </ul> </div> ); } ``` 在这个例子中，无论组件为何要进行一次重新渲染，实际上都需要进行一次过滤的操作。但其实你只需要在 users 或者 searchKey 这两个状态中的某一个发生变化时，重新计算获得需要展示的数据就行了。那么，这个时候，我们就可以用 useMemo 这个 Hook 来实现这个逻辑，缓存计算的结果 ```JavaScript const usersToShow = useMemo(() => { if (!users) return null; return users.data.filter((user) => { return user.first_name.includes(searchKey)); } }, [users, searchKey]); ``` 可以看到，通过 useMemo 这个 Hook，可以避免在用到的数据没发生变化时进行的重复计算。虽然例子展示的是一个很简单的场景，但如果是一个复杂的计算，那么对于提升性能会有很大的帮助。 这也是 userMemo 的一大好处：避免重复计算。 除了避免重复计算之外，useMemo 还有一个很重要的好处：避免子组件的重复渲染。比如在例子中的 usersToShow 这个变量，如果每次都需要重新计算来得到，那么对于 UserList 这个组件而言，就会每次都需要刷新，因为它将 usersToShow 作为了一个属性。而一旦能够缓存上次的结果，就和 useCallback 的场景一样，可以避免很多不必要的组件刷新。 这个时候，如果我们结合 useMemo 和 useCallback 这两个 Hooks 一起看，会发现一个有趣的特性，那就是 useCallback 的功能其实是可以用 useMemo 来实现的。比如下面的代码就是利用 useMemo 实现了 useCallback 的功能： ```JavaScript const myEventHandler = useMemo(() => { // 返回一个函数作为缓存结果 return () => { // 在这里进行事件处理 } }, [dep1, dep2]); ``` 从本质上来说，useMemo 和 useCallback 只是做了同一件事情：建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。 ##"},{"id":"v-20e3ed6c#usecontext-用于优化-context-中-consumer-的写法","path":"/React/Hooks.html#usecontext-用于优化-context-中-consumer-的写法","pageTitle":"hocks","headerTitle":"useContext - 用于优化 Context 中 Consumer 的写法","text":"useContext - 用于优化 Context 中 Consumer 的写法 用于优化 Context 中 Consumer 的写法 Provider 还是要正常写 这个 hocks 就是可以传入 createContext 的实例 直接获取到结果 写法： const { Provider 中的 value } = useContext(context2); ##"},{"id":"v-20e3ed6c#usereducer-用于创建一个小型的仓库","path":"/React/Hooks.html#usereducer-用于创建一个小型的仓库","pageTitle":"hocks","headerTitle":"useReducer - 用于创建一个小型的仓库","text":"useReducer - 用于创建一个小型的仓库 reducer 函数的写法和 redux 一样 defaultState 也一样 state 不用写等于 defaultState 调用的时候引入 useuseReducer 有两个参数 第一个参数就是 reducer 函数 第二个是 defaultState 从 useReducer 中解构出 state 和 dispatch 调用就调用 state.count dispatch 中传入 type const [state, dispatch] = useReducer(reducer, defaultState); useReducer 里面没有中间键 不能写异步操作 如果要写异步可以写 useEffect 先请求数据 在吧请求到的数据放到仓库里面 ##"},{"id":"v-20e3ed6c#useref-类似于-createref-用于获取-dom-节点-用-ref-绑定一点就可以了-在父组件的子组件标签上添加一个-ref-属性等于-useref-的实例","path":"/React/Hooks.html#useref-类似于-createref-用于获取-dom-节点-用-ref-绑定一点就可以了-在父组件的子组件标签上添加一个-ref-属性等于-useref-的实例","pageTitle":"hocks","headerTitle":"useRef - 类似于 createRef 用于获取 Dom 节点 用 ref 绑定一点就可以了 在父组件的子组件标签上添加一个 ref 属性等于 useRef 的实例","text":"useRef - 类似于 createRef 用于获取 Dom 节点 用 ref 绑定一点就可以了 在父组件的子组件标签上添加一个 ref 属性等于 useRef 的实例 在父组件就可以使用这个 useRef 的实例 函数组件不能绑定 ref？ useRef 还有一些其他的特性 可以绕过 CaptureValue 的特征 利用 useRef 定义的数据 拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。比如你设置一个定时器 然后当定时器没完成的时候去改变他的值 在变回去 他拿到的还是一个最终状态 但是这个 useRef 不是很好用 没有响应式 ##"},{"id":"v-20e3ed6c#useimperativehandle-通过-useimperativehandle-用于让父组件获取子组件内的索引-通过父组件让子组件获得焦点","path":"/React/Hooks.html#useimperativehandle-通过-useimperativehandle-用于让父组件获取子组件内的索引-通过父组件让子组件获得焦点","pageTitle":"hocks","headerTitle":"useImperativeHandle 通过 useImperativeHandle 用于让父组件获取子组件内的索引 通过父组件让子组件获得焦点","text":"useImperativeHandle 通过 useImperativeHandle 用于让父组件获取子组件内的索引 通过父组件让子组件获得焦点 通过父组件让子组件获得焦点原理 在父组件里面定义一个 ref 等于 useRef 的返回值 在子组件标签中写 ref= {ref} ，让子组件套上一个 forwardRef 高阶组件然后子组件自己也去定义一个 ref 和父组件的名称一样 给子组件中的元素也加上这个 ref 属性 然后在子组件中使用 useImperativeHandle 函数组件可以接受第二个参数 ref useImperativeHandle 的第一个参数是 ref 第二个参数是 input 标签中的那个 ref 的 current 去改变 ref 的指向 让父组件的子组件标签中的 ref 去指向 input 的 ref # redux 提供的两个 hocks ##"},{"id":"v-20e3ed6c#useselect-用于获取仓库数据的","path":"/React/Hooks.html#useselect-用于获取仓库数据的","pageTitle":"hocks","headerTitle":"useSelect 用于获取仓库数据的","text":"useSelect 用于获取仓库数据的 用于获取仓库数据的 useSelect 接收一个函数作为参数 写法： const list = useSelector((state) => state.list); ##"},{"id":"v-20e3ed6c#usedispatch-用于调用-reducer-函数","path":"/React/Hooks.html#usedispatch-用于调用-reducer-函数","pageTitle":"hocks","headerTitle":"useDispatch 用于调用 reducer 函数","text":"useDispatch 用于调用 reducer 函数 useDispatch 用于调用 reducer 函数 传入一个参数是对象 相当于 action ##"},{"id":"v-20e3ed6c#usehistory-用于做页面跳转","path":"/React/Hooks.html#usehistory-用于做页面跳转","pageTitle":"hocks","headerTitle":"useHistory 用于做页面跳转","text":"useHistory 用于做页面跳转 useHistory 用于做页面跳转 useHistory 的实例对象下面有 push go 等方法可以进行路由跳转 ##"},{"id":"v-20e3ed6c#uselocation-是用来获取路由信息下的-location-对象","path":"/React/Hooks.html#uselocation-是用来获取路由信息下的-location-对象","pageTitle":"hocks","headerTitle":"useLocation 是用来获取路由信息下的 location 对象","text":"useLocation 是用来获取路由信息下的 location 对象 是用来获取路由信息下的 location 对象 也可以用来做跳转 ##"},{"id":"v-20e3ed6c#自定义-hocks-相当于-vue-中的组合-api-相同的功能放在一个文件里面","path":"/React/Hooks.html#自定义-hocks-相当于-vue-中的组合-api-相同的功能放在一个文件里面","pageTitle":"hocks","headerTitle":"自定义 hocks 相当于 vue 中的组合 API 相同的功能放在一个文件里面","text":"自定义 hocks 相当于 vue 中的组合 API 相同的功能放在一个文件里面"},{"id":"v-9b4d9c76","path":"/React/Hooks/useActionState.html","pageTitle":"useActionState","headerTitle":null,"text":"# useActionState ##"},{"id":"v-9b4d9c76#_1-useactionstate-简介","path":"/React/Hooks/useActionState.html#_1-useactionstate-简介","pageTitle":"useActionState","headerTitle":"1. useActionState 简介","text":"1. useActionState 简介 `useActionState` 是 React 18 引入的一个新的 Hook，主要用于在表单或交互操作中结合异步 Server Actions（如 Next.js 的 server actions）和本地 UI 状态管理。它适用于需要在用户操作后异步处理数据并反馈结果的场景，比如提交表单、批量操作等。 - `useActionState` 使得**异步操作的结果和状态管理更加集中和清晰**，尤其适合 Server Components 和结合 Next.js 的 App Router 使用。 - 其设计类似于 `useReducer`，但专为异步 Server Actions 场景优化。 ##"},{"id":"v-9b4d9c76#_2-基本用法","path":"/React/Hooks/useActionState.html#_2-基本用法","pageTitle":"useActionState","headerTitle":"2. 基本用法","text":"2. 基本用法 `useActionState` 的典型用法如下： ```tsx const [state, formAction, isPending] = useActionState( async (prevState, formData) => { // 这里执行异步操作，比如调用 server action const result = await submitData(formData); return result; }, initialState // 初始状态 ); ``` - `state`: 当前的状态（上一次 action 的返回值）。 - `formAction`: 一个可传递给 `<form action={formAction}>` 的处理函数。 - `isPending`: 是否正在处理 action（可用于 loading 状态）。 ###"},{"id":"v-9b4d9c76#示例","path":"/React/Hooks/useActionState.html#示例","pageTitle":"useActionState","headerTitle":"示例","text":"示例 ```tsx \"use client\"; import { useActionState } from \"react\"; async function submit(formData) { // 假设这里是异步提交逻辑 return { message: \"提交成功！\" }; } export default function MyForm() { const [state, formAction, isPending] = useActionState( async (prevState, formData) => { return await submit(formData); }, { message: \"\" } ); return ( <form action={formAction}> <input name=\"username\" /> <button type=\"submit\" disabled={isPending}> 提交 </button> <p>{state.message}</p> </form> ); } ``` ##"},{"id":"v-9b4d9c76#_3-useactionstate-的参数说明","path":"/React/Hooks/useActionState.html#_3-useactionstate-的参数说明","pageTitle":"useActionState","headerTitle":"3. useActionState 的参数说明","text":"3. useActionState 的参数说明 - **处理函数**(`reducer`)：接收上一个 state 和 formData（或 action 参数），返回新的状态（可为 Promise）。 - **初始状态**(`initialState`)：第一次渲染时的状态。 - **可选依赖项**：当依赖项变化时，action state 会重置。 ##"},{"id":"v-9b4d9c76#_4-使用场景","path":"/React/Hooks/useActionState.html#_4-使用场景","pageTitle":"useActionState","headerTitle":"4. 使用场景","text":"4. 使用场景 - 处理表单提交：集中管理异步提交的 loading、success、error 等 UI 状态。 - 与 Next.js 服务器 Actions 结合：直接将 server action 作为处理函数，自动管理请求状态。 - 替代 `useState` + 手动管理 loading/error，减少样板代码。 ##"},{"id":"v-9b4d9c76#_5-注意事项与最佳实践","path":"/React/Hooks/useActionState.html#_5-注意事项与最佳实践","pageTitle":"useActionState","headerTitle":"5. 注意事项与最佳实践","text":"5. 注意事项与最佳实践 - 适合与 Server Actions/异步操作配合，不适合仅做同步本地状态管理。 - 只在客户端组件（`'use client'`）中使用。 - 返回的 `isPending` 很适合用来做按钮 loading 态或防止重复提交。 - 如果依赖外部值，记得作为依赖项传入（第三参数）。 - 对于复杂表单/多步骤，可配合 reducer 方式统一管理复杂状态。 ##"},{"id":"v-9b4d9c76#_6-与其他相关-api-区别","path":"/React/Hooks/useActionState.html#_6-与其他相关-api-区别","pageTitle":"useActionState","headerTitle":"6. 与其他相关 API 区别","text":"6. 与其他相关 API 区别 - `useState`：简单本地状态，无异步 Action 概念。 - `useReducer`：适合复杂本地状态，但不专为异步提交优化。 - `useTransition`：用于管理 UI 过渡的异步，不直接用于表单 action。 ##"},{"id":"v-9b4d9c76#_7-官方文档与推荐阅读","path":"/React/Hooks/useActionState.html#_7-官方文档与推荐阅读","pageTitle":"useActionState","headerTitle":"7. 官方文档与推荐阅读","text":"7. 官方文档与推荐阅读 - [React 官方 useActionState 文档](https://react.dev/reference/react/useActionState) - [Next.js Server Actions 与 useActionState 配合示例](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions#useactionstate) ---"},{"id":"v-5137b446","path":"/React/Hooks/useContext.html","pageTitle":"useContext","headerTitle":null,"text":"# useContext `useContext` 是 React 提供的一个 Hook，用于在函数组件中直接读取和订阅 context 上下文数据。它极大地方便了组件间深层数据传递，避免了层层 props 传递。 --- ##"},{"id":"v-5137b446#基本用法","path":"/React/Hooks/useContext.html#基本用法","pageTitle":"useContext","headerTitle":"基本用法","text":"基本用法 ```js const value = useContext(SomeContext); ``` - `SomeContext` 是你通过 `createContext` 创建的 context 对象。 **示例：** ```js import { useContext } from \"react\"; function MyComponent() { const theme = useContext(ThemeContext); // ...可以直接用 theme 变量 } ``` --- ##"},{"id":"v-5137b446#主要用途","path":"/React/Hooks/useContext.html#主要用途","pageTitle":"useContext","headerTitle":"主要用途","text":"主要用途 1. **向组件树深层传递数据**，比如主题、用户信息等。 2. **通过 context 实现数据的动态更新**。 3. **为 context 指定默认值，作为后备方案**。 4. **可以覆盖组件树某一部分的 context**，实现局部配置。 5. **在传递对象和函数时优化重新渲染，提升性能**。 --- ##"},{"id":"v-5137b446#参数与返回值","path":"/React/Hooks/useContext.html#参数与返回值","pageTitle":"useContext","headerTitle":"参数与返回值","text":"参数与返回值 - **参数：** `SomeContext` —— 你通过 `createContext` 创建的 context 对象。本身不包含数据，只代表一种可传递的信息类型。 - **返回值：** `useContext` 返回离当前组件最近的 Provider 提供的 `value`。如果上层没有 Provider，则返回创建 context 时设置的默认值（`createContext(defaultValue)` 的那个值）。 **注意：** context 的值发生变化时，React 会自动重新渲染所有使用了该 context 的组件。 --- ##"},{"id":"v-5137b446#注意事项","path":"/React/Hooks/useContext.html#注意事项","pageTitle":"useContext","headerTitle":"注意事项","text":"注意事项 - `useContext()` 只会向上查找**调用它的组件**外层最近的 Provider，**不会受本组件内部 Provider 影响**。 - 只要 Provider 的 value 发生变化，所有下层用到该 context 的组件都会重新渲染，且 React 使用 `Object.is` 比较新旧值。 - 要保证传递 context 的对象和读取 context 的对象是**完全相同的引用**，否则会导致 context 取值失效。这点在使用 monorepo 或符号链接开发时需特别注意。 --- ##"},{"id":"v-5137b446#实战用法","path":"/React/Hooks/useContext.html#实战用法","pageTitle":"useContext","headerTitle":"实战用法","text":"实战用法 ###"},{"id":"v-5137b446#_1-深层组件数据传递","path":"/React/Hooks/useContext.html#_1-深层组件数据传递","pageTitle":"useContext","headerTitle":"1. 深层组件数据传递","text":"1. 深层组件数据传递 ```js import { createContext, useContext } from \"react\"; const ThemeContext = createContext(\"light\"); function Button() { const theme = useContext(ThemeContext); return <button className={`button-${theme}`}>按钮</button>; } function App() { // ThemeContext.Provider 提供 value return ( <ThemeContext.Provider value=\"dark\"> <Button /> </ThemeContext.Provider> ); } ``` - 只要 Button 组件在 Provider 内部，无论嵌套多深，都能直接拿到 `value`。 --- ###"},{"id":"v-5137b446#_2-动态更新-context","path":"/React/Hooks/useContext.html#_2-动态更新-context","pageTitle":"useContext","headerTitle":"2. 动态更新 context","text":"2. 动态更新 context ```js import { createContext, useContext, useState } from \"react\"; const ThemeContext = createContext(\"light\"); function MyApp() { const [theme, setTheme] = useState(\"light\"); return ( <ThemeContext.Provider value={theme}> <Form /> <button onClick={() => setTheme(theme === \"light\" ? \"dark\" : \"light\")}> 切换主题 </button> </ThemeContext.Provider> ); } function Form() { const theme = useContext(ThemeContext); return <div className={`form-${theme}`}>表单内容</div>; } ``` - Provider 的 value 可以是 state，更新 state 会自动刷新下层所有依赖该 context 的组件。 --- ###"},{"id":"v-5137b446#_3-指定默认值","path":"/React/Hooks/useContext.html#_3-指定默认值","pageTitle":"useContext","headerTitle":"3. 指定默认值","text":"3. 指定默认值 ```js const ThemeContext = createContext(\"light\"); ``` - 如果组件树中没有 Provider，`useContext(ThemeContext)` 返回的就是 `'light'`。 - 默认值不会变，只有在 Provider 缺失时才生效。 --- ###"},{"id":"v-5137b446#_4-覆盖部分树的-context","path":"/React/Hooks/useContext.html#_4-覆盖部分树的-context","pageTitle":"useContext","headerTitle":"4. 覆盖部分树的 context","text":"4. 覆盖部分树的 context ```js <ThemeContext.Provider value=\"dark\"> <Button /> {/* 这里的按钮是 dark */} <ThemeContext.Provider value=\"light\"> <Footer /> {/* 这里的 Footer 及其子组件是 light */} </ThemeContext.Provider> </ThemeContext.Provider> ``` - 多层 Provider 可以实现局部覆盖。 --- ###"},{"id":"v-5137b446#_5-传递对象和函数、优化性能","path":"/React/Hooks/useContext.html#_5-传递对象和函数、优化性能","pageTitle":"useContext","headerTitle":"5. 传递对象和函数、优化性能","text":"5. 传递对象和函数、优化性能 ```js import { useCallback, useMemo, useState, createContext } from \"react\"; const AuthContext = createContext(null); function MyApp() { const [currentUser, setCurrentUser] = useState(null); // 用 useCallback 保证 login 函数引用稳定 const login = useCallback((response) => { // 登录逻辑... setCurrentUser(response.user); }, []); // 用 useMemo 保证 context value 对象引用稳定 const contextValue = useMemo( () => ({ currentUser, login, }), [currentUser, login] ); return ( <AuthContext.Provider value={contextValue}> <Page /> </AuthContext.Provider> ); } ``` - 这样可以减少 context 变化导致的无效重渲染。 --- ##"},{"id":"v-5137b446#常见问题与排查","path":"/React/Hooks/useContext.html#常见问题与排查","pageTitle":"useContext","headerTitle":"常见问题与排查","text":"常见问题与排查 ###"},{"id":"v-5137b446#_1-取不到-provider-传递的值","path":"/React/Hooks/useContext.html#_1-取不到-provider-传递的值","pageTitle":"useContext","headerTitle":"1. 取不到 Provider 传递的值？","text":"1. 取不到 Provider 传递的值？ - 检查 useContext 调用的组件是否确实被对应 Provider 包裹。 - 确认 Provider 和 useContext 用的是**同一个 context 对象**（不能 import 两次或路径不同）。 - 检查是否写漏了 Provider 的 `value` 属性，或属性名写错。 ###"},{"id":"v-5137b446#_2-总是拿到-undefined-或默认值","path":"/React/Hooks/useContext.html#_2-总是拿到-undefined-或默认值","pageTitle":"useContext","headerTitle":"2. 总是拿到 undefined 或默认值？","text":"2. 总是拿到 undefined 或默认值？ - Provider 写法错误，如： ```jsx <ThemeContext>...</ThemeContext> // 错误！缺少 value <ThemeContext theme={theme}>...</ThemeContext> // 错误！应为 value={theme} ``` 正确写法应为： ```jsx <ThemeContext.Provider value={theme}>...</ThemeContext.Provider> ``` - 如果 Provider 的 value 是 `undefined`，下层会收到 undefined 而不是默认值。 - 只有**组件树上没有任何 Provider 时**，才会用默认值。 --- ##"},{"id":"v-5137b446#总结","path":"/React/Hooks/useContext.html#总结","pageTitle":"useContext","headerTitle":"总结","text":"总结 - `useContext` 让你在任何函数组件中方便地读取 context 数据。 - 搭配 Provider 可实现全局或局部数据共享、跨层通信。 - 动态 value 结合 state 实现响应式全局数据。 - 复杂对象建议用 useMemo/useCallback 优化。 - 遇到问题多检查 Provider 包裹、value 设置和 context 对象引用。 ---"},{"id":"v-5ff49182","path":"/React/Hooks/useCallback.html","pageTitle":"useCallback","headerTitle":null,"text":"# useCallback `useCallback` 是 React 提供的一个 Hook，用于在组件多次渲染时缓存某个函数。只有依赖项发生变化时，才会返回新函数，否则复用上一次的函数引用，常用于性能优化。 --- ##"},{"id":"v-5ff49182#基本用法","path":"/React/Hooks/useCallback.html#基本用法","pageTitle":"useCallback","headerTitle":"基本用法","text":"基本用法 ```js const cachedFn = useCallback(fn, dependencies); ``` - `fn`：你希望缓存的函数。可以有参数，返回任意值，但 React **不会自动调用**，只负责返回该函数本身。 - `dependencies`：依赖项数组，包含所有在 `fn` 内用到的响应式变量（如 props、state 等）。只有依赖项发生变化时才会更新函数引用。 **示例：** ```js import { useCallback } from \"react\"; function ProductPage({ productId, referrer }) { const handleSubmit = useCallback( (orderDetails) => { post(\"/product/\" + productId + \"/buy\", { referrer, orderDetails, }); }, [productId, referrer] ); // ... } ``` --- ##"},{"id":"v-5ff49182#适用场景","path":"/React/Hooks/useCallback.html#适用场景","pageTitle":"useCallback","headerTitle":"适用场景","text":"适用场景 - **跳过不必要的子组件渲染** 和 `React.memo` 搭配，避免因为函数引用变化导致子组件重新渲染。 - **记忆化回调中安全更新 state** 用于事件处理、异步回调等，避免闭包陷阱。 - **防止副作用（Effect）频繁触发** 提供稳定的回调引用，减少不必要的 effect 执行。 - **优化自定义 Hook 的函数导出** 让自定义 Hook 的返回函数在依赖不变时始终保持引用不变。 --- ##"},{"id":"v-5ff49182#参数与返回值","path":"/React/Hooks/useCallback.html#参数与返回值","pageTitle":"useCallback","headerTitle":"参数与返回值","text":"参数与返回值 - **参数** - `fn`：要缓存的函数。 - `dependencies`：依赖数组。React 用 `Object.is` 比较依赖项是否变化。 - **返回值** - 返回当前或缓存的 `fn`，只有依赖项变化时才会返回新的函数引用。 --- ##"},{"id":"v-5ff49182#注意事项","path":"/React/Hooks/useCallback.html#注意事项","pageTitle":"useCallback","headerTitle":"注意事项","text":"注意事项 - **只能在组件顶层或自定义 Hook 内调用**，不能在循环或条件中用。 - **开发环境热更新或组件挂载中断时，缓存会被丢弃。** 生产环境下，只有依赖变才会变。 - **仅作性能优化手段**，不要让业务逻辑依赖 useCallback，否则需先修复逻辑问题再用它优化。 - **不要滥用**，只有当真的有性能瓶颈（比如和 memo 组件配合）时再用。 --- ##"},{"id":"v-5ff49182#常见用法详解","path":"/React/Hooks/useCallback.html#常见用法详解","pageTitle":"useCallback","headerTitle":"常见用法详解","text":"常见用法详解 ###"},{"id":"v-5ff49182#跳过子组件的重新渲染","path":"/React/Hooks/useCallback.html#跳过子组件的重新渲染","pageTitle":"useCallback","headerTitle":"跳过子组件的重新渲染","text":"跳过子组件的重新渲染 ```js import { memo, useCallback } from \"react\"; const ShippingForm = memo(function ShippingForm({ onSubmit }) { // ...表单内容 }); function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback( (orderDetails) => { post(\"/product/\" + productId + \"/buy\", { referrer, orderDetails }); }, [productId, referrer] ); return ( <div className={theme}> <ShippingForm onSubmit={handleSubmit} /> </div> ); } ``` > 只有当 `productId` 或 `referrer` 变化时，`handleSubmit` 才变化，ShippingForm 才会重新渲染，否则复用同一个函数引用，提升性能。 --- ###"},{"id":"v-5ff49182#记忆化回调中安全更新-state","path":"/React/Hooks/useCallback.html#记忆化回调中安全更新-state","pageTitle":"useCallback","headerTitle":"记忆化回调中安全更新 state","text":"记忆化回调中安全更新 state #### 错误写法（依赖项太多，闭包可能取到旧 state）： ```js const handleAddTodo = useCallback( (text) => { const newTodo = { id: nextId++, text }; setTodos([...todos, newTodo]); }, [todos] ); ``` #### 推荐写法（用 updater，依赖项可减少到空数组）： ```js const handleAddTodo = useCallback((text) => { const newTodo = { id: nextId++, text }; setTodos((todos) => [...todos, newTodo]); }, []); ``` > 这样不会因为 todos 变化频繁导致缓存失效，也避免了闭包陷阱。 --- ###"},{"id":"v-5ff49182#防止-effect-频繁触发","path":"/React/Hooks/useCallback.html#防止-effect-频繁触发","pageTitle":"useCallback","headerTitle":"防止 Effect 频繁触发","text":"防止 Effect 频繁触发 #### 错误写法（每次渲染函数引用都变）： ```js function ChatRoom({ roomId }) { function createOptions() { return { serverUrl: \"https://localhost:1234\", roomId }; } useEffect(() => { const options = createOptions(); // ... }, [createOptions]); } ``` #### 优化写法（用 useCallback 保证 createOptions 稳定）： ```js const createOptions = useCallback( () => ({ serverUrl: \"https://localhost:1234\", roomId, }), [roomId] ); useEffect(() => { const options = createOptions(); // ... }, [createOptions]); ``` #### 更佳方式（直接写在 effect 内，无需 useCallback）： ```js useEffect(() => { function createOptions() { return { serverUrl: \"https://localhost:1234\", roomId }; } const options = createOptions(); // ... }, [roomId]); ``` > Effect 依赖项更明确，代码更清晰。 --- ###"},{"id":"v-5ff49182#优化自定义-hook","path":"/React/Hooks/useCallback.html#优化自定义-hook","pageTitle":"useCallback","headerTitle":"优化自定义 Hook","text":"优化自定义 Hook ```js function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback( (url) => { dispatch({ type: \"navigate\", url }); }, [dispatch] ); const goBack = useCallback(() => { dispatch({ type: \"back\" }); }, [dispatch]); return { navigate, goBack }; } ``` > 这样使用者在依赖这些函数时，可以获得更好的性能优化。 --- ##"},{"id":"v-5ff49182#疑难解答","path":"/React/Hooks/useCallback.html#疑难解答","pageTitle":"useCallback","headerTitle":"疑难解答","text":"疑难解答 ###"},{"id":"v-5ff49182#_1-每次渲染-usecallback-都返回新函数","path":"/React/Hooks/useCallback.html#_1-每次渲染-usecallback-都返回新函数","pageTitle":"useCallback","headerTitle":"1. 每次渲染 useCallback 都返回新函数？","text":"1. 每次渲染 useCallback 都返回新函数？ - 检查是否正确传递了依赖数组。 - 依赖项变化会导致新函数生成。可用 console.log 检查依赖项，定位是哪个依赖导致缓存失效。 ###"},{"id":"v-5ff49182#_2-循环中不能调用-usecallback","path":"/React/Hooks/useCallback.html#_2-循环中不能调用-usecallback","pageTitle":"useCallback","headerTitle":"2. 循环中不能调用 useCallback","text":"2. 循环中不能调用 useCallback **错误写法：** ```js items.map((item) => { const handleClick = useCallback(() => sendReport(item), [item]); // ❌ return <Chart onClick={handleClick} />; }); ``` > Hook 只能在顶层调用，不能在循环或条件中。 **正确写法：** ```js items.map((item) => <Report key={item.id} item={item} />); function Report({ item }) { const handleClick = useCallback(() => sendReport(item), [item]); return <Chart onClick={handleClick} />; } ``` 或直接将 Report 包裹在 memo 中，去掉 useCallback。 --- ##"},{"id":"v-5ff49182#总结","path":"/React/Hooks/useCallback.html#总结","pageTitle":"useCallback","headerTitle":"总结","text":"总结 - `useCallback` 主要用于缓存函数，避免因函数引用变化导致子组件或 Effect 不必要地重新渲染或执行。 - 只有依赖项变化时才生成新函数，否则复用同一函数引用。 - 搭配 `React.memo`、自定义 Hook、Effect 等场景使用效果最佳。 - 只是性能优化，不要滥用，不能依赖其实现业务逻辑。 > 推荐在实际项目中多练习，理解 useCallback 的实际作用和最佳实践。"},{"id":"v-280d2a9f","path":"/React/Hooks/useImperativeHandle.html","pageTitle":"useImperativeHandle","headerTitle":null,"text":"# useImperativeHandle `useImperativeHandle` 是 React 提供的一个高级 Hook，常与 `forwardRef` 配合使用，用于**自定义暴露给父组件的 ref 实例值**。它允许你控制父组件通过 ref 能访问到哪些属性或方法，而不是将整个子组件实例或 DOM 暴露出去。 --- ##"},{"id":"v-280d2a9f#基本用法","path":"/React/Hooks/useImperativeHandle.html#基本用法","pageTitle":"useImperativeHandle","headerTitle":"基本用法","text":"基本用法 ```js useImperativeHandle(ref, createHandle, [deps]); ``` - **ref**：父组件传递进来的 ref 对象（通常由 `forwardRef` 提供）。 - **createHandle**：返回暴露给父组件的对象（包含你希望父组件访问的方法或属性）。 - **deps**（可选）：依赖项数组，只有依赖变化时才会重新生成 handle 对象。 --- ##"},{"id":"v-280d2a9f#典型场景","path":"/React/Hooks/useImperativeHandle.html#典型场景","pageTitle":"useImperativeHandle","headerTitle":"典型场景","text":"典型场景 - 需要让父组件通过 ref 访问子组件的某些方法（如表单校验、强制聚焦、重置状态等）。 - 不希望直接暴露子组件内部的所有内容，只暴露指定接口，保证封装性。 --- ##"},{"id":"v-280d2a9f#基本示例","path":"/React/Hooks/useImperativeHandle.html#基本示例","pageTitle":"useImperativeHandle","headerTitle":"基本示例","text":"基本示例 ```js import React, { useRef, useImperativeHandle, forwardRef } from \"react\"; const MyInput = forwardRef((props, ref) => { const inputRef = useRef(); useImperativeHandle(ref, () => ({ focus: () => { inputRef.current.focus(); }, getValue: () => { return inputRef.current.value; }, })); return <input ref={inputRef} />; }); function Parent() { const inputRef = useRef(); const handleFocus = () => { inputRef.current.focus(); // 调用子组件暴露的 focus 方法 }; const handleGetValue = () => { alert(inputRef.current.getValue()); }; return ( <> <MyInput ref={inputRef} /> <button onClick={handleFocus}>聚焦输入框</button> <button onClick={handleGetValue}>获取输入值</button> </> ); } ``` --- ##"},{"id":"v-280d2a9f#参数与返回值","path":"/React/Hooks/useImperativeHandle.html#参数与返回值","pageTitle":"useImperativeHandle","headerTitle":"参数与返回值","text":"参数与返回值 - **ref**：由 `forwardRef` 传递进来的 ref 引用。 - **createHandle**：返回一个对象，这个对象的属性/方法会被父组件通过 ref 访问到。 - **deps**：依赖数组，handle 只有在依赖变化时才会重新生成（一般与 useMemo 类似）。 --- ##"},{"id":"v-280d2a9f#注意事项","path":"/React/Hooks/useImperativeHandle.html#注意事项","pageTitle":"useImperativeHandle","headerTitle":"注意事项","text":"注意事项 1. **必须配合 forwardRef 使用** 子组件必须用 `forwardRef` 包裹，否则无法接收到 ref 参数。 2. **不要直接暴露 DOM 或内部全部内容** 通过 useImperativeHandle，只暴露需要的接口，保证组件内部封装性。 3. **依赖项传递** 如果暴露的内容依赖于组件的 state 或 props，记得把相关变量加到 deps 中。 4. **仅用于需要场景** 大多数情况下，推荐用 props 向下传递行为和数据。只有在必须让父组件主动调用子组件方法时才使用。 --- ##"},{"id":"v-280d2a9f#实用场景举例","path":"/React/Hooks/useImperativeHandle.html#实用场景举例","pageTitle":"useImperativeHandle","headerTitle":"实用场景举例","text":"实用场景举例 - 表单组件：父组件可以通过 ref 调用子组件的校验、重置等方法。 - 自定义输入组件：父组件调用 focus、blur、select 等方法。 - 控制动画：父组件通过 ref 启动或停止子组件动画。 --- ##"},{"id":"v-280d2a9f#总结","path":"/React/Hooks/useImperativeHandle.html#总结","pageTitle":"useImperativeHandle","headerTitle":"总结","text":"总结 - `useImperativeHandle` 用于定制暴露给父组件的 ref 接口，保证封装和安全。 - 必须与 `forwardRef` 配合使用。 - 只暴露必要的方法或属性，避免破坏组件的封装性。 - 使用时关注依赖项，保持暴露接口的正确性。 > 推荐只在确实需要让父组件“主动”操作子组件时使用，平时多用 props 传递数据和行为。"},{"id":"v-3031c502","path":"/React/Hooks/useEffect.html","pageTitle":"useEffect","headerTitle":null,"text":"# useEffect ##"},{"id":"v-3031c502#参考","path":"/React/Hooks/useEffect.html#参考","pageTitle":"useEffect","headerTitle":"参考","text":"参考 ###"},{"id":"v-3031c502#useeffect-setup-dependencies","path":"/React/Hooks/useEffect.html#useeffect-setup-dependencies","pageTitle":"useEffect","headerTitle":"useEffect(setup, dependencies?)","text":"useEffect(setup, dependencies?) 在组件的顶层调用 useEffect 以声明一个 useEffect： ```jsx import { useState, useEffect } from \"react\"; import { createConnection } from \"./chat.js\"; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); // ... } ``` [请参阅下面的更多示例。](#"},{"id":"v-3031c502#用法","path":"/React/Hooks/useEffect.html#用法","pageTitle":"useEffect","headerTitle":"用法","text":"用法) #### 参数 - setup：具有 useEffect 逻辑的函数。你的设置函数也可以选择返回一个清理函数。当你的组件被添加到 DOM 时，React 将运行你的设置函数。在每次使用更改的依赖重新渲染后，React 将首先使用旧值运行清理函数（如果你提供了它），然后使用新值运行你的设置函数。在你的组件从 DOM 中移除后，React 将运行你的清理函数。 - 可选 dependencies：setup 代码中引用的所有反应值的列表。反应值包括属性、状态以及直接在组件主体内声明的所有变量和函数。如果你的 linter 是 为 React 配置，它将验证每个反应值是否正确指定为依赖。依赖列表必须具有恒定数量的条目，并且像 [dep1, dep2, dep3] 一样写成内联。React 将使用 Object.is 比较将每个依赖与其先前的值进行比较。如果省略此参数，你的 useEffect 将在每次重新渲染组件后重新运行。查看传递依赖数组、空数组和完全不依赖之间的区别。 #### 返回 useEffect 返回 undefined。 #### 注意事项 - useEffect 是一个 Hook，所以你只能在你的组件的顶层或者你自己的钩子中调用它。你不能在循环或条件内调用它。如果需要，提取一个新组件并将状态移入其中。 - 如果你不尝试与某些外部系统同步，你可能不需要 useEffect - 当严格模式打开时，React 将在第一次真正设置之前运行一个额外的仅开发设置+清理周期。这是一个压力测试，可确保你的清理逻辑 “mirrors” 你的设置逻辑，并确保它停止或撤消设置正在执行的任何操作。如果这导致问题，实现清理函数。 - 如果你的某些依赖是在组件内部定义的对象或函数，则存在它们会导致 useEffect 重新运行频率超过所需频率的风险。要解决此问题，请删除不必要的 object 和 函数 依赖。你也可以在 useEffect 器之外进行 提取状态更新 和 非 React 性逻辑。 - 如果你的 useEffect 不是由交互（如点击）引起的，React 通常会让浏览器在运行你的 useEffect 之前先绘制更新的屏幕。如果你的效果正在执行一些视觉操作（例如，定位工具提示），并且延迟很明显（例如，它闪烁），请将 useEffect 替换为 useLayoutEffect。 - 如果你的效果是由交互（如点击）引起的，React 可能会在浏览器绘制更新的屏幕之前运行你的效果。这可确保事件系统可以观察到效果的结果。通常，这会按预期工作。但是，如果你必须将工作推迟到绘制之后，例如 alert()，则可以使用 setTimeout。有关更多信息，请参阅 reactwg/react-18/128。 - 即使你的效果是由交互（如点击）引起的，React 也可能允许浏览器在处理效果内的状态更新之前重新绘制屏幕。通常，这会按预期工作。但是，如果必须阻止浏览器重新绘制屏幕，则需要将 useEffect 替换为 useLayoutEffect。 - useEffect 仅在客户端上运行。它们不会在服务器渲染期间运行。 ## 用法 ###"},{"id":"v-3031c502#连接到外部系统","path":"/React/Hooks/useEffect.html#连接到外部系统","pageTitle":"useEffect","headerTitle":"连接到外部系统","text":"连接到外部系统 有些组件在页面上显示时，需要与网络、某些浏览器 API 或第三方库保持连接。这些系统不受 React 控制，因此它们被称为外部系统。 要在组件的顶层调用 将你的组件连接到某个外部系统，请调用 useEffect： ```jsx import { useState, useEffect } from \"react\"; import { createConnection } from \"./chat.js\"; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); // ... } ``` - 你需要将两个参数传递给 useEffect： 1. 具有连接到该系统的 setup code 的设置函数。 - 它应该返回一个清理函数，其中包含与该系统断开连接的 清理代码。 2. 依赖列表，包括在这些函数中使用的组件中的每个值。 **React 会在必要时调用你的设置和清理函数，这可能会发生多次：** 1. 组件挂载时运行设置代码 ```jsx useEffect(() => { console.log(\"设置代码运行\"); // 组件挂载时执行 return () => { console.log(\"清理代码运行\"); }; }, []); ``` 首次渲染：只有设置函数执行 生产环境表现：组件添加到 DOM 后立即运行设置函数 开发环境表现：在严格模式下，React 可能会先挂载 → 卸载 → 重新挂载组件来检测问题 2. 依赖项变化时的执行顺序 ```jsx useEffect(() => { console.log(\"设置代码运行，当前count:\", count); return () => { console.log(\"清理代码运行，上一个count:\", count); }; }, [count]); // 依赖count ``` 当 count 从 1 变为 2 时的执行顺序： 清理阶段：使用旧值(1)运行清理函数 设置阶段：使用新值(2)运行设置函数 3. 组件卸载时的清理 ```jsx useEffect(() => { const timer = setInterval(() => {}, 1000); return () => { clearInterval(timer); // 组件卸载时执行 }; }, []); ``` 当组件从 DOM 移除时，React 会执行最后一次清理 这是防止内存泄漏的关键机制 - 实际场景示例 订阅数据源示例 ```jsx useEffect(() => { console.log(\"订阅用户数据，ID:\", userId); const subscription = dataSource.subscribe(userId); return () => { console.log(\"取消订阅，ID:\", userId); subscription.unsubscribe(); }; }, [userId]); // 依赖 userId ``` 当 userId 变化时的执行流程： 1. 用户 A(id=1)进入页面： 输出：\"订阅用户数据，ID:1\" 2. 用户切换到用户 B(id=2)： 输出：\"取消订阅，ID:1\" (清理旧订阅) 输出：\"订阅用户数据，ID:2\" (设置新订阅) 3. 离开页面： 输出：\"取消订阅，ID:2\" (最终清理) - 为什么需要这种机制？ 资源管理：避免内存泄漏(如未清除的定时器、订阅) 状态一致性：确保 Effect 总是使用最新的 props 和 state 竞态条件预防：清理函数可以取消旧的异步请求 - 开发 vs 生产环境差异 - 开发环境： 严格模式下会故意多次挂载/卸载组件 帮助你发现忘记清理资源的问题 - 生产环境： 更直接的执行流程 但基本机制保持不变 - 最佳实践 每个 Effect 只做一件事： ```jsx // 好：分离关注点 useEffect(() => { /* 订阅逻辑 */ }, [userId]); useEffect(() => { /* 动画逻辑 */ }, []); ``` 返回清理函数： ```jsx useEffect(() => { const handler = () => {}; window.addEventListener(\"resize\", handler); return () => window.removeEventListener(\"resize\", handler); }, []); ``` 正确处理依赖： ```jsx useEffect(() => { // 依赖所有用到的外部值 }, [count, userId]); ``` 理解这种\"设置 → 清理 → 设置\"的循环模式，是掌握 React useEffect 管理的关键。这确保了资源被正确管理，应用行为可预测。 ###"},{"id":"v-3031c502#自定义钩子中的封装-useeffect","path":"/React/Hooks/useEffect.html#自定义钩子中的封装-useeffect","pageTitle":"useEffect","headerTitle":"自定义钩子中的封装 useEffect","text":"自定义钩子中的封装 useEffect useEffect 是一个 “应急方案”：，当你需要 “走出 React” 并且没有更好的内置解决方案适合你的用例时，你可以使用它们。如果你发现自己经常需要手动编写 useEffect，这通常表明你需要为组件所依赖的常见行为提取一些 自定义钩子。 例如，这个 useChatRoom 自定义钩子 “hides” 你的 useEffect 的逻辑背后是一个更具声明性的 API： ```jsx function useChatRoom({ serverUrl, roomId }) { useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId, }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); } ``` 然后你可以像这样从任何组件使用它： ```jsx function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState(\"https://localhost:1234\"); useChatRoom({ roomId: roomId, serverUrl: serverUrl, }); } // ... ``` React 生态系统中还有许多优秀的自定义钩子可用于各种用途。 ###"},{"id":"v-3031c502#控制非-react-小部件","path":"/React/Hooks/useEffect.html#控制非-react-小部件","pageTitle":"useEffect","headerTitle":"控制非 React 小部件","text":"控制非 React 小部件 有时，你希望使外部系统与组件的某些属性或状态保持同步。 例如，如果你有一个第三方地图小部件或一个没有使用 React 编写的视频播放器组件，你可以使用 useEffect 来调用它的方法，使其状态与你的 React 组件的当前状态相匹配。这个 useEffect 创建了一个在 map-widget.js 中定义的 MapWidget 类的实例。当你更改 Map 组件的 zoomLevel 属性时，useEffect 会调用类实例上的 setZoom() 以保持同步： ```jsx import { useRef, useEffect } from \"react\"; import { MapWidget } from \"./map-widget.js\"; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() => { if (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return <div style={{ width: 200, height: 200 }} ref={containerRef} />; } ``` 在此示例中，不需要清理函数，因为 MapWidget 类仅管理传递给它的 DOM 节点。从树中移除 Map React 组件后，DOM 节点和 MapWidget 类实例都会被浏览器 JavaScript 引擎自动垃圾回收。 ###"},{"id":"v-3031c502#使用-useeffect-请求数据","path":"/React/Hooks/useEffect.html#使用-useeffect-请求数据","pageTitle":"useEffect","headerTitle":"使用 useEffect 请求数据","text":"使用 useEffect 请求数据 你可以使用 useEffect 为你的组件获取数据。请注意，使用框架的数据请求机制的 如果你使用框架， 将比手动编写 useEffect 更有效。 如果你想手动从 useEffect 中获取数据，你的代码可能如下所示： ```jsx import { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { let ignore = false; // 1. 定义标志变量 setBio(null); // 2. 重置状态 fetchBio(person).then(result => { // 3. 发起请求 if (!ignore) { // 4. 检查标志 setBio(result); // 5. 安全更新状态 } }); return () => { // 6. 清理函数 ignore = true; // 7. 标记为忽略 }; }, [person]); // 8. 依赖person变化 // ... ``` - 竞态条件问题说明 假设以下场景： 快速切换 person 从\"Alice\"到\"Bob\"再到\"Charlie\" 三个请求依次发出，但响应顺序可能是： Bob 的响应(慢) Alice 的响应(最慢) Charlie 的响应(最快) 没有防护时，Alice 的响应可能最后到达，错误地覆盖了当前显示的 Charlie 的数据。 - ignore 机制如何工作 - 组件挂载/更新时： ignore 初始化为 false 发起新请求 - person 变化时(重新渲染)： - 执行上一次 Effect 的清理函数，将旧请求的 ignore 设为 true - 新 Effect 运行，新的 ignore 变量(false)被创建 - 请求完成时： - 只有 ignore 为 false 的响应会更新状态 - 被\"忽略\"的请求响应到达时不会执行 setBio - 为什么这种模式有效 闭包机制：每个 Effect 调用都有自己的 ignore 变量 执行顺序保证：React 总是先执行前一个 Effect 的清理，再运行新 Effect 请求隔离：每个请求的响应处理只影响自己的渲染周期 - 实际应用场景 搜索框输入：快速连续输入时，只显示最后输入的结果 选项卡切换：快速切换时，只显示最后选中选项卡的内容 分页数据：快速翻页时，确保显示正确的页面数据 - 现代替代方案 虽然这种模式有效，但现代 React 开发更推荐： - 使用框架提供的数据获取： Next.js 的 getServerSideProps/getStaticProps Remix 的 loader React Router 的 loader - 使用数据获取库： SWR React Query Apollo Client(GraphQL) 这些方案内置了竞态条件处理、缓存、重试等高级功能。 ###"},{"id":"v-3031c502#指定反应依赖","path":"/React/Hooks/useEffect.html#指定反应依赖","pageTitle":"useEffect","headerTitle":"指定反应依赖","text":"指定反应依赖 #### 依赖项必须完整声明 React 强调所有在 Effect 内部使用的响应式值（reactive values）都必须声明为依赖项。响应式值包括： - 组件 props（如 roomId） - 组件 state（如 serverUrl） - 组件内部定义的变量和函数 ```jsx // ✅ 正确：所有用到的响应式值都声明为依赖 useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [serverUrl, roomId]); // 必须包含所有依赖 ``` #### 不能选择性忽略依赖 开发者不能随意挑选依赖，必须完整声明所有用到的响应式值。如果遗漏依赖： - React 会在开发时通过 lint 规则报错 - 可能导致 Effect 无法及时响应数据变化 ```jsx // 🔴 错误：遗漏了serverUrl依赖 useEffect(() => { const connection = createConnection(serverUrl, roomId); // ... }, [roomId]); // 缺少serverUrl ``` #### 减少依赖的合法方式 如果确实需要减少依赖，应该通过代码结构调整来实现，而不是忽略 lint 警告： - 方式一：将值移出组件 ```jsx const serverUrl = \"https://localhost:1234\"; // 不再是响应式值 function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); // ... }, [roomId]); // ✅ 现在只需要roomId } ``` - 方式二：使用 useMemo/useCallback ```jsx function ChatRoom({ roomId }) { const options = useMemo( () => ({ serverUrl: \"https://localhost:1234\", roomId, }), [roomId] ); useEffect(() => { const connection = createConnection(options); // ... }, [options]); // ✅ 依赖更简洁 } ``` 4. 空依赖数组的特殊含义 ```jsx useEffect(() => { // 这段代码只会在组件挂载时运行一次 }, []); // 空数组表示不依赖任何响应式值 ``` 空数组表示： Effect 不依赖于任何 props 或 state 只在组件挂载时运行一次 适合初始化非 React 相关的第三方库等场景 当你的组件的任何属性或状态发生变化时，具有空依赖的 useEffect 不会重新运行。 #### 不要压制 lint 警告 官方强烈反对这种写法： ```jsx // 🔴 危险！不要这样做 useEffect(() => { // ... // eslint-disable-next-line react-hooks/exhaustive-deps }, []); ``` 压制 lint 警告会导致： 难以发现的 bug Effect 无法正确响应数据变化 代码维护困难 核心思想总结 - 诚实声明依赖：Effect 用到的所有响应式值都必须声明 - 通过重构而非压制来优化：如果依赖过多，应该重构代码而非忽略警告 - 依赖项决定 Effect 的执行时机：React 根据依赖变化决定是否重新执行 Effect - 空依赖数组有特殊含义：明确表示 Effect 不依赖任何响应式数据 ###"},{"id":"v-3031c502#根据-useeffect-的先前状态更新状态","path":"/React/Hooks/useEffect.html#根据-useeffect-的先前状态更新状态","pageTitle":"useEffect","headerTitle":"根据 useEffect 的先前状态更新状态","text":"根据 useEffect 的先前状态更新状态 当你想根据 useEffect 的先前状态更新状态时，你可能会遇到问题： ```jsx function Counter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { setCount(count + 1); // You want to increment the counter every second... }, 1000); return () => clearInterval(intervalId); }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval. // ... } ``` 由于 count 是一个反应值，因此必须在依赖列表中指定它。但是，这会导致每次 count 更改时重新执行 useEffect，从而导致 intervalId 的清除和重新设置。这并不理想。 要解决此问题，通过 c => c + 1 状态更新器 到 setCount： ```jsx import { useState, useEffect } from \"react\"; export default function Counter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { setCount(c + 1); // ✅ Pass a state updater }, 1000); return () => clearInterval(intervalId); }, []); // ✅ Now count is not a dependency return <h1>{count}</h1>; } ``` ###"},{"id":"v-3031c502#移除不必要的对象依赖","path":"/React/Hooks/useEffect.html#移除不必要的对象依赖","pageTitle":"useEffect","headerTitle":"移除不必要的对象依赖","text":"移除不必要的对象依赖 如果你的 useEffect 依赖于渲染期间创建的对象或函数，则它可能会运行得太频繁。例如，此 useEffect 在每次渲染后重新连接，因为 options 对象是 每个渲染都不同： ```jsx const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { // 🚩 This object is created from scratch on every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); // It's used inside the Effect connection.connect(); return () => connection.disconnect(); }, [options]); // 🚩 As a result, these dependencies are always different on a re-render // ... ``` 修复后的代码，直接在 Effect 内部创建对象，依赖原始值 ```jsx const serverUrl = \"https://localhost:1234\"; function ChatRoom({ roomId }) { const [message, setMessage] = useState(\"\"); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId, }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // ✅ serverUrl是常量，不需要作为依赖 // ... } ``` ###"},{"id":"v-3031c502#删除不必要的函数依赖","path":"/React/Hooks/useEffect.html#删除不必要的函数依赖","pageTitle":"useEffect","headerTitle":"删除不必要的函数依赖","text":"删除不必要的函数依赖 如果你的 useEffect 依赖于渲染期间创建的对象或函数，则它可能会运行得太频繁。例如，此 useEffect 在每次渲染后重新连接，因为 createOptions 函数是 每个渲染都不同： ```jsx function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { // 🚩 This function is created from scratch on every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() => { const options = createOptions(); // It's used inside the Effect const connection = createConnection(); connection.connect(); return () => connection.disconnect(); }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render // ... ``` 函数和对象都是引用类型，作为依赖有相同的问题。 ##"},{"id":"v-3031c502#故障排除","path":"/React/Hooks/useEffect.html#故障排除","pageTitle":"useEffect","headerTitle":"故障排除","text":"故障排除 ###"},{"id":"v-3031c502#我的-useeffect-在组件挂载时运行两次","path":"/React/Hooks/useEffect.html#我的-useeffect-在组件挂载时运行两次","pageTitle":"useEffect","headerTitle":"我的 useEffect 在组件挂载时运行两次","text":"我的 useEffect 在组件挂载时运行两次 当严格模式打开时，在开发中，React 在实际设置之前额外运行一次设置和清理。 这是一个压力测试，用于验证你的 useEffect 逻辑是否正确实现。如果这导致可见问题，则说明你的清理函数缺少某些逻辑。清理函数应该停止或撤消设置函数正在做的任何事情。经验法则是用户不应该能够区分调用一次的设置（如在生产中）和设置 → 清理 → 设置序列（如在开发中）。 ###"},{"id":"v-3031c502#我的-useeffect-在每次重新渲染后运行","path":"/React/Hooks/useEffect.html#我的-useeffect-在每次重新渲染后运行","pageTitle":"useEffect","headerTitle":"我的 useEffect 在每次重新渲染后运行","text":"我的 useEffect 在每次重新渲染后运行 首先，检查你是否没有忘记指定依赖数组： ```jsx useEffect(() => { // ... }); // 🚩 No dependency array: re-runs after every render! ``` 如果你指定了依赖数组，但你的 useEffect 仍然在循环中重新运行，那是因为你的一个依赖在每次重新渲染时都不同。 你可以通过手动将依赖记录到控制台来调试此问题： ```jsx useEffect(() => { // .. }, [serverUrl, roomId]); console.log([serverUrl, roomId]); ``` 然后，你可以在控制台中右键单击来自不同重新渲染的数组，并为它们选择 “存储为全局变量”。假设第一个保存为 temp1，第二个保存为 temp2，那么你可以使用浏览器控制台检查两个数组中的每个依赖是否相同： ```jsx Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays? Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays? Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... ``` - [根据 useEffect 的先前状态更新状态](#根据useEffect的先前状态更新状态) - [移除不必要的对象依赖](#移除不必要的对象依赖) - [删除不必要的函数依赖](#删除不必要的函数依赖) ###"},{"id":"v-3031c502#我的-useeffect-在无限循环中不断重新运行","path":"/React/Hooks/useEffect.html#我的-useeffect-在无限循环中不断重新运行","pageTitle":"useEffect","headerTitle":"我的 useEffect 在无限循环中不断重新运行","text":"我的 useEffect 在无限循环中不断重新运行 如果你的 useEffect 以无限循环运行，则以下两点必须为真： 你的 useEffect 正在更新一些状态。 该状态会导致重新渲染，从而导致 useEffect 的依赖发生变化。 在开始解决问题之前，先问问自己 useEffect 是否连接到某个外部系统（如 DOM、网络、第三方小部件等）。为什么你的 useEffect 需要设置状态？它是否与该外部系统同步？或者你是否正在尝试使用它来管理应用的数据流？ 如果没有外部系统，请考虑 完全删除 useEffect 是否会简化你的逻辑。 如果你真正与某个外部系统同步，请考虑你的 useEffect 应该更新状态的原因和条件。有什么改变影响了你的组件的视觉输出吗？如果你需要跟踪渲染未使用的某些数据，引用（不会触发重新渲染）可能更合适。验证你的 useEffect 不会比需要更多地更新状态（并触发重新渲染）。 最后，如果你的 useEffect 在正确的时间更新状态，但仍然存在循环，那是因为该状态更新导致 useEffect 的依赖之一发生变化。阅读[如何调试依赖更改。](#我的useEffect在无限循环中不断重新运行) ###"},{"id":"v-3031c502#即使我的组件没有卸载-我的清理逻辑仍在运行","path":"/React/Hooks/useEffect.html#即使我的组件没有卸载-我的清理逻辑仍在运行","pageTitle":"useEffect","headerTitle":"即使我的组件没有卸载，我的清理逻辑仍在运行","text":"即使我的组件没有卸载，我的清理逻辑仍在运行 清理函数不仅在卸载期间运行，而且在每次重新渲染更改依赖之前运行。此外，在开发中，React 在组件挂载后立即额外运行一次设置+清理。 如果你有清理代码而没有相应的设置代码，通常是代码味道（Code Smell）： Code Smell:可能存在潜在问题或不良设计模式的警示信号 ```jsx useEffect(() => { // 🔴 Avoid: Cleanup logic without corresponding setup logic return () => { doSomething(); }; }, []); ``` 你的清理逻辑应该是设置逻辑的 “symmetrical”，并且应该停止或撤消任何设置所做的事情： ```jsx useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); ``` ###"},{"id":"v-3031c502#我的-useeffect-做了一些视觉-useeffect-我在它运行前看到了闪烁","path":"/React/Hooks/useEffect.html#我的-useeffect-做了一些视觉-useeffect-我在它运行前看到了闪烁","pageTitle":"useEffect","headerTitle":"我的 useEffect 做了一些视觉 useEffect，我在它运行前看到了闪烁","text":"我的 useEffect 做了一些视觉 useEffect，我在它运行前看到了闪烁 如果你的 useEffect 必须阻止浏览器访问 绘画屏幕，请将 useEffect 替换为 useLayoutEffect。请注意，绝大多数效果都不需要这样做。仅当在浏览器绘制之前运行效果至关重要时，你才需要它：例如，在用户看到之前测量和定位工具提示。"},{"id":"v-11452e5f","path":"/React/Hooks/useMemo.html","pageTitle":"useMemo","headerTitle":null,"text":"# useMemo `useMemo` 是 React 提供的一个 Hook，用于在组件多次渲染时缓存某个计算过程的结果。只有依赖项发生变化时，才会重新计算，否则直接复用上一次的结果，从而优化性能、减少不必要的计算。 --- ##"},{"id":"v-11452e5f#基本用法","path":"/React/Hooks/useMemo.html#基本用法","pageTitle":"useMemo","headerTitle":"基本用法","text":"基本用法 ```js const cachedValue = useMemo(calculateValue, dependencies); ``` - `calculateValue`：一个**无参数的纯函数**，返回需要缓存的值。 - `dependencies`：一个依赖项数组，包含所有在计算函数中用到的响应式变量（如 props、state 等）。 **示例：** ```js import { useMemo } from \"react\"; function TodoList({ todos, tab }) { const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); // ... } ``` --- ##"},{"id":"v-11452e5f#适用场景","path":"/React/Hooks/useMemo.html#适用场景","pageTitle":"useMemo","headerTitle":"适用场景","text":"适用场景 - **跳过代价昂贵的重复计算**：如大型数据过滤、复杂运算等。 - **优化子组件的重新渲染**：配合 `React.memo`，避免因 props 变化导致子组件频繁渲染。 - **防止 Effect 频繁触发**：在 useEffect 依赖项中传递稳定的对象或函数引用。 - **记忆对象或函数**：避免每次渲染都创建新引用带来的性能开销。 --- ##"},{"id":"v-11452e5f#参数与返回值","path":"/React/Hooks/useMemo.html#参数与返回值","pageTitle":"useMemo","headerTitle":"参数与返回值","text":"参数与返回值 - **参数** - `calculateValue`：无参数纯函数，返回需缓存的值。 - `dependencies`：依赖数组，只有内容变化时才重新计算。 - React 使用 `Object.is` 比较依赖项是否发生变化。 - 数组长度和顺序必须固定。 - **返回值** - 初次渲染时，返回 `calculateValue()` 的结果。 - 之后只有依赖项变化时才重新计算，否则返回缓存值。 --- ##"},{"id":"v-11452e5f#注意事项","path":"/React/Hooks/useMemo.html#注意事项","pageTitle":"useMemo","headerTitle":"注意事项","text":"注意事项 - **useMemo 只能在组件顶层或自定义 Hook 内调用**，不能在循环或条件语句中调用。 - **开发环境下严格模式**，计算函数会被调用两次，用于帮助发现副作用，生产环境只会调用一次。 - **缓存不是永久的**：开发过程中热更新、组件初始挂载被终止、未来 React 新特性（如虚拟化）等场景下缓存会丢弃。 - **useMemo 只是性能优化手段**，不要把它当作代码正常工作的必要条件。 --- ##"},{"id":"v-11452e5f#典型用法详解","path":"/React/Hooks/useMemo.html#典型用法详解","pageTitle":"useMemo","headerTitle":"典型用法详解","text":"典型用法详解 ###"},{"id":"v-11452e5f#跳过重复计算","path":"/React/Hooks/useMemo.html#跳过重复计算","pageTitle":"useMemo","headerTitle":"跳过重复计算","text":"跳过重复计算 ```js function TodoList({ todos, tab, theme }) { // filterTodos 只有 todos 或 tab 变化时才会重新运行 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); // ... } ``` > 适合大型数组过滤、复杂运算等高开销场景。 --- ###"},{"id":"v-11452e5f#优化子组件的渲染","path":"/React/Hooks/useMemo.html#优化子组件的渲染","pageTitle":"useMemo","headerTitle":"优化子组件的渲染","text":"优化子组件的渲染 ```js import { memo } from \"react\"; const List = memo(function List({ items }) { // 渲染慢的列表 }); function TodoList({ todos, tab, theme }) { // visibleTodos 只有依赖变化时才会变 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); return <List items={visibleTodos} />; } ``` > 保证 props 稳定，配合 memo 包裹的子组件，实现性能提升。 --- ###"},{"id":"v-11452e5f#防止-effect-频繁触发","path":"/React/Hooks/useMemo.html#防止-effect-频繁触发","pageTitle":"useMemo","headerTitle":"防止 Effect 频繁触发","text":"防止 Effect 频繁触发 #### 错误写法（对象引用总变，Effect 频繁执行）： ```js function ChatRoom({ roomId }) { const options = { serverUrl: \"https://localhost:1234\", roomId, }; useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); } ``` > 每次渲染 options 都是新对象，Effect 每次都重新执行。 #### 优化写法（用 useMemo 保证 options 稳定）： ```js function ChatRoom({ roomId }) { const options = useMemo( () => ({ serverUrl: \"https://localhost:1234\", roomId, }), [roomId] ); useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); } ``` > 只有 roomId 变化时 options 才会变，Effect 也只会在需要时触发。 #### 更优写法（直接在 Effect 内新建对象，最简洁）： ```js function ChatRoom({ roomId }) { useEffect(() => { const options = { serverUrl: \"https://localhost:1234\", roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); } ``` > 推荐方式，减少 useMemo 的使用。 --- ###"},{"id":"v-11452e5f#记忆对象和函数","path":"/React/Hooks/useMemo.html#记忆对象和函数","pageTitle":"useMemo","headerTitle":"记忆对象和函数","text":"记忆对象和函数 #### 记忆对象 ```js const searchOptions = useMemo( () => ({ matchMode: \"whole-word\", text }), [text] ); const visibleItems = useMemo( () => searchItems(allItems, searchOptions), [allItems, searchOptions] ); ``` #### 推荐写法（直接依赖基础数据）： ```js const visibleItems = useMemo(() => { const searchOptions = { matchMode: \"whole-word\", text }; return searchItems(allItems, searchOptions); }, [allItems, text]); ``` #### 记忆函数（一般更推荐用 useCallback） ```js const handleSubmit = useMemo(() => { return (orderDetails) => { post(\"/product/\" + productId + \"/buy\", { referrer, orderDetails }); }; }, [productId, referrer]); ``` 用 `useCallback` 语义更直观： ```js const handleSubmit = useCallback( (orderDetails) => { post(\"/product/\" + productId + \"/buy\", { referrer, orderDetails }); }, [productId, referrer] ); ``` --- ##"},{"id":"v-11452e5f#常见错误与排查","path":"/React/Hooks/useMemo.html#常见错误与排查","pageTitle":"useMemo","headerTitle":"常见错误与排查","text":"常见错误与排查 ###"},{"id":"v-11452e5f#_1-计算函数运行两次","path":"/React/Hooks/useMemo.html#_1-计算函数运行两次","pageTitle":"useMemo","headerTitle":"1. 计算函数运行两次","text":"1. 计算函数运行两次 - 开发环境下严格模式，React 会调用两次帮助发现副作用。只要你的计算函数是纯函数，这不会影响结果。 ###"},{"id":"v-11452e5f#_2-箭头函数直接返回对象返回了-undefined","path":"/React/Hooks/useMemo.html#_2-箭头函数直接返回对象返回了-undefined","pageTitle":"useMemo","headerTitle":"2. 箭头函数直接返回对象返回了 undefined","text":"2. 箭头函数直接返回对象返回了 undefined ```js // 错误 const options = useMemo(() => { matchMode: \"whole-word\", text; }, [text]); // 正确：加括号或显式 return const options = useMemo(() => ({ matchMode: \"whole-word\", text }), [text]); // 或 const options = useMemo(() => { return { matchMode: \"whole-word\", text }; }, [text]); ``` ###"},{"id":"v-11452e5f#_3-每次都重新计算-usememo-无效","path":"/React/Hooks/useMemo.html#_3-每次都重新计算-usememo-无效","pageTitle":"useMemo","headerTitle":"3. 每次都重新计算（useMemo 无效）","text":"3. 每次都重新计算（useMemo 无效） - 忘了写依赖项数组，或者依赖项每次都是新引用（如对象/数组/函数）。 - 检查依赖项，确保它们不会在不需要的情况下发生变化。 ###"},{"id":"v-11452e5f#_4-循环中调用-usememo-报错","path":"/React/Hooks/useMemo.html#_4-循环中调用-usememo-报错","pageTitle":"useMemo","headerTitle":"4. 循环中调用 useMemo 报错","text":"4. 循环中调用 useMemo 报错 - Hook 只能在组件顶层调用，不能在循环或条件中用。 - 解决方法：将每个列表项提取为单独组件，在其内部使用 useMemo。 **错误示例：** ```js items.map((item) => { const data = useMemo(() => calculate(item), [item]); // ❌ return <Child data={data} />; }); ``` **正确示例：** ```js items.map((item) => <MemoizedChild key={item.id} item={item} />); function MemoizedChild({ item }) { const data = useMemo(() => calculate(item), [item]); return <Child data={data} />; } ``` --- ##"},{"id":"v-11452e5f#总结","path":"/React/Hooks/useMemo.html#总结","pageTitle":"useMemo","headerTitle":"总结","text":"总结 - `useMemo` 主要用于缓存高开销的计算、优化性能。 - 只在确实有性能瓶颈时使用，不要滥用。 - 记得合理设置依赖项，避免无效缓存。 - 配合 `memo` 和 `useCallback`，让组件性能得到最佳优化。 > 推荐结合实际项目多加练习，理解 useMemo 的最佳用法和适用场景。"},{"id":"v-5b07065e","path":"/React/Hooks/useMemoVSuseCallback.html","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":null,"text":"# useMemo 与 useCallback 对比详解 在 React 中，`useMemo` 和 `useCallback` 都是用于**缓存数据或函数**、优化性能的 Hook。它们常被用来减少不必要的计算和渲染，提升应用响应速度。尽管两者用法类似，但各自有明确的适用场景和区别。 --- ##"},{"id":"v-5b07065e#基本定义","path":"/React/Hooks/useMemoVSuseCallback.html#基本定义","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"基本定义","text":"基本定义 - **useMemo** 用于在组件多次渲染之间**缓存一个计算值**，只有依赖项发生变化时才重新计算。 ```js const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); ``` - **useCallback** 用于在组件多次渲染之间**缓存一个函数**，只有依赖项发生变化时才生成新的函数引用。 ```js const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]); ``` --- ##"},{"id":"v-5b07065e#主要区别","path":"/React/Hooks/useMemoVSuseCallback.html#主要区别","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"主要区别","text":"主要区别 | 对比项 | useMemo | useCallback | | ------------- | ---------------------------------------- | ------------------------------------ | | 缓存对象类型 | **值**（任意类型，如数组、对象、结果等） | **函数**（可传递给子组件等） | | 返回内容 | 计算函数的返回值 | 缓存后的函数本身 | | 典型场景 | 高开销的计算、过滤、生成稳定对象/数组 | 事件处理、回调、传递给 memo 子组件 | | 用法语义 | “记住一个值” | “记住一个函数” | | 语法 | `useMemo(fn, deps)` | `useCallback(fn, deps)` | | 依赖变化时 | 重新计算并返回新值 | 生成新函数引用 | | 与 React.memo | 保证 props 数据引用稳定，减少子组件渲染 | 保证回调函数引用稳定，减少子组件渲染 | --- ##"},{"id":"v-5b07065e#相同点","path":"/React/Hooks/useMemoVSuseCallback.html#相同点","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"相同点","text":"相同点 - 都接收**依赖数组**作为第二个参数，只有依赖变化时才更新缓存。 - 都是**性能优化工具**，只在有性能瓶颈时使用，不要滥用。 - 都只能在**组件顶层**或**自定义 Hook**中使用，不能在循环或条件语句中调用。 --- ##"},{"id":"v-5b07065e#典型用法对比","path":"/React/Hooks/useMemoVSuseCallback.html#典型用法对比","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"典型用法对比","text":"典型用法对比 ###"},{"id":"v-5b07065e#usememo-缓存值","path":"/React/Hooks/useMemoVSuseCallback.html#usememo-缓存值","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"useMemo：缓存值","text":"useMemo：缓存值 适合**复杂计算**或**生成对象/数组**，如： ```js // 过滤大数据列表 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); ``` ###"},{"id":"v-5b07065e#usecallback-缓存函数","path":"/React/Hooks/useMemoVSuseCallback.html#usecallback-缓存函数","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"useCallback：缓存函数","text":"useCallback：缓存函数 适合**事件处理**、**回调**，尤其是**传递给子组件**时，如： ```js const handleClick = useCallback(() => { doSomething(a, b); }, [a, b]); ``` --- ##"},{"id":"v-5b07065e#实际案例对比","path":"/React/Hooks/useMemoVSuseCallback.html#实际案例对比","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"实际案例对比","text":"实际案例对比 ###"},{"id":"v-5b07065e#_1-优化子组件渲染","path":"/React/Hooks/useMemoVSuseCallback.html#_1-优化子组件渲染","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"1. 优化子组件渲染","text":"1. 优化子组件渲染 #### 传递稳定的数组 ```js const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); <List items={visibleTodos} />; // items 引用稳定，memo 优化有效 ``` #### 传递稳定的回调 ```js const handleSubmit = useCallback( (orderDetails) => { postOrder(orderDetails, productId); }, [productId] ); <Form onSubmit={handleSubmit} />; // onSubmit 引用稳定，memo 优化有效 ``` --- ###"},{"id":"v-5b07065e#_2-防止-effect-频繁触发","path":"/React/Hooks/useMemoVSuseCallback.html#_2-防止-effect-频繁触发","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"2. 防止 Effect 频繁触发","text":"2. 防止 Effect 频繁触发 #### 用 useMemo 保证对象稳定 ```js const options = useMemo(() => ({ serverUrl, roomId }), [serverUrl, roomId]); useEffect(() => { connect(options); }, [options]); // 只有 options 变才执行 ``` #### 用 useCallback 保证函数稳定 ```js const createOptions = useCallback( () => ({ serverUrl, roomId }), [serverUrl, roomId] ); useEffect(() => { const opts = createOptions(); connect(opts); }, [createOptions]); // 只有 roomId/serverUrl 变才执行 ``` --- ##"},{"id":"v-5b07065e#usememo-和-usecallback-何时用","path":"/React/Hooks/useMemoVSuseCallback.html#usememo-和-usecallback-何时用","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"useMemo 和 useCallback 何时用？","text":"useMemo 和 useCallback 何时用？ - 当**需要缓存“值”**（对象、数组、计算结果），用 **useMemo**。 - 当**需要缓存“函数”**（事件处理器、回调、给子组件的 props），用 **useCallback**。 - 如果你发现因为 props/函数引用变化导致子组件或 effect 频繁重复执行，就要考虑它们。 - 绝大多数情况下，`useCallback(fn, deps)` 等同于 `useMemo(() => fn, deps)`，只是语义更加明确。 --- ##"},{"id":"v-5b07065e#常见误区","path":"/React/Hooks/useMemoVSuseCallback.html#常见误区","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"常见误区","text":"常见误区 - **不要滥用**：只有当性能出现瓶颈，或者引用变化导致问题时才需要用。 - **依赖项要写全**：依赖项缺失会导致 Bug，建议配合 ESLint 规则。 - **缓存不是持久化**：React 可能在某些场景丢弃缓存（如热更新、虚拟化等），不要依赖缓存做业务逻辑。 --- ##"},{"id":"v-5b07065e#总结","path":"/React/Hooks/useMemoVSuseCallback.html#总结","pageTitle":"useMemo 与 useCallback 对比详解","headerTitle":"总结","text":"总结 - `useMemo` 用于**缓存值**，`useCallback` 用于**缓存函数**。 - 两者都用于性能优化，常与 `React.memo`、`useEffect` 等配合。 - 选择用哪个，关键看你要缓存的是“值”还是“函数”。 > 多练习、结合实际场景体会两者区别，有助于写出高性能的 React 组件！"},{"id":"v-a5f02fba","path":"/React/Hooks/useReducer.html","pageTitle":"useReducer","headerTitle":null,"text":"# useReducer `useReducer` 是 React 提供的一个 Hook，用于在组件中以 reducer 的方式管理更复杂或多步骤的状态逻辑。它常用于替代 `useState`，尤其是在 state 结构较复杂或更新逻辑较多时。 --- ##"},{"id":"v-a5f02fba#基本用法","path":"/React/Hooks/useReducer.html#基本用法","pageTitle":"useReducer","headerTitle":"基本用法","text":"基本用法 ```js const [state, dispatch] = useReducer(reducer, initialArg, init?) ``` - **reducer**：用于更新 state 的纯函数，签名为 `(state, action) => newState` - **initialArg**：初始 state，可以是任意类型 - **init**（可选）：初始化函数，只在首次渲染时运行，用于生成实际的初始 state **示例：** ```js import { useReducer } from \"react\"; function reducer(state, action) { // 根据 action.type 返回新 state } function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... } ``` --- ##"},{"id":"v-a5f02fba#dispatch-函数","path":"/React/Hooks/useReducer.html#dispatch-函数","pageTitle":"useReducer","headerTitle":"dispatch 函数","text":"dispatch 函数 - `dispatch(action)` 用于触发状态更新，参数 `action` 通常为带 type 字段的对象 - 调用后不会立即改变 state，而是触发一次组件重新渲染 - 调用完 dispatch 后立刻读取 state，拿到的还是旧值 **示例：** ```js function handleClick() { dispatch({ type: \"incremented_age\" }); } ``` --- ##"},{"id":"v-a5f02fba#reducer-函数实现","path":"/React/Hooks/useReducer.html#reducer-函数实现","pageTitle":"useReducer","headerTitle":"reducer 函数实现","text":"reducer 函数实现 通常用 switch 语句按 action.type 匹配： ```js function reducer(state, action) { switch (action.type) { case \"incremented_age\": return { ...state, age: state.age + 1 }; case \"changed_name\": return { ...state, name: action.nextName }; default: throw Error(\"Unknown action: \" + action.type); } } ``` > 一定要返回新对象/新数组，**不要直接修改原 state**！ --- ##"},{"id":"v-a5f02fba#初始化函数-init-参数","path":"/React/Hooks/useReducer.html#初始化函数-init-参数","pageTitle":"useReducer","headerTitle":"初始化函数（init 参数）","text":"初始化函数（init 参数） 当初始 state 的计算较复杂时，可以用 `init` 参数优化性能，只在首次渲染时执行： ```js function createInitialState(username) { // 复杂初始化逻辑 return { todos: [...], draft: '' }; } const [state, dispatch] = useReducer(reducer, username, createInitialState); ``` > `init` 只会在首次渲染时运行一次，避免每次渲染都做重复计算。 --- ##"},{"id":"v-a5f02fba#usereducer-vs-usestate","path":"/React/Hooks/useReducer.html#usereducer-vs-usestate","pageTitle":"useReducer","headerTitle":"useReducer vs useState","text":"useReducer vs useState - `useState` 更适合简单状态或单一字段 - `useReducer` 更适合复杂对象/数组、多步骤更新、需要将更新逻辑集中管理的场景 - 代码可读性和可维护性更高 --- ##"},{"id":"v-a5f02fba#完整示例","path":"/React/Hooks/useReducer.html#完整示例","pageTitle":"useReducer","headerTitle":"完整示例","text":"完整示例 ```js import { useReducer } from \"react\"; function reducer(state, action) { switch (action.type) { case \"incremented_age\": return { ...state, age: state.age + 1 }; case \"changed_name\": return { ...state, name: action.nextName }; default: throw Error(\"Unknown action: \" + action.type); } } export default function Form() { const [state, dispatch] = useReducer(reducer, { name: \"Taylor\", age: 42 }); function handleNameChange(e) { dispatch({ type: \"changed_name\", nextName: e.target.value }); } function handleIncrement() { dispatch({ type: \"incremented_age\" }); } return ( <> <input value={state.name} onChange={handleNameChange} /> <button onClick={handleIncrement}>加一岁</button> <p> 你好，{state.name}，你今年 {state.age} 岁。 </p> </> ); } ``` --- ##"},{"id":"v-a5f02fba#常见陷阱与调试","path":"/React/Hooks/useReducer.html#常见陷阱与调试","pageTitle":"useReducer","headerTitle":"常见陷阱与调试","text":"常见陷阱与调试 ###"},{"id":"v-a5f02fba#_1-dispatch-后-state-没变-屏幕没更新","path":"/React/Hooks/useReducer.html#_1-dispatch-后-state-没变-屏幕没更新","pageTitle":"useReducer","headerTitle":"1. dispatch 后 state 没变/屏幕没更新？","text":"1. dispatch 后 state 没变/屏幕没更新？ - 不能直接修改 state（如 state.age++），必须返回新对象 - 直接修改 state，React 会跳过渲染 ###"},{"id":"v-a5f02fba#_2-dispatch-后部分属性丢失为-undefined","path":"/React/Hooks/useReducer.html#_2-dispatch-后部分属性丢失为-undefined","pageTitle":"useReducer","headerTitle":"2. dispatch 后部分属性丢失为 undefined？","text":"2. dispatch 后部分属性丢失为 undefined？ - 返回新对象时要展开 `...state`，否则未赋值的属性会丢失 ###"},{"id":"v-a5f02fba#_3-dispatch-后-state-变成-undefined","path":"/React/Hooks/useReducer.html#_3-dispatch-后-state-变成-undefined","pageTitle":"useReducer","headerTitle":"3. dispatch 后 state 变成 undefined？","text":"3. dispatch 后 state 变成 undefined？ - reducer 必须覆盖所有 action.type，最后加个 default 或 throw Error ###"},{"id":"v-a5f02fba#_4-dispatch-后立即读取-state-值没变","path":"/React/Hooks/useReducer.html#_4-dispatch-后立即读取-state-值没变","pageTitle":"useReducer","headerTitle":"4. dispatch 后立即读取 state，值没变？","text":"4. dispatch 后立即读取 state，值没变？ - 状态更新是异步的，dispatch 后本次事件中 state 不会立即变化 ###"},{"id":"v-a5f02fba#_5-报错-too-many-re-renders","path":"/React/Hooks/useReducer.html#_5-报错-too-many-re-renders","pageTitle":"useReducer","headerTitle":"5. 报错 “Too many re-renders”？","text":"5. 报错 “Too many re-renders”？ - 可能在渲染期间直接调用了 dispatch，正确做法是事件中调用 ```js // 错误 return <button onClick={handleClick()}>Click me</button>; // 正确 return <button onClick={handleClick}>Click me</button>; ``` ###"},{"id":"v-a5f02fba#_6-reducer-初始化函数运行两次","path":"/React/Hooks/useReducer.html#_6-reducer-初始化函数运行两次","pageTitle":"useReducer","headerTitle":"6. reducer/初始化函数运行两次？","text":"6. reducer/初始化函数运行两次？ - 严格模式（开发环境）下会运行两次，帮助你发现副作用。只要是纯函数，不会影响实际功能 --- ##"},{"id":"v-a5f02fba#总结","path":"/React/Hooks/useReducer.html#总结","pageTitle":"useReducer","headerTitle":"总结","text":"总结 - `useReducer` 适合管理复杂、多步骤、对象/数组类型的状态 - 状态更新逻辑全部集中在 reducer，便于维护和测试 - 返回新 state，**不要直接修改原 state** - dispatch 更新是异步的，不能立即读取到新 state - 遇到问题多检查 reducer、action、初始值、依赖是否写对 > 建议实际项目中多用 useReducer 管理复杂表单或多字段、可组合的状态！"},{"id":"v-1a453b95","path":"/React/Hooks/useRef.html","pageTitle":"useRef","headerTitle":null,"text":"# useRef useRef 是一个 React Hook，它能帮助引用一个不需要渲染的值。 ```jsx const ref = useRef(initialValue); ``` ##"},{"id":"v-1a453b95#参考","path":"/React/Hooks/useRef.html#参考","pageTitle":"useRef","headerTitle":"参考","text":"参考 在组件顶层调用 useRef 以声明一个 ref。 ```jsx import { useRef } from 'react'; function MyComponent() { const intervalRef = useRef(0); const inputRef = useRef(null); // ... ``` [请参考下方案例](#用-ref-引用一个值) ###"},{"id":"v-1a453b95#useref-initialvalue","path":"/React/Hooks/useRef.html#useref-initialvalue","pageTitle":"useRef","headerTitle":"useRef(initialValue)","text":"useRef(initialValue) #### 参数 initialValue：ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略。 #### 返回值 useRef 返回一个只有一个属性的对象: - current：初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，ref 将作为 current 属性。 在后续的渲染中，useRef 将返回同一个对象。 #### 注意 - 可以修改 ref.current 属性。与 state 不同，它是可变的。然而，如果它持有一个用于渲染的对象（例如 state 的一部分），那么就不应该修改这个对象。 - 改变 ref.current 属性时，React 不会重新渲染组件。React 不知道它何时会发生改变，因为 ref 是一个普通的 JavaScript 对象。 - 除了 初始化 外不要在渲染期间写入或者读取 ref.current，否则会使组件行为变得不可预测。 - 在严格模式下，React 将会 调用两次组件方法，这是为了 帮助发现意外问题。但这只是开发模式下的行为，不会影响生产模式。每个 ref 对象都将会创建两次，但是其中一个版本将被丢弃。如果"},{"id":"v-1a453b95#使用","path":"/React/Hooks/useRef.html#使用","pageTitle":"useRef","headerTitle":"使用","text":"使用的是组件纯函数（也应当如此），那么这不会影响其行为。 ## 使用 ###"},{"id":"v-1a453b95#用-ref-引用一个值","path":"/React/Hooks/useRef.html#用-ref-引用一个值","pageTitle":"useRef","headerTitle":"用 ref 引用一个值","text":"用 ref 引用一个值 在组件顶层调用 useRef 声明一个或多个 ref。 ```jsx import { useRef } from 'react'; function Stopwatch() { const intervalRef = useRef(0); // ... ``` useRef 返回一个具有单个 current 属性 的 ref 对象，并初始化为你提供的 初始值。 在后续的渲染中，useRef 将返回相同的对象。你可以改变它的 current 属性来存储信息，并在之后读取它。这会让人联想到 state，但是有一个重要的区别。 **改变 ref 不会触发重新渲染。**这意味着 ref 是存储一些不影响组件视图输出信息的完美选择。例如，如果需要存储一个 interval ID 并在以后检索它，那么可以将它存储在 ref 中。只需要手动改变它的 current 属性 即可修改 ref 的值： ```js function handleStartClick() { const intervalId = setInterval(() => { // ... }, 1000); intervalRef.current = intervalId; } ``` 在之后，从 ref 中读取 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval\" target=\"_blank\">interval ID</a>便可以 清除定时器： ```js function handleStopClick() { const intervalId = intervalRef.current; clearInterval(intervalId); } ``` 使用 ref 可以确保： - 可以在重新渲染之间 存储信息（普通对象存储的值每次渲染都会重置）。 - 改变它 不会触发重新渲染（状态变量会触发重新渲染）。 - 对于组件的每个副本而言，这些信息都是本地的（外部变量则是共享的）。 改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替。 <a href=\"https://zh-hans.react.dev/learn/referencing-values-with-refs#differences-between-refs-and-state\" target=\"_blank\">阅读更多关于 在 useRef 和 useState 之间选择 的信息。</a> #### 注意 不要在渲染期间写入或者读取 ref.current。 React 期望组件主体 表现得像一个纯函数： 如果输入的（props、state 与 上下文）都是一样的，那么就应该返回一样的 JSX。 以不同的顺序或用不同的参数调用它，不应该影响其他调用的结果。 在 渲染期间 读取或写入 ref 会破坏这些预期行为。 ```jsx function MyComponent() { // ... // 🚩 不要在渲染期间写入 ref myRef.current = 123; // ... // 🚩 不要在渲染期间读取 ref return <h1>{myOtherRef.current}</h1>; } ``` 可以在 事件处理程序或者 Effect 中读取和写入 ref。 ```jsx function MyComponent() { // ... useEffect(() => { // ✅ 可以在 Effect 中读取和写入 ref myRef.current = 123; }); // ... function handleClick() { // ✅ 可以在事件处理程序中读取和写入 ref doSomething(myOtherRef.current); } // ... } ``` 如果不得不在渲染期间读取 或者写入，那么应该 使用 state 代替。 当打破这些规则时，组件可能仍然可以工作，但是我们**为 React 添加的大多数新功能将依赖于这些预期行为**。阅读 <a href=\"https://zh-hans.react.dev/learn/keeping-components-pure#where-you-_can_-cause-side-effects\" target=\"_blank\">保持组件纯粹</a>以了解更多信息。 ###"},{"id":"v-1a453b95#通过-ref-操作-dom","path":"/React/Hooks/useRef.html#通过-ref-操作-dom","pageTitle":"useRef","headerTitle":"通过 ref 操作 DOM","text":"通过 ref 操作 DOM 使用 ref 操作 DOM 是非常常见的行为。React 内置了对它的支持。 首先，声明一个 初始值 为 null 的 ref 对象 ```jsx import { useRef } from 'react'; function MyComponent() { const inputRef = useRef(null); // ... ``` 然后将 ref 对象作为 ref 属性传递给想要操作的 DOM 节点的 JSX： ```jsx // ... return <input ref={inputRef} />; ``` 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性。现在可以借助 ref 对象访问 input 的 DOM 节点，并且可以调用类似于 focus() 的方法： ```js function handleClick() { inputRef.current.focus(); } ``` 当节点从屏幕上移除时，React 将把 current 属性设置回 null。 #### 案例 有时你可能想让父组件在组件中操纵 DOM。例如，假设正在编写一个 MyInput 组件，但希望父组件能够聚焦 input（不过父组件无法访问）。此时可以在父组件中创建一个 ref 并作为 prop 传递给子组件。 ```jsx import { useRef } from \"react\"; function MyInput({ ref }) { return <input ref={ref} />; } export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <MyInput ref={inputRef} /> <button onClick={handleClick}>聚焦输入框</button> </> ); } ``` ###"},{"id":"v-1a453b95#避免重复创建-ref-的内容","path":"/React/Hooks/useRef.html#避免重复创建-ref-的内容","pageTitle":"useRef","headerTitle":"避免重复创建 ref 的内容","text":"避免重复创建 ref 的内容 React 会保存 ref 初始值，并在后续的渲染中忽略它。 ```jsx function Video() { const playerRef = useRef(new VideoPlayer()); // ... ``` 虽然 new VideoPlayer() 的结果只会在首次渲染时使用，但是依然在每次渲染时都在调用这个方法。如果是创建昂贵的对象，这可能是一种浪费。 为了解决这个问题，你可以像这样初始化 ref： ```jsx function Video() { const playerRef = useRef(null); if (playerRef.current === null) { playerRef.current = new VideoPlayer(); } // ... ``` 通常情况下，在渲染过程中写入或读取 ref.current 是不允许的。然而，在这种情况下是可以的，因为结果总是一样的，而且条件只在初始化时执行，所以是完全可预测的。 ##"},{"id":"v-1a453b95#疑难解答","path":"/React/Hooks/useRef.html#疑难解答","pageTitle":"useRef","headerTitle":"疑难解答","text":"疑难解答 ###"},{"id":"v-1a453b95#无法获取自定义组件的-ref","path":"/React/Hooks/useRef.html#无法获取自定义组件的-ref","pageTitle":"useRef","headerTitle":"无法获取自定义组件的 ref","text":"无法获取自定义组件的 ref 如果尝试像这样传递 ref 到自定义组件： ```jsx const inputRef = useRef(null); return <MyInput ref={inputRef} />; ``` 你可能会在控制台中得到这样的错误： ``` Console TypeError: Cannot read properties of null ``` 默认情况下，自定义组件不会暴露它们内部 DOM 节点的 ref。 为了解决这个问题，首先，找到想获得 ref 的组件： ```jsx export default function MyInput({ value, onChange }) { return <input value={value} onChange={onChange} />; } ``` 然后在组件的 props 参数中提取 ref，并将它作为参数传递给相关的 内置组件。如下所示： ```jsx function MyInput({ value, onChange, ref }) { return <input value={value} onChange={onChange} ref={ref} />; } export default MyInput; ``` 最后，父级组件就可以得到它的 ref。 阅读 <a href=\"https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes\" target=\"_blank\">访问另一个组件的 DOM 节点</a>以了解更多信息。"},{"id":"v-11b7c34e","path":"/React/Hooks/useState.html","pageTitle":"useState","headerTitle":null,"text":"# useState useState 是一个 React 钩子，可让你将 状态变量 添加到组件中。 ```jsx const [state, setState] = useState(initialState); ``` ##"},{"id":"v-11b7c34e#参考","path":"/React/Hooks/useState.html#参考","pageTitle":"useState","headerTitle":"参考","text":"参考 ###"},{"id":"v-11b7c34e#usestate-initialstate","path":"/React/Hooks/useState.html#usestate-initialstate","pageTitle":"useState","headerTitle":"useState(initialState)","text":"useState(initialState) useState(initialState) 在组件的顶层调用 useState 以声明 状态变量。 ```jsx import { useState } from 'react'; function MyComponent() { const [age, setAge] = useState(28); const [name, setName] = useState('Taylor'); const [todos, setTodos] = useState(() => createTodos()); // ... ``` 约定是使用 数组解构 命名状态变量，例如 [something, setSomething]。 #### 参数 initialState：你希望状态的初始值。它可以是任何类型的值，但函数有特殊的行为。这个参数在初始渲染后被忽略。 如果你将函数作为 initialState 传递，它将被视为初始化函数。它应该是纯粹的，不带任何参数，并且应该返回任何类型的值。React 在初始化组件时会调用你的初始化函数，并将其返回值存储为初始状态。[请参见下面的示例](#用法)。 初始化参数的两种方式 - 普通初始化 useState(value) 每次渲染都会执行表达式，但只用第一次的结果 初始值简单 - 惰性初始化 useState(() => value) 只在首次渲染时执行 初始值计算复杂 ```js // 普通初始化 const [nums, setNums] = useState(new Array(1000000).fill(0)); // 每次渲染都执行一次 new Array... // 惰性初始化 const [nums, setNums] = useState(() => new Array(1000000).fill(0)); // 只有首次渲染才执行一次 ``` #### 返回 Returns useState 返回一个恰好包含两个值的数组： 当前状态。在第一次渲染期间，它将与你传递的 initialState 相匹配。 set 函数 允许你将状态更新为不同的值并触发重新渲染。 #### 注意事项 useState 是一个 Hook，所以你只能在你的组件的顶层或者你自己的钩子中调用它。你不能在循环或条件内调用它。如果需要，提取一个新组件并将状态移入其中。 在严格模式下，React 将调用你的初始化函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的初始化函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。 ###"},{"id":"v-11b7c34e#set-函数与-setsomething-nextstate-类似","path":"/React/Hooks/useState.html#set-函数与-setsomething-nextstate-类似","pageTitle":"useState","headerTitle":"set 函数与 setSomething(nextState)类似","text":"set 函数与 setSomething(nextState)类似 useState 返回的 set 函数允许你将状态更新为不同的值并触发重新渲染。你可以直接传递下一个状态，或从前一个状态计算它的函数： ```jsx const [name, setName] = useState('Edward'); function handleClick() { setName('Taylor'); setAge(a => a + 1); // ... ``` #### 参数 nextState：你希望状态成为的值。它可以是任何类型的值，但函数有特殊的行为。 如果你将函数作为 nextState 传递，它将被视为更新函数。它必须是纯粹的，应该将挂起状态作为其唯一参数，并且应该返回下一个状态。React 会将你的更新程序函数放入队列中并重新渲染你的组件。在下一次渲染期间，React 将通过将所有排队的更新器应用于前一个状态来计算下一个状态。[请参见下面的示例](#根据之前的状态更新状态)。 #### 返回 set 函数没有返回值。 #### 注意事项 - **set 函数仅更新下一次渲染的状态变量**。如果你在调用 set 函数后读取状态变量，则 **你仍然会得到旧的值** 在你调用之前显示在屏幕上。 - 如果你提供的新值与当前的 state 相同（通过 Object.is 比较确定），React 将跳过重新渲染组件及其子组件。这是一个优化。尽管在某些情况下 React 可能仍需要在跳过子级之前调用你的组件，但这不应该影响你的代码。 - React 批量状态更新。 在所有事件处理程序运行并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在极少数情况下，你需要强制 React 提前更新屏幕，例如访问 DOM，你可以使用 flushSync。 - set 函数具有稳定的标识，因此你经常会看到它从副作用依赖中省略，但包含它不会导致副作用触发。如果 linter 允许你在没有错误的情况下省略依赖，那么这样做是安全的。详细了解如何删除副作用依赖。 - 在渲染期间调用 set 函数只能从当前渲染组件中调用。React 将丢弃其输出并立即尝试使用新状态再次渲染它。这种模式很少需要，但你可以使用它来存储先前渲染的信息。[请参见下面的示例](#存储以前渲染的信息)。 - 在严格模式下，React 将调用你的更新程序函数两次，以便 帮助你发现意外杂质 这是仅开发行为，不会影响生产。如果你的更新程序函数是纯函数（它应该是纯函数），这应该不会影响行为。其中一个调用的结果将被忽略。 ##"},{"id":"v-11b7c34e#用法","path":"/React/Hooks/useState.html#用法","pageTitle":"useState","headerTitle":"用法","text":"用法 ###"},{"id":"v-11b7c34e#向组件添加状态","path":"/React/Hooks/useState.html#向组件添加状态","pageTitle":"useState","headerTitle":"向组件添加状态","text":"向组件添加状态 在组件的顶层调用 useState 以声明一个或多个 状态变量。 ```jsx import { useState } from 'react'; function MyComponent() { const [age, setAge] = useState(42); const [name, setName] = useState('Taylor'); // ... ``` 约定是使用 数组解构 命名状态变量，例如 [something, setSomething]。 useState 返回一个恰好包含两项的数组： 此状态变量的当前状态，初始设置为你提供的初始状态。 set 函数 允许你将其更改为任何其他值以响应交互。 要更新屏幕上的内容，请使用下一个状态调用 set 函数： ```jsx function handleClick() { setName(\"Robin\"); } ``` React 将存储下一个状态，使用新值再次渲染你的组件，并更新 UI。 #### 易犯错误 调用 set 函数 不会改变已经执行的代码中的当前状态： ```jsx function handleClick() { setName(\"Robin\"); console.log(name); // Still \"Taylor\"! } ``` 它只影响 useState 从下一次渲染开始返回的内容。 ###"},{"id":"v-11b7c34e#根据之前的状态更新状态","path":"/React/Hooks/useState.html#根据之前的状态更新状态","pageTitle":"useState","headerTitle":"根据之前的状态更新状态","text":"根据之前的状态更新状态 假设 age 是 42。此处理程序调用 setAge(age + 1) 三次： ```js function handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } ``` 但是，点击之后，age 只会变成 43，而不是 45！这是因为在已经运行的代码中调用 set 函数 不会更新 age 状态变量。所以每次 setAge(age + 1) 调用都变成 setAge(43)。 为了解决这个问题，你可以将更新函数传递给 setAge 而不是下一个状态： ```jsx function handleClick() { setAge((a) => a + 1); // setAge(42 => 43) setAge((a) => a + 1); // setAge(43 => 44) setAge((a) => a + 1); // setAge(44 => 45) } ``` 这里，a => a + 1 是你的更新函数。它采用 挂起状态 并从中计算出 下一个状态。 React 将你的更新函数放到 队列 中。然后，在下一次渲染期间，它将以相同的顺序调用它们： a => a + 1 将接收 42 作为挂起状态，并返回 43 作为下一个状态。 a => a + 1 将接收 43 作为挂起状态，并返回 44 作为下一个状态。 a => a + 1 将接收 44 作为挂起状态，并返回 45 作为下一个状态。 没有其他排队的更新，所以 React 最后会将 45 存储为当前状态。 按照惯例，通常将状态变量名称的第一个字母命名为挂起状态参数，例如 a 代表 age。但是，你也可以将其称为 prevAge 或你认为更清楚的其他名称。 React 可能在开发中 [两次调用你的更新器](#我的初始化或更新函数运行两次) 以验证它们是 纯粹的。 ###"},{"id":"v-11b7c34e#更新状态中的对象和数组","path":"/React/Hooks/useState.html#更新状态中的对象和数组","pageTitle":"useState","headerTitle":"更新状态中的对象和数组","text":"更新状态中的对象和数组 你可以将对象和数组放入状态。在 React 中，状态被认为是只读的，因此你应该替换它而不是改变现有的对象。例如，如果你有一个状态为 form 的对象，不要改变它： ```js // 🚩 Don't mutate an object in state like this: form.firstName = \"Taylor\"; ``` 而是，通过创建一个新对象来替换整个对象： ```js // ✅ Replace state with a new object setForm({ ...form, firstName: \"Taylor\", }); ``` ###"},{"id":"v-11b7c34e#使用键来重置状态","path":"/React/Hooks/useState.html#使用键来重置状态","pageTitle":"useState","headerTitle":"使用键来重置状态","text":"使用键来重置状态 当 渲染列表 时，你会经常遇到 key 属性。但是，它还有另一个用途。 你可以通过将不同的 key 传递给组件来重置组件的状态。在此示例中，“重置”按钮更改 version 状态变量，我们将其作为 key 传递给 Form。当 key 改变时，React 从头开始重新创建 Form 组件（及其所有子级），因此它的状态被重置。 ```jsx import { useState } from \"react\"; export default function App() { const [version, setVersion] = useState(0); function handleReset() { setVersion(version + 1); } return ( <> <button onClick={handleReset}>Reset</button> <Form key={version} /> </> ); } function Form() { const [name, setName] = useState(\"Taylor\"); return ( <> <input value={name} onChange={(e) => setName(e.target.value)} /> <p>Hello, {name}.</p> </> ); } ``` ###"},{"id":"v-11b7c34e#存储以前渲染的信息","path":"/React/Hooks/useState.html#存储以前渲染的信息","pageTitle":"useState","headerTitle":"存储以前渲染的信息","text":"存储以前渲染的信息 通常，你将在事件处理程序中更新状态。但是，在极少数情况下，你可能希望根据渲染调整状态 - 例如，你可能希望在属性更改时更改状态变量。 在大多数情况下，你不需要这样： 如果你需要的值可以完全根据当前的属性或其他状态计算出来，那么 完全删除该冗余状态。 如果你担心重新计算过于频繁，那么 useMemo 钩子 可以提供帮助。 如果你想重置整个组件树的状态，将不同的 key 传递给你的组件。 如果可以，请更新事件处理程序中的所有相关状态。 在极少数情况下，这些都不适用，你可以使用一种模式根据目前已渲染的值更新状态，方法是在组件渲染时调用 set 函数。 这是一个例子。这个 CountLabel 组件显示传递给它的 count 属性： ```jsx export default function CountLabel({ count }) { return <h1>{count}</h1>; } ``` 如果你这样使用那么将会造成页面无限渲染 ```jsx function InfiniteLoopComponent() { const [count, setCount] = useState(0); // 错误：无条件调用setState setCount(count + 1); // 每次渲染都会触发状态更新 return <div>Count: {count}</div>; } ``` 组件首次渲染，count 初始化为 0 执行 setCount(0 + 1)，计划将 count 更新为 1 React 重新渲染组件 再次执行 setCount(1 + 1)，计划将 count 更新为 2 这个过程会无限继续下去 ##"},{"id":"v-11b7c34e#故障排除","path":"/React/Hooks/useState.html#故障排除","pageTitle":"useState","headerTitle":"故障排除","text":"故障排除 ###"},{"id":"v-11b7c34e#我更新了状态-但日志记录给了我旧值","path":"/React/Hooks/useState.html#我更新了状态-但日志记录给了我旧值","pageTitle":"useState","headerTitle":"我更新了状态，但日志记录给了我旧值","text":"我更新了状态，但日志记录给了我旧值 调用 set 函数不会更改运行代码中的状态： ```jsx function handleClick() { console.log(count); // 0 setCount(count + 1); // Request a re-render with 1 console.log(count); // Still 0! setTimeout(() => { console.log(count); // Also 0! }, 5000); } ``` 这是因为 状态的行为类似于快照。 更新状态请求另一个具有新状态值的渲染，但不会影响你已经运行的事件处理程序中的 count JavaScript 变量。 如果需要使用下一个状态，可以将其保存在变量中，然后再传递给 set 函数： ```jsx const nextCount = count + 1; setCount(nextCount); console.log(count); // 0 console.log(nextCount); // 1 ``` ###"},{"id":"v-11b7c34e#我已经更新了状态-但是屏幕没有更新","path":"/React/Hooks/useState.html#我已经更新了状态-但是屏幕没有更新","pageTitle":"useState","headerTitle":"我已经更新了状态，但是屏幕没有更新","text":"我已经更新了状态，但是屏幕没有更新 如果下一个状态等于前一个状态（由 Object.is 比较确定），React 将忽略你的更新。当你直接更改状态中的对象或数组时，通常会发生这种情况： ```jsx obj.x = 10; // 🚩 Wrong: mutating existing object setObj(obj); // 🚩 Doesn't do anything ``` 你改变了一个现有的 obj 对象并将它传递回 setObj，所以 React 忽略了更新。要解决此问题，你需要确保你始终是 替换状态中的对象和数组而不是改变它们： ```jsx // ✅ Correct: creating a new object setObj({ ...obj, x: 10, }); ``` ###"},{"id":"v-11b7c34e#我收到错误-太多的重新渲染","path":"/React/Hooks/useState.html#我收到错误-太多的重新渲染","pageTitle":"useState","headerTitle":"我收到错误：“太多的重新渲染”","text":"我收到错误：“太多的重新渲染” 你可能会收到一条错误消息：Too many re-renders. React limits the number of renders to prevent an infinite loop. 通常，这意味着你在渲染期间无条件设置状态，因此你的组件进入循环：渲染、设置状态（导致渲染）、渲染、设置状态（导致渲染），以此类推。通常，这是由于指定事件处理程序的错误造成的： ```jsx // 🚩 Wrong: calls the handler during render return <button onClick={handleClick()}>Click me</button>; // ✅ Correct: passes down the event handler return <button onClick={handleClick}>Click me</button>; // ✅ Correct: passes down an inline function return <button onClick={(e) => handleClick(e)}>Click me</button>; ``` 如果找不到此错误的原因，请单击控制台中错误旁边的箭头并查看 JavaScript 堆栈以查找导致错误的特定 set 函数调用。 ###"},{"id":"v-11b7c34e#我的初始化或更新函数运行两次","path":"/React/Hooks/useState.html#我的初始化或更新函数运行两次","pageTitle":"useState","headerTitle":"我的初始化或更新函数运行两次","text":"我的初始化或更新函数运行两次 在 严格模式 中，React 将调用你的一些函数两次而不是一次： ```jsx function TodoList() { // This component function will run twice for every render. const [todos, setTodos] = useState(() => { // This initializer function will run twice during initialization. return createTodos(); }); function handleClick() { setTodos(prevTodos => { // This updater function will run twice for every click. return [...prevTodos, createTodo()]; }); } // ... ``` 这是预期的，不应破坏你的代码。 这种仅用于开发的行为可以帮助你 保持组件纯粹。 React 使用其中一个调用的结果，并忽略另一个调用的结果。只要你的组件、初始化器和更新器函数是纯函数，这就不会影响你的逻辑。但是，如果它们不小心不纯，这有助于你发现错误。 例如，这个不纯的更新函数改变了状态数组： ```jsx setTodos((prevTodos) => { // 🚩 Mistake: mutating state prevTodos.push(createTodo()); }); ``` 因为 React 两次调用你的更新函数，你会看到 todo 被添加了两次，所以你会知道有一个错误。在这个例子中，你可以通过 替换数组而不是改变它 来修复错误： ```jsx setTodos((prevTodos) => { // ✅ Correct: replacing with new state return [...prevTodos, createTodo()]; }); ``` 既然这个更新函数是纯粹的，额外调用它不会对行为产生影响。这就是为什么 React 调用它两次可以帮助你发现错误。只有组件、初始化器和更新器函数需要是纯函数。事件处理程序不需要是纯粹的，因此 React 永远不会调用你的事件处理程序两次。 ###"},{"id":"v-11b7c34e#我正在尝试将状态设置为一个函数-但它被调用了","path":"/React/Hooks/useState.html#我正在尝试将状态设置为一个函数-但它被调用了","pageTitle":"useState","headerTitle":"我正在尝试将状态设置为一个函数，但它被调用了","text":"我正在尝试将状态设置为一个函数，但它被调用了 你不能像这样将函数置于状态： ```jsx const [fn, setFn] = useState(someFunction); function handleClick() { setFn(someOtherFunction); } ``` 因为你正在传递一个函数，React 假定 someFunction 是一个 初始化函数，而 someOtherFunction 是一个 更新函数，所以它会尝试调用它们并存储结果。要实际存储一个函数，在这两种情况下都必须将 () => 放在它们之前。然后 React 将存储你传递的函数。 ```jsx const [fn, setFn] = useState(() => someFunction); function handleClick() { setFn(() => someOtherFunction); } ``` ##"},{"id":"v-11b7c34e#源码理解","path":"/React/Hooks/useState.html#源码理解","pageTitle":"useState","headerTitle":"源码理解","text":"源码理解 首先要理解useState，我们要解决一个核心问题：**函数组件本身是无状态的**，它每次渲染都是一次新的函数调用，执行完后所有局部变量都会丢失。那么，React 是如何在多次渲染之间“记住”这个 state 的呢？ React 的秘诀在于，它在**组件函数之外**，为每个组件实例维护了一个**内部数据结构**，这个结构在现代 React 中就是 **Fiber 节点**。这个 Fiber 节点是组件的“身份证”，它在多次渲染之间是持久存在的。 `useState` 的内部实现就完全依赖于这个 Fiber 节点： 1. **数据结构**：在每个组件的 Fiber 节点上，React 维护了一个**链表**，这个链表专门用来**存储所有的 Hooks**（包括 `useState`, `useEffect` 等）。 2. **首次渲染**：当组件**第一次渲染**时，你每调用一次 `useState`，React 就会在这个链表上**创建一个新的节点（Hook 节点）**。这个节点里会保存**当前的状态值**（`state`）和一个**更新队列**（`queue`）。 3. **后续渲染**：当组件因为状态变更**重新渲染**时，神奇的地方就来了。当 `useState` 再次被调用时，React **不会**创建新节点，而是会去**按顺序遍历**那个已经存在的 Hook 链表。 - 你调用的**第一个** `useState`，React 就取出链表上的**第一个**节点，把里面的状态值返回给你。 - 你调用的**第二个** `useState`，React 就取出链表上的**第二个**节点，以此类推。 4. **“Hooks 规则”的原因**：这也完美解释了**为什么 Hooks 必须在顶层调用**，不能放在 `if` 或循环里。因为 React 完全依赖这个**“稳定不变的调用顺序”**来确保每次都能从链表上拿到正确的状态。如果调用顺序变了，React 在遍历链表时就会“张冠李戴”，导致状态彻底错乱。 5. **setState 的工作**：最后，`useState` 返回的那个 `setter` 函数（比如 `setCount`）被调用时，它**并不会立即修改状态**。它做的是两件事： - 找到它自己对应的那个 Hook 节点。 - 把这个“更新操作”（比如新的值，或者一个 `(prev => prev + 1)` 函数）**放进那个节点的更新队列（queue）里**。 - 最后，它会**调度一次 React 的重新渲染**。 在下一次渲染时，React 就会回到第 3 步，遍历链表，在计算状态时，会检查更新队列并执行里面的所有操作，从而得到最新的状态值返回给组件。” **一句话总结：** “所以，`useState` 的内部实现，本质上就是**依靠一个稳定存在于 Fiber 节点上的 Hook 链表，并通过严格的调用顺序来确保每次渲染都能正确地存取状态。**”"},{"id":"v-475d40f6","path":"/React/Hooks/useSyncExternalStore.html","pageTitle":"React 18+ useSyncExternalStore","headerTitle":null,"text":"# React 18+ useSyncExternalStore `useSyncExternalStore` 是 React 18 新增的一个 Hook，主要用于**订阅和读取外部存储（store）的状态**，让 React 组件能够安全、正确地和外部状态源（比如全局状态管理库、浏览器 API 等）进行同步。这个 API 主要是为**第三方状态管理库**设计的，也适合你自己实现订阅型外部数据源时使用。 --- ##"},{"id":"v-475d40f6#场景和价值","path":"/React/Hooks/useSyncExternalStore.html#场景和价值","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"场景和价值","text":"场景和价值 - **状态管理库的桥梁**：如 Redux、MobX、Zustand、Recoil、Jotai 等库，未来都推荐基于这个 Hook 实现 React 绑定。 - **订阅外部全局状态**：如浏览器事件（localStorage、history、window resize、媒体查询等），或其他非 React 管理的数据源。 - **支持并发渲染（Concurrent Rendering）**：相比旧的“订阅+setState”方案，`useSyncExternalStore` 可以保证外部数据和 React 渲染同步，避免数据撕裂问题。 --- ##"},{"id":"v-475d40f6#基本用法","path":"/React/Hooks/useSyncExternalStore.html#基本用法","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"基本用法","text":"基本用法 ```js const value = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) ``` - **subscribe**：订阅外部 store 状态变化的回调。接收一个回调参数（store 变化时调用），返回取消订阅的函数。 - **getSnapshot**：同步读取当前外部 store 状态的函数，返回当前值。 - **getServerSnapshot**（可选）：SSR 场景下用于获取服务端快照，一般可忽略。 --- ##"},{"id":"v-475d40f6#简单示例-监听浏览器窗口宽度","path":"/React/Hooks/useSyncExternalStore.html#简单示例-监听浏览器窗口宽度","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"简单示例：监听浏览器窗口宽度","text":"简单示例：监听浏览器窗口宽度 ```js import { useSyncExternalStore } from \"react\"; function subscribe(callback) { window.addEventListener(\"resize\", callback); return () => window.removeEventListener(\"resize\", callback); } function getSnapshot() { return window.innerWidth; } function useWindowWidth() { return useSyncExternalStore(subscribe, getSnapshot); } function Demo() { const width = useWindowWidth(); return <div>当前窗口宽度：{width}px</div>; } ``` --- ##"},{"id":"v-475d40f6#示例-用在状态管理库","path":"/React/Hooks/useSyncExternalStore.html#示例-用在状态管理库","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"示例：用在状态管理库","text":"示例：用在状态管理库 如果你有一个全局 store（类似 Redux），可以这样写： ```js function subscribe(callback) { // 假设 store 有 subscribe 方法 return store.subscribe(callback); } function getSnapshot() { return store.getState(); } function useStore() { return useSyncExternalStore(subscribe, getSnapshot); } ``` --- ##"},{"id":"v-475d40f6#参数详解","path":"/React/Hooks/useSyncExternalStore.html#参数详解","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"参数详解","text":"参数详解 - **subscribe(callback)** - 当外部状态变化时，调用 callback 通知 React 组件更新。 - 返回一个取消订阅的函数。 - **getSnapshot()** - 读取当前外部状态（同步返回）。 - 必须保证每次调用都能准确拿到最新值。 - **getServerSnapshot（可选）** - 用于 SSR 场景下服务端快照，客户端可忽略。 --- ##"},{"id":"v-475d40f6#为什么不用-useeffect-usestate-实现","path":"/React/Hooks/useSyncExternalStore.html#为什么不用-useeffect-usestate-实现","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"为什么不用 useEffect+useState 实现？","text":"为什么不用 useEffect+useState 实现？ - 传统的 `useEffect + useState` 在并发渲染下可能导致**数据撕裂**（React 渲染和外部数据不同步）。 - `useSyncExternalStore` 能让 React 知道外部数据的变化和读取时机，保证一致性和正确性。 --- ##"},{"id":"v-475d40f6#总结","path":"/React/Hooks/useSyncExternalStore.html#总结","pageTitle":"React 18+ useSyncExternalStore","headerTitle":"总结","text":"总结 - `useSyncExternalStore` 是连接外部状态和 React 组件的“官方桥梁”。 - 能保证并发渲染和 SSR/CSR 一致性，适合第三方状态库和自定义全局状态同步。 - 推荐用于“外部 store/全局状态/非 React 状态”的同步场景。 - 正确实现 subscribe/getSnapshot 就能让你的组件无缝订阅外部状态。 > 如果你只是用 React 内部状态（useState/useReducer/useContext），一般不需要用它。只有和 React 体系外的状态（全局 store、原生事件等）同步时才用。"},{"id":"v-59be81e4","path":"/en/Html+Css/","pageTitle":"html","headerTitle":null,"text":"# html ##"},{"id":"v-59be81e4#html1","path":"/en/Html+Css/#html1","pageTitle":"html","headerTitle":"html1","text":"html1 bababa ##"},{"id":"v-59be81e4#html2","path":"/en/Html+Css/#html2","pageTitle":"html","headerTitle":"html2","text":"html2 babaa"},{"id":"v-57883c6f","path":"/React/","pageTitle":"React 基础部分","headerTitle":null,"text":"# React 基础部分 ##"},{"id":"v-57883c6f#react-的特征","path":"/React/#react-的特征","pageTitle":"React 基础部分","headerTitle":"react 的特征","text":"react 的特征 react 概念：用于构建用户界面的 JavaScript 库，提供了 UI 层面的解决方案 react 有几个特征：虚拟 dom 树，"},{"id":"v-57883c6f#jsx-语法","path":"/React/#jsx-语法","pageTitle":"React 基础部分","headerTitle":"jsx 语法","text":"jsx 语法，组件化，单向数据流 - jsx：语法 - 只能有一个根节点；但是可以相互嵌套 - 换行或者多标签最好加括号,防止 js 自动分号不往后执行； - 虚拟 dom： - 虚拟 DOM 是在 DOM 的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟 DOM，最后再批量同步到 DOM 中。 - 在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而仅仅是 JavaScript 对象，称之为虚拟 DOM。 - 组件化： - 每一个 React 文件都是一个组件，含视图、逻辑操作、数据 - 组件可以被嵌套到其他组件之中 - 注意组件声明需要首字母大写，如`<TodoList />` - 单向数据流 - 子组件对于父组件传递过来的数据是【只读】的 - 子组件不可直接修改父组件中的数据，只能通过调用父组件传递过来的方法，来间接修改父组件的数据，形成了单向清晰的数据流 - 声明式编程 - 声明式编程表明想要实现什么目的，应该做什么，但是不指定具体怎么做。 - 声明式点一杯酒，只要告诉服务员：我要一杯酒即可； react 的优势： - 高效灵活 - 声明式的设计，简单使用 - 组件式开发，提高代码复用率 - 单向响应的数据流会比双向绑定的更安全，速度更快 react 有函数组件和类组件：类组件有 this 指向，状态和生命周期，函数组件没有，只有 hooks，Hooks 是 16.8 版本才新增的，给函数组件用的，让函数组件拥有类组件的功能 ## jsx 语法 JSX 是 React 的核心组成部分，它使用 XML 标记的方式去直接声明界面，界面组件之间可以互相嵌套。可以理解为在 JS 中编写与 XML 类似的语言,一种定义带属性树结构（DOM 结构）的语法 可以通过各种编译器将这些标记编译成标准的 JS 语言。 可以定义包含属性的树状结构的语法，类似 HTML 标签那样的使用，而且更便于代码的阅读。 使用 JSX 语法后，你必须要引入 babel 的 JSX 解析器，把 JSX 转化成 JS 语法，这个工作会由 babel 自动完成。同时引入 babel 后，你就可以使用新的 es6 语法，babel 会帮你把 es6 语法转化成 es5 语法，兼容更多的浏览器。 ##"},{"id":"v-57883c6f#函数组件和-class-组件区别","path":"/React/#函数组件和-class-组件区别","pageTitle":"React 基础部分","headerTitle":"函数组件和 class 组件区别","text":"函数组件和 class 组件区别 函数组件纯函数，输入 props，输出 jsx 函数组件没有实例，没有生命周期，没有 state 函数组件不能扩展其他方法 class 创建的组件,有自己的私有数据(this.state)和生命周期 ##"},{"id":"v-57883c6f#mvc-和-mvvm-的区别","path":"/React/#mvc-和-mvvm-的区别","pageTitle":"React 基础部分","headerTitle":"MVC 和 MVVM 的区别","text":"MVC 和 MVVM 的区别 - MVC 和 MVVM 都是常见的软件架构思想 - MVC - model: 数据层 - view: 视图层 - controller: 控制层 - MVC 的通信方式： view -> controller -> model -> view - MVVM - model: 数据层 - view: 视图层 - viewModel: 视图模型层 - MVVM 的通信方式： view <-> viewmodel -><- model ##"},{"id":"v-57883c6f#生命周期","path":"/React/#生命周期","pageTitle":"React 基础部分","headerTitle":"生命周期","text":"生命周期 - **初始化阶段** constructor 是一个特殊的函数，当这个类被实例化的时候，自动执行，最先执行，只执行一次 初始化 props 和 state - **挂载阶段** UNSAFE\\_ 前面有这个的就是被废弃了 带 Will 的一般都被废弃了 16.3 版本 _UNSAFE_componentWillMount()_ _render()_ - return 标签渲染页面 _componentDidMount()_ 数据请求 这里面基本上什么都可以写了 只能在 componentDidMount 里面请求数据 由于 fiber 算法的存在 在别的生命周期里每个片都会请求一次数据多次请求 - **数据更新阶段** - _shouldComponentUpdate()_ 作用：使用 shouldComponentUpdate 就是为了减少 render 不必要的渲染 一定要返回一个布尔值 里面手动判断页面是否需要渲染 shouldComponentUpdate 提供了两个参数 nextProps 和 nextState，表示下一次 props 和一次 state 的值，当函数返回 false 时候，render()方法不执行，组件也就不会渲染，返回 true 时，组件照常重渲染 当传递的是一个复杂对象时由于地址不相同所以就没用了 解决： 1. 使用 setState 改变数据之前，先采用 es6 中 assgin 进行拷贝，但是 assgin 只深拷贝的数据的第一层，所以说不是最完美的解决办法。 2. 使用 JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为 undefined 和函数时就会错。 - 使用 immutable.js 进行项目的搭建。immutable 中讲究数据的不可变性，每次对数据进行操作前，都会自动的对数据进行深拷贝，项目中数据采用 immutable 的方式，可以轻松解决问题，但是又多了一套 API 去学习 immutable.js Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象 Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享 - _UNSAFE_componentWillUpdate() {}_ - _componentWillReceiveProps_ - _componentWillUpdate()_ - _render()_ - _componentDidUpdate()_ - **销毁阶段** _componentWillUnmount_ 清除定时器，断开 websocket，取消事件监听，卸载第三方插件 ##"},{"id":"v-57883c6f#react-组件通信方法","path":"/React/#react-组件通信方法","pageTitle":"React 基础部分","headerTitle":"React 组件通信方法","text":"React 组件通信方法 在 React 中，组件是独立且可复用的。为了构建复杂的应用，组件之间需要有效地交换数据。以下是几种核心的组件通信方法。 ###"},{"id":"v-57883c6f#_1-父组件向子组件通信-props","path":"/React/#_1-父组件向子组件通信-props","pageTitle":"React 基础部分","headerTitle":"1. 父组件向子组件通信 (Props)","text":"1. 父组件向子组件通信 (Props) 这是最常见和最直接的通信方式。 - **核心思想**: 父组件通过 **props** 属性将数据单向传递给子组件。 - **实现**: 1. **父组件**: 在调用子组件时，像传递 HTML 属性一样，将数据绑定到子组件的 props 上。 2. **子组件**: 通过 `props` 对象接收数据。在函数组件中，`props` 是函数的第一个参数；在类组件中，通过 `this.props` 访问。 - **代码示例**: ```jsx // 父组件: ParentComponent.js import React from \"react\"; import ChildComponent from \"./ChildComponent\"; function ParentComponent() { const dataToSend = \"Hello from Parent!\"; return <ChildComponent message={dataToSend} />; } // 子组件: ChildComponent.js import React from \"react\"; function ChildComponent(props) { return <h2>{props.message}</h2>; // \"Hello from Parent!\" } ``` ###"},{"id":"v-57883c6f#_2-子组件向父组件通信-回调函数","path":"/React/#_2-子组件向父组件通信-回调函数","pageTitle":"React 基础部分","headerTitle":"2. 子组件向父组件通信 (回调函数)","text":"2. 子组件向父组件通信 (回调函数) 子组件不能直接修改父组件的状态，因此需要借助回调函数来间接通信。 - **核心思想**: 父组件将一个**函数作为 props** 传递给子组件，子组件在需要时调用这个函数，从而将数据作为函数参数传递回父组件。 - **实现**: 1. **父组件**: 定义一个用于更新状态的函数，并将其传递给子组件。 2. **子组件**: 通过 props 调用该函数，并将需要传递的数据作为参数传入。 - **代码示例**: ```jsx // 父组件: ParentComponent.js import React, { useState } from \"react\"; import ChildComponent from \"./ChildComponent\"; function ParentComponent() { const [messageFromChild, setMessageFromChild] = useState(\"\"); const handleChildData = (data) => { setMessageFromChild(data); }; return ( <div> <p>Message from child: {messageFromChild}</p> <ChildComponent onSendData={handleChildData} /> </div> ); } // 子组件: ChildComponent.js import React from \"react\"; function ChildComponent(props) { const handleClick = () => { props.onSendData(\"Hi, I'm the child!\"); }; return <button onClick={handleClick}>Send Data to Parent</button>; } ``` ###"},{"id":"v-57883c6f#_3-跨级组件通信-context-api","path":"/React/#_3-跨级组件通信-context-api","pageTitle":"React 基础部分","headerTitle":"3. 跨级组件通信 (Context API)","text":"3. 跨级组件通信 (Context API) 当组件层级很深，通过 props 逐层传递数据会变得非常繁琐（即 \"props drilling\"），此时 Context 提供了一种更优雅的解决方案。 - **核心思想**: Context 提供了一个全局的“上下文”，允许父组件向其下任意层级的子组件直接传递数据，而无需手动逐层传递。 - **核心 API**: `React.createContext`, `Provider`, `Consumer`, `useContext` Hook。 - **实现步骤**: 1. **创建 Context**: 使用 `const MyContext = React.createContext(defaultValue);` 创建一个 Context 对象。 2. **提供 Context**: 在父组件或组件树的顶层，使用 `<MyContext.Provider value={data}>` 组件包裹所有需要访问该数据的子组件。`value` 属性就是要共享的数据。 3. **消费 Context**: - **`useContext` Hook (推荐)**: 在函数组件中，使用 `const value = useContext(MyContext);` 直接获取 `value`。这是最简洁现代的方式。 - **`Consumer` 组件**: 在类组件或旧版函数组件中，使用 `<MyContext.Consumer>{value => /* JSX based on value */}</MyContext.Consumer>`，通过渲染属性（render prop）的方式来获取数据。 - **代码示例 (使用 `useContext`)**: ```jsx // theme-context.js import React, { createContext, useContext } from \"react\"; // 1. 创建 Context const ThemeContext = createContext(\"light\"); // App.js (提供者) function App() { const theme = \"dark\"; return ( <ThemeContext.Provider value={theme}> <Toolbar /> </ThemeContext.Provider> ); } // Toolbar.js (中间组件) function Toolbar() { return <ThemedButton />; } // ThemedButton.js (消费者) function ThemedButton() { // 3. 使用 useContext 消费数据 const theme = useContext(ThemeContext); return <button>Current theme is: {theme}</button>; } ``` ###"},{"id":"v-57883c6f#_4-状态管理库-redux-zustand-等","path":"/React/#_4-状态管理库-redux-zustand-等","pageTitle":"React 基础部分","headerTitle":"4. 状态管理库 (Redux / Zustand 等)","text":"4. 状态管理库 (Redux / Zustand 等) 对于大型、复杂应用，组件间的通信关系可能错综复杂。此时，使用专门的状态管理库可以提供一个集中式、可预测的状态容器。 - **核心思想**: 将所有共享状态（state）存储在一个全局的 \"Store\" 中。任何组件都可以从 Store 中读取状态，并可以 \"dispatch\" 一个 \"action\" 来请求更新状态。状态的更新逻辑由 \"reducer\" 函数集中处理。 - **代表库**: - **Redux**: 经典的状态管理库，生态成熟，中间件丰富，遵循严格的单向数据流。 - **Zustand**: 一个更轻量、更现代的状态管理方案，API 简单，基于 Hooks，无需大量模板代码。 ###"},{"id":"v-57883c6f#_5-本地状态共享-hooks","path":"/React/#_5-本地状态共享-hooks","pageTitle":"React 基础部分","headerTitle":"5. 本地状态共享 (Hooks)","text":"5. 本地状态共享 (Hooks) React Hooks 提供了一些强大的工具，可以在组件内部或相关组件之间共享逻辑和状态。 #### a. `useReducer` - **核心思想**: `useReducer` 是 `useState` 的替代方案。当状态逻辑比较复杂，或者下一个状态依赖于前一个状态时，`useReducer` 更为适用。它可以看作是单个组件内部的 \"小型 Redux\"。 - **API**: `const [state, dispatch] = useReducer(reducer, initialState);` - `reducer`: 一个函数 `(state, action) => newState`，根据 action 来计算新 state。 - `initialState`: 初始状态。 - `dispatch`: 一个函数，用于触发 action，例如 `dispatch({ type: 'increment' })`。 - **注意**: `useReducer` 本身不处理异步操作（如 API 请求）。通常需要配合 `useEffect` 来处理副作用，例如在 `useEffect` 中获取数据，然后调用 `dispatch` 将数据存入 state。 #### b. 状态提升 (Lifting State Up) - **核心思想**: 当多个子组件需要共享和操作同一个状态时，应将这个状态提升到它们最近的共同父组件中进行管理。然后，父组件通过 props 将状态和更新状态的函数分发给需要的子组件。 - **本质**: 这并不是一种新的技术，而是 **Props** 和 **回调函数** 模式的结合与实践，是 React 设计的核心原则之一。 ###"},{"id":"v-57883c6f#_6-非嵌套组件通信-发布-订阅模式","path":"/React/#_6-非嵌套组件通信-发布-订阅模式","pageTitle":"React 基础部分","headerTitle":"6. 非嵌套组件通信 (发布-订阅模式)","text":"6. 非嵌套组件通信 (发布-订阅模式) 对于两个没有任何层级关系的组件，可以使用全局事件总线（Event Bus）来实现通信。 - **核心思想**: 创建一个中央事件管理器。一个组件（发布者）可以发布（`emit`）一个事件，其他任何组件（订阅者）只要订阅（`listen` 或 `on`）了该事件，就能收到通知并执行相应的回调。 - **实现**: 1. 引入一个事件库，如 `events` 或 `pubsub-js`。 2. 创建一个事件发射器实例。 3. 在组件 A 中，使用 `emitter.emit('eventName', data)` 来发布事件。 4. 在组件 B 的 `useEffect` 中，使用 `emitter.on('eventName', callback)` 来订阅事件。 5. **关键**: 在组件 B 卸载时，必须在 `useEffect` 的返回函数中调用 `emitter.off('eventName', callback)` 来取消订阅，以防止内存泄漏。 - **代码示例**: ```jsx // event-bus.js import { EventEmitter } from \"events\"; export const emitter = new EventEmitter(); // ComponentA.js (发布者) import { emitter } from \"./event-bus\"; function ComponentA() { const handleClick = () => { emitter.emit(\"message\", \"Hello from Component A!\"); }; return <button onClick={handleClick}>Send Global Message</button>; } // ComponentB.js (订阅者) import React, { useState, useEffect } from \"react\"; import { emitter } from \"./event-bus\"; function ComponentB() { const [message, setMessage] = useState(\"\"); useEffect(() => { const handleMessage = (msg) => setMessage(msg); emitter.on(\"message\", handleMessage); // 组件卸载时取消订阅 return () => { emitter.off(\"message\", handleMessage); }; }, []); // 空依赖数组确保只在挂载和卸载时执行 return <p>Received message: {message}</p>; } ``` --- ### **"},{"id":"v-57883c6f#总结","path":"/React/#总结","pageTitle":"React 基础部分","headerTitle":"总结","text":"总结** | 通信场景 | 推荐方法 | 核心 | | :-------------------- | :------------------------------ | :-------------------------------------- | | **父 -> 子** | **Props** | 最基础、最直接的数据传递。 | | **子 -> 父** | **回调函数** (通过 Props 传递) | 子组件调用父组件的函数。 | | **兄弟组件** | **状态提升** | 将共享状态放到共同的父组件中管理。 | | **跨多层级组件** | **Context API** (`useContext`) | 避免 Props 逐层钻取，实现全局数据共享。 | | **复杂应用/全局状态** | **状态管理库** (Redux, Zustand) | 集中式、可预测的全局状态管理方案。 | | **任意非嵌套组件** | **发布-订阅模式** (Event Bus) | 解耦组件，通过全局事件中心通信。 | ##"},{"id":"v-57883c6f#事件处理","path":"/React/#事件处理","pageTitle":"React 基础部分","headerTitle":"事件处理","text":"事件处理 ###"},{"id":"v-57883c6f#_1-事件命名和绑定","path":"/React/#_1-事件命名和绑定","pageTitle":"React 基础部分","headerTitle":"1. 事件命名和绑定","text":"1. 事件命名和绑定 - 事件名采用驼峰命名法（如 `onClick`、`onChange`）。 - 事件处理函数通常传递为函数引用，而不是字符串。 ```jsx // 正确 <button onClick={handleClick}>Click Me</button> // 错误 <button onClick=\"handleClick()\">Click Me</button> ``` --- ###"},{"id":"v-57883c6f#_2-阻止默认行为和事件冒泡","path":"/React/#_2-阻止默认行为和事件冒泡","pageTitle":"React 基础部分","headerTitle":"2. 阻止默认行为和事件冒泡","text":"2. 阻止默认行为和事件冒泡 React 事件对象是合成事件（SyntheticEvent），提供与原生 DOM 事件一致的接口。 ```jsx function handleSubmit(e) { e.preventDefault(); // 阻止默认提交 e.stopPropagation(); // 阻止事件冒泡 } <form onSubmit={handleSubmit}>...</form>; ``` --- ###"},{"id":"v-57883c6f#_3-向事件处理函数传递参数","path":"/React/#_3-向事件处理函数传递参数","pageTitle":"React 基础部分","headerTitle":"3. 向事件处理函数传递参数","text":"3. 向事件处理函数传递参数 可以使用箭头函数或 bind 方法： ```jsx <button onClick={() => handleClick(id)}>Delete</button> <button onClick={handleClick.bind(this, id)}>Delete</button> ``` --- ###"},{"id":"v-57883c6f#_4-事件对象","path":"/React/#_4-事件对象","pageTitle":"React 基础部分","headerTitle":"4. 事件对象","text":"4. 事件对象 事件处理函数的第一个参数为合成事件对象（SyntheticEvent），具有和原生事件类似的属性。 ```jsx function handleChange(event) { console.log(event.target.value); } <input onChange={handleChange} />; ``` --- ###"},{"id":"v-57883c6f#_5-this-指向","path":"/React/#_5-this-指向","pageTitle":"React 基础部分","headerTitle":"5. this 指向","text":"5. this 指向 - 使用 class 组件时，事件处理函数需要绑定 this，或使用箭头函数自动绑定。 - 函数组件中无需关心 this。 ```jsx // class 组件 class MyComponent extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { ... } render() { return <button onClick={this.handleClick}>Click</button> } } ``` --- ###"},{"id":"v-57883c6f#_6-事件池机制","path":"/React/#_6-事件池机制","pageTitle":"React 基础部分","headerTitle":"6. 事件池机制","text":"6. 事件池机制 - React 17 及以下，合成事件对象会被回收（事件池），异步访问事件属性时需调用 `event.persist()`。 - React 17 以上已取消事件池机制，但为兼容旧代码，可继续调用 `event.persist()`。 ```jsx function handleClick(e) { e.persist(); // 防止事件对象被回收 setTimeout(() => { console.log(e.type); }, 1000); } ``` --- ###"},{"id":"v-57883c6f#_7-常用事件类型","path":"/React/#_7-常用事件类型","pageTitle":"React 基础部分","headerTitle":"7. 常用事件类型","text":"7. 常用事件类型 | 事件类型 | 说明 | | ------------ | -------------- | | onClick | 点击事件 | | onChange | 输入、选择改变 | | onSubmit | 表单提交 | | onMouseEnter | 鼠标进入 | | onMouseLeave | 鼠标离开 | | onKeyDown | 键盘按下 | | onFocus | 获得焦点 | | onBlur | 失去焦点 | --- ###"},{"id":"v-57883c6f#_8-事件冒泡与捕获","path":"/React/#_8-事件冒泡与捕获","pageTitle":"React 基础部分","headerTitle":"8. 事件冒泡与捕获","text":"8. 事件冒泡与捕获 - React 默认事件是冒泡阶段。 - 支持捕获事件，写法如 `onClickCapture`。 ```jsx <div onClickCapture={() => console.log(\"捕获阶段\")}></div> ``` --- ###"},{"id":"v-57883c6f#_9-事件委托","path":"/React/#_9-事件委托","pageTitle":"React 基础部分","headerTitle":"9. 事件委托","text":"9. 事件委托 - React 事件委托到根节点（如 `document`），提升性能。 - 组件卸载时会自动移除监听，无需手动清理。 --- ###"},{"id":"v-57883c6f#_10-组合使用","path":"/React/#_10-组合使用","pageTitle":"React 基础部分","headerTitle":"10. 组合使用","text":"10. 组合使用 可结合 state、props、Context 等配合事件实现复杂交互。 ```jsx function Counter() { const [count, setCount] = React.useState(0); return <button onClick={() => setCount(count + 1)}>{count}</button>; } ``` ###"},{"id":"v-57883c6f#总结-2","path":"/React/#总结-2","pageTitle":"React 基础部分","headerTitle":"总结","text":"总结 - 使用合成事件，跨平台兼容。 - 事件名写法和原生不同。 - 事件处理参数、this 绑定需注意。 - 事件池影响异步操作。 - 支持事件捕获与冒泡、事件委托无需手动管理。 ##"},{"id":"v-57883c6f#受控组件与非受控组件","path":"/React/#受控组件与非受控组件","pageTitle":"React 基础部分","headerTitle":"受控组件与非受控组件","text":"受控组件与非受控组件 受控组件与非受控组件 都是基于表单组件的 受控组件: 表单由我们自己来控制的组件 就是包含 value 属性和 onChange 事件的组件 onChange 里面写 setState 改变当前点击的 value 的值赋值给 input 绑定的 value 非受控组件就是，表单交给 react 去控制 只有文件上传一定要使用非受控组件，其他时候都尽量使用受控组件 1. 引入 createRef 2. 定义 ipt = createRef(); 3. 表单上加 ref 属性 ```JSX <input type=\"text\" ref={this.ipt}/> ``` 4. 获取时用 this.ipt.current.value ##"},{"id":"v-57883c6f#hoc-高阶组件","path":"/React/#hoc-高阶组件","pageTitle":"React 基础部分","headerTitle":"hoc 高阶组件","text":"hoc 高阶组件 高阶组件是一个函数，这个函数要传入一个组件，并且返回一个新组件 高阶组件的取名一般用 with 开头，后面加功能 作用增强组件的功能,并且可以做复用 传入一个组件 return 一个功能更多的组件 高阶组件-加版权号 ```JSX const withCopy = (Comp) => { return class extends Component { render() { return ( <> {/_ {...this.props}是将接收到的 props 全部传递给子组件 _/} <Comp num={20} {...this.props}></Comp> {/_ <div>&copy;版权所有 贾滨旭 xxx </div> _/} </> ); } }; }; ``` ##"},{"id":"v-57883c6f#diff-算法-react-fiber-虚拟-dom","path":"/React/#diff-算法-react-fiber-虚拟-dom","pageTitle":"React 基础部分","headerTitle":"diff 算法 React Fiber 虚拟 dom","text":"diff 算法 React Fiber 虚拟 dom - diff 算法 用 js 对象模拟真实的 DOM 结构 当页面更新的时候比对虚拟 dom 和真实 dom 区别 然后在进行更新 只需要更改部分不需要将页面全部重新渲染 但是标准的的 Diff 算法复杂度需要 O(n^3) 虚拟 dom：将真实 dom 转换成变量存到内存中 diff 算法是一种通过同层的树节点进行比较的高效算法 特点： 1. 同级比较 2. key 值比较 3. 类的比较 拥有相同类的两个组件 生成相似的树形结构， 拥有不同类的两个组件 生成不同的树形结构。 React 里结合 Web 界面的特点做出了两个简单的假设来降低算法的复杂度 1. 两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构； 2. 对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分 - React Fiber 渲染的时候将一个大的进程拆分成小的片 在每个片结束后查看一下其他的进程 然后运行小一点的进程 再去执行下一个片 例子星巴克 虚拟 DOM 虚拟 dom 相当于在 js 和 真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把所记录的差异渲染再真实 dom 上，从而提高性能。 ##"},{"id":"v-57883c6f#时间复杂度-空间复杂度","path":"/React/#时间复杂度-空间复杂度","pageTitle":"React 基础部分","headerTitle":"时间复杂度 空间复杂度","text":"时间复杂度 空间复杂度 时间复杂度：是指执⾏当前算法所消耗的时间； 空间复杂度：是指执⾏当前算法需要占⽤多少内存空间 常⻅的量级有：常数阶 O(1)，对数阶 O(logN)，线性阶 O(n)，线性对数阶 O(nlogN)，平⽅阶 O(n²)，⽴⽅阶 O(n³)，K 次⽅阶 O(n^k)，指数阶 ##"},{"id":"v-57883c6f#protal-将组件放到页面中任意你想放的位置","path":"/React/#protal-将组件放到页面中任意你想放的位置","pageTitle":"React 基础部分","headerTitle":"protal 将组件放到页面中任意你想放的位置","text":"protal 将组件放到页面中任意你想放的位置 有时需要将元素渲染到 DOM 中的不同位置上去，这是就用到的 portal 的方法 protal 可以将组件放到页面中任意你想放的位置 引入 import { createPortal } from \"react-dom\"; 第一个参数 child 是可渲染的 react 子项，比如元素，字符串或者片段等。第二个参数 container 是一个 DOM 元素。 例子：对话框 模态框 轻提示 模态框例子 ```jsx // App.jsx import React, { Component } from \"react\"; import Modal from \"./Modal\"; // import { createPortal } from \"react-dom\"; class App extends Component { state = { show: false, }; open = (e) => { e.stopPropagation(); this.setState({ show: true, }); }; ok = (e) => { e.stopPropagation(); this.setState({ show: false, }); }; fn = () => { console.log(123); }; render() { return ( // portal的事件冒泡依旧会冒到原先的父元素上面 <main onClick={this.fn}> <h3>对话框</h3> <button onClick={this.open}>Open Modal</button> {/* {this.state.show && <Modal />} */} {/* {createPortal(<Modal />, document.querySelector(\"body\"))} */} <Modal visible={this.state.show} title=\"Basic Modal\" okText=\"确定\" onOk={this.ok} /> </main> ); } } export default App; ``` ```jsx import React, { Component } from \"react\"; import withPortal from \"./withPortal\"; import \"./style.css\"; import { bool, string } from \"prop-types\"; class Modal extends Component { render() { // console.log(this.props); // return ( // <div className=\"modal\"> // <div className=\"center\"> // <h4>Basic Modal</h4> // </div> // </div>; // ); return ( this.props.visible && ( <div className=\"modal\"> <div className=\"center\"> <h4>{this.props.title}</h4> <button onClick={this.props.onOk}>{this.props.okText}</button> </div> </div> ) ); } } Modal.defaultProps = { visible: false, title: \"标题\", }; Modal.propTypes = { visible: bool, title: string, }; export default withPortal(Modal); ``` ```js import { Component } from \"react\"; import { createPortal } from \"react-dom\"; // 添加portal的高阶组件，很多的对话框都需要加到body上，所以将createPortal提出来 const withPortal = (Comp) => { return class extends Component { render() { return createPortal( // 将接收到的所有的props，传递给子组件 <Comp {...this.props} />, document.querySelector(\"body\") ); } }; }; export default withPortal; ``` - createPortal 的优点 1.使用 Portal 后，界面定制比较灵活，Portlet 是一个容器，通过 console 可以更改 Portlet 的位置，尺寸，级别，外观等，Portlet 内部显示的内容也会随着改变。 2.Portal 有内部安全机制，可以在 Portal 上面定制角色、组及用户，可以指定哪些资源可以被哪些用户（组、角色）访问，对于那些不符合安全条件的用户登录，则看不到相关的资源。 3.Portal 允许自己利用已经开发好的资源（portlet 或者网页）按照自己的喜好定制自己的首页或者网站。提升了网站的可维护性。 4.Portal 软件里面都内置了很多其他方面的组件，比如全文检索，内容管理等。 5.Portal 支持多渠道访问，比如：同一个 Portal 可以不用修改就可以支持手机、PDA 访问。 - createPortal 的缺点 1.Portal 是标准的 Web 应用，不同厂商的实现不同，有学习曲线和时间成本。 2.Portal 的性能也是一个需要考虑的因素，如果一个页面上 Portlet 数量比较多，则显示速度会比普通的页面慢很多，如果启用了 Portlet 的页面级 cache，则速度会快很多，但使用 Portal 后，性能肯定是个问题。 3.Portal 的开发要比普通的开发步骤多，周期长，另外还要考虑一些引入了 Portal 后带来的技术细节，比如多个 Portlet 内容来自于多个独立的系统，如果使用 iFrame 带来的多 Session 的问题等等。 4.Portal 需要自己做很多工作才能完成的，比如 SSO（Single Sign-On 单点登录）。（后面可以不说） 5.Portal 有时候满足不了复杂项目的需要，需要自己二次开发，需要使用更专业的组件或者软件替代，比如内容管理，安全认证等领域。 6.使用 Portal 后，对于架构设计及开发过程都会产生很大影响，比如使用特定厂商的 Portal 产品后，需要使用特特定的 IDE 才能开发、部署，自动化的测试脚本的作用就会被削弱。 ##"},{"id":"v-57883c6f#react-路由","path":"/React/#react-路由","pageTitle":"React 基础部分","headerTitle":"React 路由","text":"React 路由 ###"},{"id":"v-57883c6f#react5","path":"/React/#react5","pageTitle":"React 基础部分","headerTitle":"React5","text":"React5 五版本路由总结 yarn add react-router-dom@5 ( 一般都用 5 版本 6 版本为新版本) 解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks 1. 如果项目要使用路由，那么项目的最外面要加上 BrowserRouter 组件 直接在出口文件给总的最大的组件套一个 BrowserRouter 标签 import { BrowserRouter } from \"react-router-dom\"; 2. 在组件中想使用路由的话在父组件引入 Link 这个 link 标签就相当于 a 标签做跳转 link 标签有一个 to 属性做跳转 to= \"路径\" 写法: import { NavLink, Route, Switch } from \"react-router-dom\"; 3. 对应的每一个 link 标签应该对应一个 Route 标签 Route 标签有两个属性 path=\"路径\" componen = {要渲染的组件名} 4. Route 标签的渲染属性有四个： 1. componen = {要渲染的组件名} 2. render ={ (props) =>{ return < 要渲染的组件名 （如果要传递 props 加 {...props}）/> } } 3. children={Mine} 4. ```jsx <Route path=\"/detail\"> <Detail /> </Route> ``` - _区别_ 路由里面最常见的渲染组件的属性是 component component 可以渲染类组件和函数组件 render属性页可以渲染组件，render属性只能渲染函数组件 render后面是可以写函数的, 那么就可以去加入逻辑判断 children属性也可以渲染组件，也只能渲染函数组件 不管url是否匹配，都会渲染 如果加了Switch，那么就和render的效果一摸一样 在Route组件的里面，直接写组件， 可以渲染类组件和函数组件 这种方式默认是拿不到路由信息的, 除非配合withRouter高阶组件 5. react 的路由是包容性路由 (vue 的路由是排他性路由) 用 Switch 标签套在 Route 标签外面，如果你要匹配多个路由，你得在外面加一个盒子，确保唯一子元素，读取时从上往下读，只要有一个匹配就不往下匹配了 exact 表示精准匹配 Switch 表示 分支匹配， 将包容性路由变成排他性路由 注意： - Vue 是排他性路由，react 默认是包容性路由 - react 默认是 history 模式 - exact 表示精准匹配 - Switch 表示 分支匹配， 将包容性路由变成排他性路由 - 如果要做二级路由的时候，一级路由不能用精准匹配 - 路由信息要全部来自于 props 6. 路由嵌套 - 二级/多级路由 在嵌套的子组件 也就是二级路由里面在写一个路由 link 标签 对应的 route 标签 这个组件的 props 里面就会有路由信息 // ?. 可选链操作符 - 如果有这个属性就打印如果没有就不打印 console.log(this.props.match?.params?.id); 7. 路由重定向 import { Link, Route, Switch, Redirect } from \"react-router-dom\"; 从 react-router-dom 中解构出 Redirect 在和 Route 标签平级的地方写重定向标签 ```jsx <Redirect from=\"要改变的路径\" to=\"要改成什么路径\" exact></Redirect> ``` 8. 路由鉴权 基础原理： 把 Route 标签里面的渲染属性换成 render 里面就可以写逻辑判断了 判断 localstorage 里面是否存在 token 如果有就是登陆过 然后 return 一个要渲染成的组件 不过不存在 token 渲染登录页的组件 写法： ```jsx <Route path=\"/mine\" render={() => { if (localStorage.getItem(\"token\")) { return <Mine />; } else { return <Redirect from=\"/mine\" to=\"/login\"></Redirect>; } }} ></Route> ``` 封装组件： 原理：自定义一个组件 用这个组件去替换 route 标签 这个组件 return 一个 Route 标签 写法： ```jsx // 标签部分： <Auth path=\"/mine\"> <Mine /> </Auth>; // 组件部分： const Auth = (props) => { return ( <Route path={props.path} render={() => { if (localStorage.getItem(\"token\")) { return props.children; } else { return ( <Redirect from={props.path} to={`/login?from=${props.path}`} ></Redirect> ); } }} ></Route> ); }; ``` 9. 404 页面 404 页面一定要写在 Route 的最下面， Switch 不能少 在所有 route 的最下面写 404 页面的 route 标签 ```jsx <Route path=\"*\" component={Not}></Route> ``` 10. link 标签高亮 // NavLink 具有 Link 所有的功能，并且会多一个高亮的效果 引入的时候引入 NavLink，去替换 Link NavLink 标签会多一个类名 active 为这个类名添加样式即可 添加样式尾元素写法： .active::before { content: \">\"; } 11. 让函数组件有类组件的功能 Hocks 引入 useHistory，useParams，useLocation import { Link, Route, Switch, useHistory, useParams, useLocation, } from \"react-router-dom\"; 在组件里直接打印 Hocks 调用的结构就有了 hooks 是 react16.8 版本新增的， 只能给函数组件使用 帮助函数组件拥有类组件的功能 所有的 hooks 都是函数 hooks 的调用必须在函数组件的顶层 12. 路由模块化 路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的 URL 去切换组件；在 web 应用前端开发中，路由系统是最核心的部分，当页面的 URL 发生改变时，页面的显示结果可以根据 URL 的变化而变化，但是页面不会刷新。 - BrowserRouter 与 HashRouter 的区别： （1）底层原理不一样：BrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下版本；HashRouter 使用的是 URL 的哈希值； （2）path 表现形式不一样：BrowserRouter 的路径中没有#,例如：localhost:3000/demo/test；HashRouter 的路径包含#,例如：localhost:3000/#/demo/test； （3）刷新后对路由 state 参数的影响：BrowserRouter 没有任何影响，因为 state 保存在 history 对象中；HashRouter 刷新后会导致路由 state 参数的丢失； ###"},{"id":"v-57883c6f#react-router6","path":"/React/#react-router6","pageTitle":"React 基础部分","headerTitle":"React-Router6","text":"React-Router6 六版本路由和五版本区别总结 yarn add react-router-dom 解构出的东西大写的是组件 小写的是方法 with 开头的是高阶组件 hoc 以 use 开头的是 Hocks 1. Switch 组件没有了 改成了 Routes， 并且 Routes 是不能少的， 会变成排他性路由 Routes 里面只能放 Route 2. 渲染组件只剩 element 一种了，里面写的是实例化的结果或者元素 不需要加 exact，也是精准匹配 用 element 渲染出来的组件全都是没有路由信息的 想要有路由信息就要用 hocks <!-- <Route path=\"/\" element={<Home />}></Route> --> 3. 路由嵌套 需要引入 Outlet 组件 相当于 props.children 在 Routes 里面直接做嵌套 4. link 标签里面可以传 pathname search hash state(看不见的数据传递 不显示在地址栏上面) ```jsx <Link to={{ pathname: \"/about\", search: \"?a=3&b=4\", hash: \"#abc\", state: { x: 10, y: 20, }, }} > about </Link> ``` 5. 编程式导航 在组件里写一个单击事件 引入 useNavigate const navigate = useNavigate(); const jump = () => { // 直接写路径相当于 push // navigate(\"/detail/888\"); // 相当于 replace // navigate(\"/home\", { replace: true }); // 直接写数字相当于 go 方法 navigate(-2); }; 6. 重定向 Navigate 组件用于做重定向 ```jsx <Route path=\"/\" element={<Navigate to=\"/home\"></Navigate>}></Route> ``` ###"},{"id":"v-57883c6f#hash-和-history","path":"/React/#hash-和-history","pageTitle":"React 基础部分","headerTitle":"hash 和 history","text":"hash 和 history - hash 是指 url 中#后面的部分，虽然出现在 URL 中，但不会被包括在 HTTP 请求中，这部分在服务器中会自动被忽略，但是在浏览器中可以通过 location.hash 来获取。主要是用到了，window.hashchange 事件，这个事件可以监听 url 中的 hash 值变化来进行 dom 操作。 onhashchange 事件触发的条件： 改变 url 地址，在最后面增加或者改变 hash 值 改变 location.herf 或者 location.hash 点击带有锚点的链接 浏览器前进后退可能会导致 hash 的变化，就是两个网页地址的 hash 值不同 实现思路：当浏览器地址栏 URl 的 hash 值发生改变时，就会触发 onhashchange 事件，这是需要通过 window.location.hash 可以拿到当前浏览器的 url 的 hash 值，执行不同的回调函数，加载不同的组件。 - history 利用 window.history 的 api： 主要使用到了 history.pushState()和 history.replaceState()这两个接口。二者均接收三个参数，分别是 state，title，url， state 用来存放将要插入 history 实体的相关信息，是一个 json 格式的参数； title 是传入 history 实体的标题，firefox 现在会自动忽略掉这个属性； url 用来传递新的 history 实体的相对路径，如果其值为 null 则表示当前要插入的 history 实体与前一个实体一致，没有改变。 两者唯一的区别在于 replaceState()方法会将最新一条的 history 实体覆盖掉，而不是直接添加。 这两个方法都不会主动触发浏览器页面的刷新，只是 history 对象包括地址栏的内容会发生改变，当触发前进后退等 history 事件时才会进行相应的响应 - 区别： Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候 ###"},{"id":"v-57883c6f#路由鉴权","path":"/React/#路由鉴权","pageTitle":"React 基础部分","headerTitle":"路由鉴权","text":"路由鉴权 可以在 route 中的 render 上直接做判断 定义一个 auth 的函数组件，传入一个 props，里面 path 就是 props.path 里面 render 的时候做判断 一般都是判断登没登陆过 判断 localStorage 是否有 token，如果有的话就渲染组件，如果没有的话就重定向到登录页面。 ###"},{"id":"v-57883c6f#路由懒加载","path":"/React/#路由懒加载","pageTitle":"React 基础部分","headerTitle":"路由懒加载","text":"路由懒加载 - 从 react 中解构出 lazy 和 Suspense - lazy 函数传入回调函数，回调函数用 import 例：const Child = lazy(() => import(\"./Child\")); - lazy 方法要和 Suspense 组件一起使用 - Suspense 组件需要有一个 fallback 属性，里面写组件，当这个要引得组件还没有引来得时候渲染 - suspense 要放在要做懒加载的组件外面 例：<Suspense fallback={<div>loading...</div>}> {this.state.isShow && <Child />} </Suspense> ###"},{"id":"v-57883c6f#自定义标签代替-a-标签跳转","path":"/React/#自定义标签代替-a-标签跳转","pageTitle":"React 基础部分","headerTitle":"自定义标签代替 a 标签跳转","text":"自定义标签代替 a 标签跳转 - 自定义一个组件，这个组件要去做编程式导航 - 在组件中添加 list，渲染出来 - 将要做跳转的标签加上点击事件 - 如果要做跳转，首先要拿到路由信息的 history 对象 - 编程式导航 go/push/replace/goBack ##"},{"id":"v-57883c6f#fetch-和-axios-的区别","path":"/React/#fetch-和-axios-的区别","pageTitle":"React 基础部分","headerTitle":"fetch 和 axios 的区别","text":"fetch 和 axios 的区别 1. axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征： - 自动转换 JSON 数据 fetch 不可以 这也就是为什么 axios 只需要一步.then - axios 是一个基于 Promise 封装的一个 ajax 库 可以避免回调地狱 可以使用 async + await 实现同步代码 - axios 可以做拦截 请求数据之前可以做一些业务逻辑的判断 比如说判断有没有 token 如果没有 token 就取消这次请求 请求后也可以进行拦截 - 从浏览器中创建 XMLHttpRequest - 客户端支持防止 CSRF - 提供了一些并发请求的接口（重要，方便了很多的操作） - 从 node.js 创建 http 请求 - 拦截请求和响应 - 转换请求和响应数据 - 超时取消请求 2. fetch 优势： 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 同构方便，使用 isomorphic-fetch 更加底层，提供的 API 丰富（request, response） 脱离了 XHR，是 ES 规范里新的实现方式 3. fetch 存在问题 - fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 - fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'}) - fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 - fetch 没有办法原生监测请求的进度，而 XHR 可以 ##"},{"id":"v-57883c6f#redux-具体流程-saga","path":"/React/#redux-具体流程-saga","pageTitle":"React 基础部分","headerTitle":"redux 具体流程 saga","text":"redux 具体流程 saga 1. 创建一个仓库文件夹 2. 从 redux 里面解构出来 createStore 定义一个 store 常量等于 createStore(reducer) 把仓库暴露出去 3. 在 createStore 里面要写一个参数 reducer 一般 reducer 都是建一个单独的 reducer 文件 4. reducer 里面定义一个 reducer 函数并暴露出去 定义一个 defaultstate 作为 reducer 第一个参数的默认值 reducer = (state = defaultstate , action) 5. reducer reducer 为纯函数 （一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。） 有两个参数 第一个参数是 state = defaultstate 是状态里面存放数据 第二个参数是 action 用于接收组件传递的参数 写法： ```js const reducer = (state = defaultState, action) => { // type 的不同表示我们要做不同的事情 switch (action.type) { case \"increment\": // 返回出来的对象会去覆盖以前的 state 对象 return { // 将没有进行修改的数据全部保留下来 ...state, count: state.count + 1, }; case \"decrement\": // 返回出来的对象会去覆盖以前的 state 对象 return { // 将没有进行修改的数据全部保留下来 ...state, count: state.count - action.num, }; default: return state; } }; ``` 6. 在入口文件引入 react-redux 并解构出 Provide 引入 store 然后 用`<Provide store = {store}></Provide>`将引入的标签包起来 然后再在组件中从 react-redux 中解构出 { connect } 组件因为他的执行结果是一个高阶组件所以暴露的时候用 connect(mapStateToProps, mapDispatchToProps)(App) 7. connect 中有两个参数 mapStateToProps 和 mapDispatchToProps 意思是把仓库中的数据映射到 props 里面 用 this.props 可以调用 也可以不用 connect 可以使用 react-redux 提供的两个 hocks useSelector 和 useDispatch 这两个分别是获取仓库数据和调用仓库的方法的 **怎么使用：** useSelector： 定义一个变量去接收 useSelector 的参数是一个函数 这个函数的参数就是仓库中的 state 就可以获取数据了 const list = useSelector((state) => state.list); useDispatch： 定义一个 dispatch 实例 dispatch 调用的时候可以传一个对象作为参数 这个对象就是 reducer 的第二个参数 action 就可以传 type 和数据给仓库 8. mapStateToProps 写法 ： ```jsx const mapStateToProps = (state) => { return { // 将仓库的 count，变成组件的 props 的 count count: state.count, }; }; ``` 9. mapDispatchToProps dispatch 方法就相当于调用 reducer 函数 写法 ： ```jsx const mapDispatchToProps = (dispatch) => { return { add(num) { dispatch({ type: \"increment\", num }); }, }; ``` 10. 异步请求数据 store.js 在 store 中从 redux 中引入 applyMiddleware 然后下载 thunk 异步库 import thunk from \"redux-thunk\"; 创建仓库 createStore(reducer, applyMiddleware(thunk)) 建一个 actionCreators.js 文件 在这个文件中写一个函数去 return 一个对象 然后再组件中在引入这个函数去调用他 这样虽然是一样的但是在这个 actionCreators.js 中写的这个函数 return 这个对象之前就可以去请求数据 但是请求到之后还是要写一个同步方法去改变仓库数据 写的这个函数就是个异步函数用这个异步方法去调同步方法改变仓库数据 写法： ```jsx const initAction = (list) => { return { type: \"init\", list: list }; }; export const initAsyncAction = () => { // 请求数据 // Actions must be plain objects return (dispatch) => { fetch( \"https://www.fastmock.site/mock/15579798b9f988acd4d04ff978a2bd7c/api/list\" ) .then((response) => response.json()) .then((res) => { // return { type: \"init\", list: res.list }; dispatch(initAction(res.list)); }); }; }; ``` 11. 异步请求数据 -saga 异步库 思路： 首先在 store 的 index 中改变写法 引 saga 异步库 里面引入 sagas 文件 组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了 在 saga 里面进行一些操作 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer 然后 reducer 去改变里面的数据 最后在组件中再去调用一下仓库中的数据就有请求过后的数据了 组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action 1. 组件中用 useEffect 去调用 dispatch 但是这里的 dispatch 被 sagas 文件拦截了 useEffect(() => { dispatch({ type: \"init2\", }); // eslint-disable-next-line }, []); 2.--_ 在 saga 里面请求数据 在 saga 里面调用 reducer 函数 请求到数据之后 将请求到的数据传递给 reducer import { takeEvery, put, call } from \"redux-saga/effects\"; import axios from \"axios\"; function_ loadFn() { // 先请求数据 // call 用来请求数据 const res = yield call(() => { return axios .get(\"http://www.pudge.wang:3080/api/rated/list\") .then((res) => { return res.data; }); }); yield put({ type: \"init\", list: res.result, }); } function\\* mySaga() { yield takeEvery(\"init2\", loadFn); } export default mySaga; 2. reducer 去改变里面的数据 const reducer = (state = defaultstate, action) => { switch (action.type) { case \"init\": // console.log(action); // return { // ...state, // list: action.list, // }; return state.set(\"list\", action.list); //immutable 写法 default: return state; } 】 最后在组件中再去调用一下仓库中的数据就有请求过后的数据了 这里注意 组件中有两个 hocks 从 redux 中解构出来的 一个是调用仓库中的数据 一个是调用仓库中的 reducer 函数传入的是 action import { useSelector, useDispatch } from \"react-redux\"; const list = useSelector((state) => state.get(\"list\")); 12. 配置 saga sagas 文件里面请求数据 请求到数据之后调用 put 方法相当于 下载 saga 1. yarn add redux-saga 2. 在 store 中从 redux 中引入 applyMiddleware 3. 创建一个 sagas.js 文件 引入到 store 的 index 中 import mySaga from \"./sagas\"; 4. 从 react-saga 中引入 createSagaMiddleware import createSagaMiddleware from \"redux-saga\"; 5. createSagaMiddleware 是个函数 将他的执行结果定义为一个变量 const sagaMiddleware = createSagaMiddleware(); 6. 创建仓库 createStore(reducer, applyMiddleware(sagaMiddleware)) 7. 最后在暴露之前执行 sagaMiddleware.run(mySaga); **sagas 文件中写什么** 从 redux-saga/effects 中解构 takeEvery 和 put import { takeEvery, put } from \"redux-saga/effects\"; takeEvery:用来监听的 只要在组件里面去调用 dispatch，会优先进入 mySaga 函数 第一个参数是函数名，对应的是组件的 dispatch 的 type 第二个参数是回调函数 put：用来调用 reducer 的函数 call：用来做数据请求的 里面写一个生成器函数 调用 takeEvery 函数 里面有两个参数 第一个参数是组件调用 dispatch 时候的名字 第二个参数是一个函数可以接收一个参数相当于 reducer 中的 action 第二个参数对应的函数中写 put 函数 put 就相当于调用 dispatch 执行的时候会先到 sagas 这个文件里面来执行过之后再到 reducer import { takeEvery, put ,call } from \"redux-saga/effects\"; function* addFn(action) { yield put({ type: \"add\", payload: action.payload, }); } function* mySaga() { yield takeEvery(\"add2\", addFn); } export default mySaga; 13. actionTypes 写法就是用一个文件里面定义一个常量大写并暴露出去 替换 reducer 里面的 case 的条件 14. 模块化 ###"},{"id":"v-57883c6f#thunk-和-saga-的区别","path":"/React/#thunk-和-saga-的区别","pageTitle":"React 基础部分","headerTitle":"thunk 和 saga 的区别","text":"thunk 和 saga 的区别 redux-thunk 和 redux-saga 处理异步任务的时机不一样。对于 redux-saga，相对于在 redux 的 action 基础上，重新开辟了一个 async action 的分支，单独处理异步任务 saga 自己有一套监听机制 saga 会比 thunk 难一点 ##"},{"id":"v-57883c6f#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件","path":"/React/#redux-本来是同步的-为什么它能执行异步代码-这句话就是中间件的作用-中间件的实现原理是什么-都有哪些中间件","pageTitle":"React 基础部分","headerTitle":"redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？","text":"redux 本来是同步的，为什么它能执行异步代码（这句话就是中间件的作用）？中间件的实现原理是什么？都有哪些中间件？ redux 本来是同步的，为什么它能执行异步代码 当我们需要修改 store 中值的时候，我们是通过 dispatch(action)将要修改的值传到 reducer 中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理 action 的机会，在 middleware 中，我们可以检阅每一个流过的 action，并挑选出特定类型的 action 进行相应操作，以此来改变 action； ··· applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后 applyMiddleware 会将不同的中间件一层一层包裹到原生的 dispatch 之上； redux-thunk 中间件的作用就是让我们可以异步执行 redux，首先检查参数 action 的类型，如果是函数的话，就执行这个 action 这个函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action。 ··· 中间件的实现原理是什么？ 中间键的原理就是将原来的 dispatch 存起来然后改变他的指向 重命名 ··· 都有哪些中间件？ redux-thunk redux-saga ##"},{"id":"v-57883c6f#react-按需加载","path":"/React/#react-按需加载","pageTitle":"React 基础部分","headerTitle":"React 按需加载","text":"React 按需加载 从 react 中解构 lazy 引入的时候用 lazy 去替换原本模块化的 import 引入 结合 Router 可以做到组件懒加载的效果 const Home = lazy(() => import('./routes/Home')) ##"},{"id":"v-57883c6f#immutable","path":"/React/#immutable","pageTitle":"React 基础部分","headerTitle":"immutable","text":"immutable 用于解决 JavaScript 数据修改的问题 引用数据类型之间传递的是地址 所以当修改其中一个一起改变 为了解决这个问题可以用 深 浅拷贝 JSON.parse JSON.stringfy 当对象的 value 是函数 或者 undefined 时会失效 Object.assign 但是这样会非常消耗性能 比如一个对象中某一个数据改变 会导致整个数据的地址改变 消耗内存 所以有了 immutable **例子 ：D:\\htlm5\\代码\\html5-3\\React.js\\react-basic-2110\\src\\19-immutable\\App.jsx** immutable 不可变数据 安装 - yarn add immutable 引入 import { Map, List, Seq, fromJS } from \"immutable\"; 定义 immutableData 1. Map import { Map } from \"immutable\"; const obj = Map({ a: 1, }); 获取数据用 get 方法 obj.get('a') // 1 2. Seq Seq 可以定义数组和对象 seq 是具有惰性的, 从结果出发，不用的东西是不会执行的 3. fromJS fromJS 定义的对象具有深度 里面的对象也是 immutable 对象 formJS 会递归的, 数组和对象都能用 改变数据需要新建一个变量 用 set 方法定义 const obj2 = obj.set(\"a\", 2); obj 于 obj2 比较的时候由于是赋值的所以是需要比较里面的数据相不相同 对象合并 - merge 定义数组 引入 List import { List } from \"immutable\"; immutable 数组有一些 api，这些 api 很多和原生 api 相同 const list1 = List([1, 2]); const list2 = list1.push(3, 4, 5); //1 2 3 4 5 const list3 = list2.unshift(0); //0 1 2 3 4 5 const list4 = list1.concat(list2, list3); console.log(list4); size 表示数组长度 console.log(list4.size === 13); 数组合并 immutable 数组可以使用数组的方法 所以直接 concat 就可以 ##"},{"id":"v-57883c6f#webpack","path":"/React/#webpack","pageTitle":"React 基础部分","headerTitle":"WebPack","text":"WebPack WebPack 可以看做是静态资源打包机，它做的事情是，分析你的项目结构，因为浏览器很多文件都不认识，所以要转换成浏览器认识的文件，将其打包为合适的格式以供浏览器使用。 前端环境分为 开发环境:无法在服务器环境中运行（本地做开发的时候） 生产环境:将开发环境的代码经过打包压缩编译之后的文件，放在测试环境服务器中运行 核心概念： wepack 管控打包转化的控制工具，将源码转成目标格式 entry：入口文件，它是一个数组，因为它有很多个入口， output：出口文件，打包出的文件所在目录 loader：转换器，用于对模块的源代码进行转换。（将不是 js 文件转成 js 文件经行打包压缩 8） 样式：style-loader、css-loader、less-loader、sass-loader 等 文件：raw-loader、file-loader 、url-loader 等 编译：babel-loader、coffee-loader 、ts-loader 等 校验测试：mocha-loader、jshint-loader 、eslint-loader 等 Plugin：插件，本质是构造函数，给工程化提供额外的功能 webpack 内置 UglifyJsPlugin，压缩和混淆代码。 webpack 内置 CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。 ProvidePlugin：自动加载模块，代替 require 和 import ··· 底层： 是由 node.js 来开发的--也就是说 webpack 配置文件都是 node.js 文件， 环境支持 node.js8 版本以上 书写规范：common.js 规范 ··· source-map 把错误映射到源码的位置 ··· 热更新 在应用程序的开发环境，方便开发人员在不刷新页面的情况下，就能修改代码，并且直观地在页面上看到变化的机制，提升开发效率。 ··· webpack 如何实现热部署 通过 webpack-dev-server 来实现，它是 webpack 官方提供的一个小型 Express 服务器，使用它可以为 webpack 打包生成的资源文件提供 web 服务。可以使用它来实时监听代码文件变化。 项目中只需要在配置文件 package.json 配置 hot: true, // 是否热更新即可开启 Hot Module Replacemen 即热模块替换 ##"},{"id":"v-57883c6f#webpack-与-grunt、gulp","path":"/React/#webpack-与-grunt、gulp","pageTitle":"React 基础部分","headerTitle":"webpack 与 grunt、gulp","text":"webpack 与 grunt、gulp 相同点：都是前端构建⼯具，grunt、gulp 以前流⾏，现在 webpack 流⾏，轻量化的任务还是可以⽤ gulp 来实现。 grunt 和 gulp 是基于任务和流的：找到⼀个⼜⼀个⽂件，做链式操作更新流上的数据，这个为⼀个任务，多个任务组成整个 web 构建流程。 webpack 是一个打包模块化 javascript 的工具，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目。loader 用于加载某些资源文件，plugin 用于扩展 webpack 的功能。 webpack 四个组成：⼊⼝，出⼝，loader，plugin ##"},{"id":"v-57883c6f#类型检查和默认值","path":"/React/#类型检查和默认值","pageTitle":"React 基础部分","headerTitle":"类型检查和默认值","text":"类型检查和默认值 函数式组件的默认值只能写成 App.defaultProps = { msg : \"zhangsan\" } 类组件的默认值可以在外面写 App.defaultProps = { msg : \"zhangsan\" } 也可以在类里面加一个 static 表示私有属性 static defaultProps = { name : \"wangwu\" } static propTypes = { name: PropTypes.string, }; 类型检查 import PropTypes from 'prop-types'; 写法同默认值 ##"},{"id":"v-57883c6f#ts-和-js-的区别-使用-typescript-的好处","path":"/React/#ts-和-js-的区别-使用-typescript-的好处","pageTitle":"React 基础部分","headerTitle":"Ts 和 JS 的区别 使用 typescript 的好处","text":"Ts 和 JS 的区别 使用 typescript 的好处 区别 Typescript 是 JavaScript 的超集，它支持所有 JavaScript 的语法，并在此基础上添加静态类型定义和面向对象的思想。最终编译成 JavaScript 运行。 TypeScript 它不是一门新的语言，而是用来规范 js 的，js 始终是一门弱类型语言 ，ts 它是 js 的超集 js 分成 EcmaScript(js 的语法规范),Dom(文档对象模型),Bom(浏览器对象模型)ts 实际上是 EcmaScript 的超集, ts 是强类型版的 js 使用 typescript 的好处 1.开源，跨平台。它本身不需要考虑运行环境的问题，所有支持 JavaScript 的地方都可以使用 typescript； 2.引入静态类型声明，减少不必要的类型判断和文档注释； 3。及早发现错误，静态类型检查 1 或编译时发现问题，不用等到运行； 4.类、接口的使用更易于构建和维护组件； 5.重构更方便可靠，适合大型项目； ##"},{"id":"v-57883c6f#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数","path":"/React/#react-中的-key-有什么作用-key-发生变化会发生什么-key-值发生改变后会执行哪些生命周期函数","pageTitle":"React 基础部分","headerTitle":"react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数","text":"react 中的 key 有什么作用 key 发生变化会发生什么 key 值发生改变后会执行哪些生命周期函数 - react 中的 key 有什么作用 1.简单的来说就是为了提高 diff 的同级比较的效率，避免原地复用带来的副作用 2.react 利用 key 来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个 key 对应一个组件，相同的 key react 认为是同一个组件，这样后续相同的 key 对应组件都不会被创 key 发生变化会发生什么 key 值不同组件会销毁再重新创建 key 值发生改变后会执行哪些生命周期函数 1.componentWillUnmount 2.constructor 3.componentWillMount（可以不说） 4.render 5.componentDidMount ##"},{"id":"v-57883c6f#react-中的闭包陷阱-closure-trap","path":"/React/#react-中的闭包陷阱-closure-trap","pageTitle":"React 基础部分","headerTitle":"React 中的闭包陷阱（Closure Trap）","text":"React 中的闭包陷阱（Closure Trap） ###"},{"id":"v-57883c6f#_1-什么是闭包陷阱","path":"/React/#_1-什么是闭包陷阱","pageTitle":"React 基础部分","headerTitle":"1. 什么是闭包陷阱？","text":"1. 什么是闭包陷阱？ 在 React 的函数式组件中，**闭包陷阱**常发生在 `useEffect`、`useCallback` 等 Hooks 中。其本质是：组件中的函数（尤其是在 effect 或回调中）形成了一个闭包，捕获并持有了**旧的（过时的）state 或 props 值**。 - 核心原因 - React 的函数组件每次渲染都是一次独立的“快照”。 - 组件内部的所有变量（state, props）和函数，都是该次渲染“快照”的一部分。 - 如果某个函数是在某次渲染中创建的，它就会“记住”当时的 state 和 props。 - 如果这个函数在后续渲染中没有被更新，它“记住”的就永远是旧的值。 --- ###"},{"id":"v-57883c6f#_2-经典陷阱案例-setinterval-计数器","path":"/React/#_2-经典陷阱案例-setinterval-计数器","pageTitle":"React 基础部分","headerTitle":"2. 经典陷阱案例：setInterval 计数器","text":"2. 经典陷阱案例：setInterval 计数器 - 错误示例 ```javascript import React, { useState, useEffect } from \"react\"; function IntervalCounter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { // 这里形成了闭包，count 永远是初始值 console.log(`正在更新 count... 闭包中捕获的 count 值是 ${count}`); setCount(count + 1); }, 1000); return () => clearInterval(intervalId); }, []); // 依赖数组为空，仅组件挂载时运行一次 return <h1>{count}</h1>; } ``` - 问题分析 - 初始渲染：`count` 为 0，`useEffect` 执行，`setInterval` 的回调函数被创建。 - 闭包形成：`setInterval` 的回调函数“记住”了初始渲染时的 `count`，这个值永远是 0。 - 后续行为： 1. 1 秒后，定时器触发，执行 `setCount(0 + 1)`，`count` 变为 1。 2. 2 秒后，定时器再次触发，但回调函数闭包里的 `count` 依旧是 0，再次 `setCount(0 + 1)`。 - **最终结果**：`count` 的值只会在 0 和 1 之间来回变化，无法持续递增。 --- ###"},{"id":"v-57883c6f#_3-如何避免闭包陷阱","path":"/React/#_3-如何避免闭包陷阱","pageTitle":"React 基础部分","headerTitle":"3. 如何避免闭包陷阱？","text":"3. 如何避免闭包陷阱？ - 方法一：正确使用依赖数组 ```javascript useEffect(() => { const intervalId = setInterval(() => { setCount(count + 1); }, 1000); return () => clearInterval(intervalId); }, [count]); // 把 count 加入依赖数组 ``` - 原理：`count` 每次改变，`useEffect` 会重新执行，旧定时器被清除，创建新定时器，捕获到最新的 `count`。 - 缺点：对于 `setInterval` 这类场景，频繁清除/创建定时器有性能开销，可能导致计时不准，通常**不推荐**。 --- - 方法二：使用函数式更新（推荐） ```javascript useEffect(() => { const intervalId = setInterval(() => { setCount((prevCount) => prevCount + 1); // 函数式更新 }, 1000); return () => clearInterval(intervalId); }, []); // 依赖数组为空 ``` - 原理：`setCount` 传入函数，React 会确保 `prevCount` 永远是**最新的状态值**。 - 优点：无须依赖外部闭包的变量，写法简洁，性能好，是最佳实践。 --- - 方法三：使用 useRef 保存最新值 适用于需要在异步回调中**读取最新 state 或 props**的场景。 ```javascript import React, { useState, useEffect, useRef } from \"react\"; function IntervalCounterWithRef() { const [count, setCount] = useState(0); const countRef = useRef(count); // 同步 ref 的值 useEffect(() => { countRef.current = count; }, [count]); useEffect(() => { const intervalId = setInterval(() => { setCount(countRef.current + 1); }, 1000); return () => clearInterval(intervalId); }, []); return <h1>{count}</h1>; } ``` - 原理：`ref` 对象在组件整个生命周期中不变。闭包捕获的是 `countRef` 这个稳定对象，通过 `.current` 总能读取到最新的 `count`。 - 优点：适用于任何需要异步回调中获取最新 state/props 的场景，通用性强。 --- ###"},{"id":"v-57883c6f#_4-总结","path":"/React/#_4-总结","pageTitle":"React 基础部分","headerTitle":"4. 总结","text":"4. 总结 - **闭包陷阱**是 React 函数组件开发中常见的陷阱，尤其在 `useEffect`、`setInterval`、异步回调等场景中。 - 推荐优先使用**函数式更新**解决闭包陷阱。 - 更复杂的场景下，可以通过 `useRef` 解决对最新 state/props 的读取问题。 --- ###"},{"id":"v-57883c6f#_5-参考","path":"/React/#_5-参考","pageTitle":"React 基础部分","headerTitle":"5. 参考","text":"5. 参考 - [React 官方文档 - Using the State Hook](https://react.dev/reference/react/useState) - [深入理解 React Hooks 的闭包陷阱](https://juejin.cn/post/6844904186715285512)"},{"id":"v-9eab5b8c","path":"/en/JavaScript/","pageTitle":"JavaScript","headerTitle":null,"text":"# JavaScript"},{"id":"v-17b728cb","path":"/en/React/Hooks.html","pageTitle":"hocks","headerTitle":null,"text":"# hocks ##"},{"id":"v-17b728cb#简介","path":"/en/React/Hooks.html#简介","pageTitle":"hocks","headerTitle":"简介","text":"简介 从 react 中解构出以 use 开头的函数 让函数式组件拥有类组件的功能 ##"},{"id":"v-17b728cb#usestate-让函数式组件拥有自己的状态","path":"/en/React/Hooks.html#usestate-让函数式组件拥有自己的状态","pageTitle":"hocks","headerTitle":"useState - 让函数式组件拥有自己的状态","text":"useState - 让函数式组件拥有自己的状态 useState 传入的参数就是状态中的数据 一个组件可以有多个 useState useState 的调用的结果是一个数组 useState 有两个参数 第一个参数是数据的默认值 第二个参数是改变这个状态的方法 从 useState 中可以解构出两个参数 state 和 setState 并且 state 的值能能通过 setState 去改变 第二个参数的写法和函数式组件中的 setState 一样 _写法_ let [state, setState] = useState(4); setState((state) => { return state - 1; }); ··· setState 是同步的还是异步的？ 在合成事件里面是异步的 在生命周期里面是异步的 在定时器里面是同步的 在原生 js 事件里面是同步的 ··· ##"},{"id":"v-17b728cb#useeffect-useeffect-是用来代替生命周期的","path":"/en/React/Hooks.html#useeffect-useeffect-是用来代替生命周期的","pageTitle":"hocks","headerTitle":"useEffect - useEffect 是用来代替生命周期的","text":"useEffect - useEffect 是用来代替生命周期的 一般这样写 const [count, setCount] = useState(10); useEffect 的第一个参数是一个函数 第二个参数是一个数组（依赖） 1. 如果只有一个参数的时候，相当于是 componentDidMount, componentDidUpdate 直接执行 2. 如果第二个参数是一个空数组，相当于 componentDidMount 刚开始执行一次 之后就不会在执行了 3. 如果不是空数组，相当于 componentDidMount 和 watch 依赖的值改变了里面就执行 4. 里面 return 一个函数，相当于 componentWillUnmount return 一个函数 在里面做清除定时器 卸载插件等操作 *如果在 useEffect 里面写封装好的数据请求 *会报警告 但是不会报错 说让数据请求写在 useEffect 里面 这是因为请求数据的时候 return 一个 fetch 如果 useEffect 里面 return 一个结果 那就相当于第 4 条变成 componentWillUnmount 了 解决办法： 第一参数里面写一个自执行函数 函数自执行了就没有 return 了 useEffect(() => { (async () => { const res = await getData(); console.log(res); })(); }, []); ##"},{"id":"v-17b728cb#uselayouteffect-和-useeffect-类似-大部分情况下-使用-useeffect","path":"/en/React/Hooks.html#uselayouteffect-和-useeffect-类似-大部分情况下-使用-useeffect","pageTitle":"hocks","headerTitle":"useLayoutEffect 和 useEffect 类似 大部分情况下 使用 useEffect","text":"useLayoutEffect 和 useEffect 类似 大部分情况下 使用 useEffect 区别： 简单来说就是调用时机不同，`useLayoutEffect`和原来`componentDidMount`&`componentDidUpdate`一致，在 react 完成 DOM 更新后马上**同步**调用的代码，会阻塞页面渲染。而`useEffect`是会在整个页面渲染完才会调用的代码 什么时候会用到呢 当你需要用 useEffect 去操作 dom 元素的时候 比如 useEfftct 让一个盒子在零秒内向右平移 100px 会出现闪屏 这时候就需要用到 useLayoutEffect ##"},{"id":"v-17b728cb#usecallback-usecallback-是用来缓存函数的","path":"/en/React/Hooks.html#usecallback-usecallback-是用来缓存函数的","pageTitle":"hocks","headerTitle":"useCallback useCallback 是用来缓存函数的","text":"useCallback useCallback 是用来缓存函数的 useCallback 当组件的数据改变的时候 默认是会全部重新渲染的 因为生命周期数据更新之后会重新 render 想让类组件里面的数据改变 并且引入的子组件不重新渲染 用 PureComponent 比较前后两次是否有变化 由于里面是对象 所以地址不同 所以把对象提出去定义成一个常量就好了 想让函数式组件里面的数据改变 并且引入的子组件不重新渲染 需要引入 memo memo 是一个高阶组件 给子组件套上 相当于类组件中的 PureComponent 然后把对象提到外面写 但是 如果函数式组件有一个自定义事件传参 需要用到函数里面的 state 就不能提到外面去写又由于函数式组件本身就相当于一个 render 他会把里面的所有东西从上往下执行 memo 将新的组件和旧的组件做对比的时候 这时候所产生的函数就又不是同一个函数了 地址不同 这时候就要用到 useCallback 来缓存函数 第一个参数是要缓存的函数，第二个参数是依赖- _只要函数式组件做自定义事件传参就要写_ 当一个事件要作为属性传递的时候使用它 写法 ： ```jsx import React, { useState, memo, useCallback } from \"react\"; // const fn2 = () => { // console.log(\"fn2\"); // }; const Child = memo(() => { console.log(\"Child\"); return ( <> <span> Child</span> </> ); }); const obj = { fontSize: 14 }; const App = () => { let [count, setCount] = useState(1); const fn = () => { setCount((count) => { return (count = count + 1); }); }; const fn2 = useCallback(() => { console.log(123); }, []); return ( <> <div> <Child style={obj} doSomething={fn2} /> <div>{count}</div> <button onClick={fn}>btn</button> {/_ <button onClick={fn2}>btn</button> _/} </div> </> ); }; ``` ##"},{"id":"v-17b728cb#usememo-类似于-vue-中的计算属性","path":"/en/React/Hooks.html#usememo-类似于-vue-中的计算属性","pageTitle":"hocks","headerTitle":"useMemo - 类似于 vue 中的计算属性","text":"useMemo - 类似于 vue 中的计算属性 当函数式组件中的一个数据改变的时候 整个函数式组件都会重新渲染 如果不想让其他的函数也跟着重新渲染 这时候就需要给他加 useMemo 缓存起来 useMemo 类似于 vue 中的计算属性 区别 useCallback 缓存的是函数本身 useMemo 缓存的是函数的返回值 useMemo 和 useCallback 也是可以互相改写的 利用上面的特性和函数柯理化 ##"},{"id":"v-17b728cb#usecontext-用于优化-context-中-consumer-的写法","path":"/en/React/Hooks.html#usecontext-用于优化-context-中-consumer-的写法","pageTitle":"hocks","headerTitle":"useContext - 用于优化 Context 中 Consumer 的写法","text":"useContext - 用于优化 Context 中 Consumer 的写法 用于优化 Context 中 Consumer 的写法 Provider 还是要正常写 这个 hocks 就是可以传入 createContext 的实例 直接获取到结果 写法： const { Provider 中的 value } = useContext(context2); ##"},{"id":"v-17b728cb#usereducer-用于创建一个小型的仓库","path":"/en/React/Hooks.html#usereducer-用于创建一个小型的仓库","pageTitle":"hocks","headerTitle":"useReducer - 用于创建一个小型的仓库","text":"useReducer - 用于创建一个小型的仓库 reducer 函数的写法和 redux 一样 defaultState 也一样 state 不用写等于 defaultState 调用的时候引入 useuseReducer 有两个参数 第一个参数就是 reducer 函数 第二个是 defaultState 从 useReducer 中解构出 state 和 dispatch 调用就调用 state.count dispatch 中传入 type const [state, dispatch] = useReducer(reducer, defaultState); useReducer 里面没有中间键 不能写异步操作 如果要写异步可以写 useEffect 先请求数据 在吧请求到的数据放到仓库里面 ##"},{"id":"v-17b728cb#useref-类似于-createref-用于获取-dom-节点-用-ref-绑定一点就可以了-在父组件的子组件标签上添加一个-ref-属性等于-useref-的实例","path":"/en/React/Hooks.html#useref-类似于-createref-用于获取-dom-节点-用-ref-绑定一点就可以了-在父组件的子组件标签上添加一个-ref-属性等于-useref-的实例","pageTitle":"hocks","headerTitle":"useRef - 类似于 createRef 用于获取 Dom 节点 用 ref 绑定一点就可以了 在父组件的子组件标签上添加一个 ref 属性等于 useRef 的实例","text":"useRef - 类似于 createRef 用于获取 Dom 节点 用 ref 绑定一点就可以了 在父组件的子组件标签上添加一个 ref 属性等于 useRef 的实例 在父组件就可以使用这个 useRef 的实例 函数组件不能绑定 ref？ useRef 还有一些其他的特性 可以绕过 CaptureValue 的特征 利用 useRef 定义的数据 拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。比如你设置一个定时器 然后当定时器没完成的时候去改变他的值 在变回去 他拿到的还是一个最终状态 但是这个 useRef 不是很好用 没有响应式 ##"},{"id":"v-17b728cb#useimperativehandle-通过-useimperativehandle-用于让父组件获取子组件内的索引-通过父组件让子组件获得焦点","path":"/en/React/Hooks.html#useimperativehandle-通过-useimperativehandle-用于让父组件获取子组件内的索引-通过父组件让子组件获得焦点","pageTitle":"hocks","headerTitle":"useImperativeHandle 通过 useImperativeHandle 用于让父组件获取子组件内的索引 通过父组件让子组件获得焦点","text":"useImperativeHandle 通过 useImperativeHandle 用于让父组件获取子组件内的索引 通过父组件让子组件获得焦点 通过父组件让子组件获得焦点原理 在父组件里面定义一个 ref 等于 useRef 的返回值 在子组件标签中写 ref= {ref} ，让子组件套上一个 forwardRef 高阶组件然后子组件自己也去定义一个 ref 和父组件的名称一样 给子组件中的元素也加上这个 ref 属性 然后在子组件中使用 useImperativeHandle 函数组件可以接受第二个参数 ref useImperativeHandle 的第一个参数是 ref 第二个参数是 input 标签中的那个 ref 的 current 去改变 ref 的指向 让父组件的子组件标签中的 ref 去指向 input 的 ref # redux 提供的两个 hocks ##"},{"id":"v-17b728cb#useselect-用于获取仓库数据的","path":"/en/React/Hooks.html#useselect-用于获取仓库数据的","pageTitle":"hocks","headerTitle":"useSelect 用于获取仓库数据的","text":"useSelect 用于获取仓库数据的 用于获取仓库数据的 useSelect 接收一个函数作为参数 写法： const list = useSelector((state) => state.list); ##"},{"id":"v-17b728cb#usedispatch-用于调用-reducer-函数","path":"/en/React/Hooks.html#usedispatch-用于调用-reducer-函数","pageTitle":"hocks","headerTitle":"useDispatch 用于调用 reducer 函数","text":"useDispatch 用于调用 reducer 函数 useDispatch 用于调用 reducer 函数 传入一个参数是对象 相当于 action ##"},{"id":"v-17b728cb#usehistory用于做页面跳转","path":"/en/React/Hooks.html#usehistory用于做页面跳转","pageTitle":"hocks","headerTitle":"useHistory用于做页面跳转","text":"useHistory用于做页面跳转 useHistory 用于做页面跳转 useHistory 的实例对象下面有 push go 等方法可以进行路由跳转 ##"},{"id":"v-17b728cb#uselocation-是用来获取路由信息下的-location-对象","path":"/en/React/Hooks.html#uselocation-是用来获取路由信息下的-location-对象","pageTitle":"hocks","headerTitle":"useLocation 是用来获取路由信息下的 location 对象","text":"useLocation 是用来获取路由信息下的 location 对象 是用来获取路由信息下的 location 对象 也可以用来做跳转 ##"},{"id":"v-17b728cb#自定义-hocks-相当于-vue-中的组合-api-相同的功能放在一个文件里面","path":"/en/React/Hooks.html#自定义-hocks-相当于-vue-中的组合-api-相同的功能放在一个文件里面","pageTitle":"hocks","headerTitle":"自定义 hocks 相当于 vue 中的组合 API 相同的功能放在一个文件里面","text":"自定义 hocks 相当于 vue 中的组合 API 相同的功能放在一个文件里面"},{"id":"v-7aa2930c","path":"/project/chrome-dev-tools.html","pageTitle":"浏览器调试工具","headerTitle":null,"text":"# 浏览器调试工具 [【浏览器调试工具精讲】Chrome Dev Tools精讲，前端必看！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&vd_source=471ae300a01d18a7dc8b121c6c288fd7) ##"},{"id":"v-7aa2930c#检查元素","path":"/project/chrome-dev-tools.html#检查元素","pageTitle":"浏览器调试工具","headerTitle":"检查元素","text":"检查元素 - 使用选择工具 - 先框选右键检查 ##"},{"id":"v-7aa2930c#打开","path":"/project/chrome-dev-tools.html#打开","pageTitle":"浏览器调试工具","headerTitle":"打开","text":"打开 f12 菜单>更多工具>开发者工具 ##"},{"id":"v-7aa2930c#打开命令菜单","path":"/project/chrome-dev-tools.html#打开命令菜单","pageTitle":"浏览器调试工具","headerTitle":"打开命令菜单","text":"打开命令菜单 ``` ctrl+shift+p command + shift + p ``` - 主题 switch to dark theme 可以切换调试工具到黑色主题 - **截屏**screenshot 截取的图片会以png的格式下载到电脑上 里面有四个选项 - capture area screenshot - capture full size screenshot：可以截取到所有的屏幕外滚动条的内容 - capture node screenshot：截取一个节点（元素）先选中一个节点 然后截取 - capture screenshot ##"},{"id":"v-7aa2930c#查找dom树","path":"/project/chrome-dev-tools.html#查找dom树","pageTitle":"浏览器调试工具","headerTitle":"查找dom树","text":"查找dom树 ctrl+f 查询方式 - 文本查询 - css选择器 - Xpath eg. //section/p // 意思是全局范围内寻找 找全局范围内的section标签下的p标签 - 在console面板内可以使用 inspect(dom)的方式查找节点 ##"},{"id":"v-7aa2930c#复制样式","path":"/project/chrome-dev-tools.html#复制样式","pageTitle":"浏览器调试工具","headerTitle":"复制样式","text":"复制样式 选中右键复制样式 在浏览器的element style中粘贴进去 computed面板 展示所有的style ##"},{"id":"v-7aa2930c#console面板","path":"/project/chrome-dev-tools.html#console面板","pageTitle":"浏览器调试工具","headerTitle":"console面板","text":"console面板 快捷键 ctrl+shift+j 执行语句 $_返回上一条语句的执行结果 $0上一个选择的DOM节点 console.group 层组 用console.groupEnd结尾 console.time 返回中间代码运行的时间 用console.timeEnd结尾 console.table参数是数组对象 可以吧数组对象可视化可以排序 ##"},{"id":"v-7aa2930c#断点","path":"/project/chrome-dev-tools.html#断点","pageTitle":"浏览器调试工具","headerTitle":"断点","text":"断点 在代码中加debugger或者在浏览器中直接加 比console效果好 可以在过程中监听到各个值的变化 f10下一步 f8 跳到下一个debugger 没有就结束了 右键节点 break on 有三个选项 - subtree modification当节点的子节点被修改时js暂停执行 - attribute modification 当节点的属性被修改时js暂停执行 - node removal 当节点被删除时js暂停执行 如果debugger的时候用框架写的跳转到了系统文件里面 可以忽略掉该文件 - 在Sources面板下右侧的Call Stack 中找到那个文件 右键选择add script to ignore list ##"},{"id":"v-7aa2930c#network","path":"/project/chrome-dev-tools.html#network","pageTitle":"浏览器调试工具","headerTitle":"Network","text":"Network Preserve log 保留历史请求 比如从一个页面跳转到另一个页面的时候 想看之前的请求 节流器 disable catch 去掉浏览器的缓存 HAR file 导入可以模拟网络环境 看到客户当时是什么情况 ##"},{"id":"v-7aa2930c#application","path":"/project/chrome-dev-tools.html#application","pageTitle":"浏览器调试工具","headerTitle":"Application","text":"Application 缓存 Local Storage和Session Storage的区别 local Storage回永久保存 除非手动删除 Session Storage关闭会话就删除 Cookies 可以设置过期时间的缓存"},{"id":"v-8a6b7344","path":"/project/deploy.html","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":null,"text":"# 实训平台 + Dify 全流程部署详细笔记 > 本文档详细记录了从本地环境准备到服务器部署、环境配置、端口开放、服务启动、模型接入等完整流程，适用于 ShiXunPlatForm-Web（前端）、ShiXunPlatform（后端）、ShiXunDify（Dify 智能体平台）等项目的搭建。请根据实际域名、密钥等进行相应替换。 --- ##"},{"id":"v-8a6b7344#_1-连接到服务器","path":"/project/deploy.html#_1-连接到服务器","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"1. 连接到服务器","text":"1. 连接到服务器 ###"},{"id":"v-8a6b7344#本机生成-ssh-密钥","path":"/project/deploy.html#本机生成-ssh-密钥","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"本机生成 SSH 密钥","text":"本机生成 SSH 密钥 ```bash ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" ``` - `-t` 指定密钥类型（一般为 rsa 或 ed25519）。 - `-b` 指定密钥长度（RSA 推荐 4096 位）。 - `-C` 注释，建议填写邮箱。 执行该命令后，程序会提示： - **Enter file in which to save the key**：直接回车使用默认路径（如`~/.ssh/id_rsa`），也可自定义路径。 - **Enter passphrase**：建议设置密码短语，增强私钥安全性。 命令执行完后，会在指定路径生成： - 私钥：如 `id_rsa` - 公钥：如 `id_rsa.pub` ###"},{"id":"v-8a6b7344#将公钥发送给服务器管理员","path":"/project/deploy.html#将公钥发送给服务器管理员","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"将公钥发送给服务器管理员","text":"将公钥发送给服务器管理员 管理员将你的公钥内容加到服务器的 `~/.ssh/authorized_keys` 文件中。 ###"},{"id":"v-8a6b7344#测试连接","path":"/project/deploy.html#测试连接","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"测试连接","text":"测试连接 ```bash ssh ubuntu@<your-server-ip> ``` 如有多个 SSH 密钥，指定私钥连接： ```bash ssh -i ~/.ssh/<your-key-name> ubuntu@<your-server-ip> ``` --- ##"},{"id":"v-8a6b7344#_2-代码拉取","path":"/project/deploy.html#_2-代码拉取","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"2. 代码拉取","text":"2. 代码拉取 ###"},{"id":"v-8a6b7344#dify-代码拉取-服务器端","path":"/project/deploy.html#dify-代码拉取-服务器端","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"Dify 代码拉取（服务器端）","text":"Dify 代码拉取（服务器端） 1. **生成服务器 SSH 密钥**（如未配置过）: ```bash ssh-keygen -t ed25519 -C \"your_email@example.com\" ``` 2. **把公钥加到 GitHub 账户/仓库 Deploy Keys**: ```bash cat ~/.ssh/id_ed25519.pub ``` 3. **测试 GitHub 连接:** ```bash ssh -T git@github.com ``` 4. **克隆 Dify 仓库代码（dev 分支）:** ```bash git clone -b dev git@github.com:XZXY-AI/ShiXunDify.git ``` ###"},{"id":"v-8a6b7344#实训平台代码拉取","path":"/project/deploy.html#实训平台代码拉取","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"实训平台代码拉取","text":"实训平台代码拉取 - 前端： ```bash git clone -b dev git@github.com:XZXY-AI/ShiXunPlatForm-Web.git ``` - 后端： ```bash git clone -b dev git@github.com:XZXY-AI/ShiXunPlatform.git ``` > 如遇到用户名密码问题，请确保 SSH Key 配置无误。 --- ##"},{"id":"v-8a6b7344#_3-部署准备工作","path":"/project/deploy.html#_3-部署准备工作","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"3. 部署准备工作","text":"3. 部署准备工作 ###"},{"id":"v-8a6b7344#_3-1-前端环境准备","path":"/project/deploy.html#_3-1-前端环境准备","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"3.1 前端环境准备","text":"3.1 前端环境准备 #### nvm 管理 Node - 安装 nvm： ```bash curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash ``` - 重新加载配置文件： - bash: `source ~/.bashrc` - zsh: `source ~/.zshrc` - 验证 nvm： ```bash nvm --version ``` - 安装 Node（LTS）： ```bash nvm install --lts ``` - 验证 Node： ```bash node -v ``` #### 安装 yarn、pnpm、pm2 ```bash npm install --global yarn npm install -g pnpm npm install -g pm2 ``` - 验证 pm2： ```bash pm2 --version ``` #### 安装依赖 切到前端目录： ```bash cd ShiXunPlatForm-Web yarn install --production ``` --- ###"},{"id":"v-8a6b7344#_3-2-certbot、docker、nginx-安装","path":"/project/deploy.html#_3-2-certbot、docker、nginx-安装","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"3.2 Certbot、Docker、Nginx 安装","text":"3.2 Certbot、Docker、Nginx 安装 - **安装 snap 核心和 Certbot:** ```bash sudo snap install core sudo snap refresh core sudo snap install --classic certbot sudo ln -s /snap/bin/certbot /usr/bin/certbot ``` - **安装 Docker:** ```bash sudo snap install docker docker -v ``` - **安装 Nginx:** ```bash sudo apt install nginx nginx -v ``` --- ###"},{"id":"v-8a6b7344#_3-3-配置环境变量","path":"/project/deploy.html#_3-3-配置环境变量","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"3.3 配置环境变量","text":"3.3 配置环境变量 #### 前端环境变量 进入 `ShiXunPlatForm-Web` 目录，编辑 `.env.production`： ```bash nano .env.production ``` 内容示例（请替换为实际域名）： ``` NEXT_PUBLIC_API_BASE_URL=https://test1.xinzhiaigc.com NEXT_PUBLIC_API_APP_URL=https://test2.xinzhiaigc.com ``` 保存退出后可 `cat .env.production` 验证。 --- #### 后端环境变量 - Python 版本需 3.10.12 ```bash sudo apt install python3 python3 --version ``` - 安装 certbot 及 nginx 插件 ```bash sudo apt install certbot python3-certbot-nginx -y ``` 编辑 ShiXunPlatform 的 `.env` 文件（请根据实际替换密钥、域名等）： ```bash cd ShiXunPlatform nano .env ``` 内容参考你需求文档中的示例。 --- #### Dify 环境变量 在 `ShiXunDify/docker` 下新建 `.env` 文件，内容参照你的详细模板，并根据实际情况替换域名、密钥等。 --- ##"},{"id":"v-8a6b7344#_4-系统级-nginx-及-https-配置","path":"/project/deploy.html#_4-系统级-nginx-及-https-配置","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"4. 系统级 Nginx 及 HTTPS 配置","text":"4. 系统级 Nginx 及 HTTPS 配置 ###"},{"id":"v-8a6b7344#获取-ssl-证书","path":"/project/deploy.html#获取-ssl-证书","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"获取 SSL 证书","text":"获取 SSL 证书 ```bash sudo certbot --nginx -d test1.xinzhiaigc.com -d test2.xinzhiaigc.com ``` ###"},{"id":"v-8a6b7344#重新加载-nginx","path":"/project/deploy.html#重新加载-nginx","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"重新加载 Nginx","text":"重新加载 Nginx ```bash sudo nginx -t sudo systemctl reload nginx ``` ###"},{"id":"v-8a6b7344#配置自动续期","path":"/project/deploy.html#配置自动续期","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"配置自动续期","text":"配置自动续期 ```bash sudo certbot renew --dry-run ``` ###"},{"id":"v-8a6b7344#nginx-配置软连接","path":"/project/deploy.html#nginx-配置软连接","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"Nginx 配置软连接","text":"Nginx 配置软连接 ```bash sudo ln -s /etc/nginx/sites-available/shixunPlatform-web /etc/nginx/sites-enabled/ ``` ###"},{"id":"v-8a6b7344#nginx-配置示例","path":"/project/deploy.html#nginx-配置示例","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"Nginx 配置示例","text":"Nginx 配置示例 编辑 `/etc/nginx/sites-available/shixunPlatform-web`（注意替换域名、路径等）： ```nginx server { server_name test1.xinzhiaigc.com test2.xinzhiaigc.com; set $project_root /home/ubuntu/ShiXunPlatForm-Web; client_max_body_size 50M; location /api/ { if ($host = \"test1.xinzhiaigc.com\") { set $target_upstream_static http://127.0.0.1:8000; } if ($host = \"test2.xinzhiaigc.com\") { set $target_upstream_static http://127.0.0.1:3000; } if ($target_upstream_static = \"\") { return 404; } proxy_pass $target_upstream_static; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 60s; proxy_send_timeout 60s; proxy_read_timeout 60s; } location / { proxy_pass http://127.0.0.1:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; } server { if ($host = test2.xinzhiaigc.com) { return 301 https://$host$request_uri; } if ($host = test1.xinzhiaigc.com) { return 301 https://$host$request_uri; } listen 80; server_name test1.xinzhiaigc.com test2.xinzhiaigc.com; return 404; } ``` --- ##"},{"id":"v-8a6b7344#_5-端口开放","path":"/project/deploy.html#_5-端口开放","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"5. 端口开放","text":"5. 端口开放 确保 3443、3000、3001 端口未被占用： ```bash sudo ss -tulnp | grep ':3443' sudo ss -tulnp | grep ':3000' sudo ss -tulnp | grep ':3001' ``` --- ##"},{"id":"v-8a6b7344#_6-启动服务","path":"/project/deploy.html#_6-启动服务","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"6. 启动服务","text":"6. 启动服务 ###"},{"id":"v-8a6b7344#启动-dify","path":"/project/deploy.html#启动-dify","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"启动 Dify","text":"启动 Dify 进入 `ShiXunDify/docker` 目录： ```bash sudo docker-compose up -d --build ``` 验证 3000 端口是否监听： ```bash sudo ss -tulnp | grep ':3000' ``` ###"},{"id":"v-8a6b7344#启动实训平台前端","path":"/project/deploy.html#启动实训平台前端","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"启动实训平台前端","text":"启动实训平台前端 进入 `ShiXunPlatForm-Web` 根目录： ```bash yarn build PORT=3001 pm2 start npm --name \"shixun-test\" -- run start ``` 查看 pm2 状态： ```bash pm2 list ``` ###"},{"id":"v-8a6b7344#启动实训平台后端","path":"/project/deploy.html#启动实训平台后端","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"启动实训平台后端","text":"启动实训平台后端 进入 ShiXunPlatform 目录： ```bash sudo docker-compose up --build -d ``` --- ##"},{"id":"v-8a6b7344#_7-dify-配置要点","path":"/project/deploy.html#_7-dify-配置要点","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"7. Dify 配置要点","text":"7. Dify 配置要点 - `.env` 文件中的域名、端口、API、密钥需全部根据实际修改，如： ``` APP_WEB_URL=https://test2.xinzhiaigc.com NGINX_SERVER_NAME=\"test1.xinzhiaigc.com test2.xinzhiaigc.com\" MAIN_SYSTEM_HOST=https://test1.xinzhiaigc.com MAIN_SYSTEM_ONLY_HOST=test1.xinzhiaigc.com APP_SYSTEM_ONLY_HOST=test2.xinzhiaigc.com ``` --- ##"},{"id":"v-8a6b7344#_8-常见问题与排查","path":"/project/deploy.html#_8-常见问题与排查","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"8. 常见问题与排查","text":"8. 常见问题与排查 - **端口冲突**：如端口被占用，需先释放后再启动服务。 - **环境变量漏填**：务必每个 `.env` 配置项都参考模版仔细填写。 - **域名解析未生效**：必须先完成 DNS 解析再申请证书和配置 nginx。 - **服务未启动或报错**：查看 `docker-compose logs`、`pm2 logs`、`nginx`/`certbot` 日志排查。 --- ##"},{"id":"v-8a6b7344#_9-附录","path":"/project/deploy.html#_9-附录","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"9. 附录","text":"9. 附录 ###"},{"id":"v-8a6b7344#快速命令参考","path":"/project/deploy.html#快速命令参考","pageTitle":"实训平台 + Dify 全流程部署详细笔记","headerTitle":"快速命令参考","text":"快速命令参考 - **查看端口占用**： ```bash sudo ss -tulnp | grep ':端口号' ``` - **重启 nginx**： ```bash sudo systemctl reload nginx ``` - **查看 pm2 列表**： ```bash pm2 list ``` - **docker-compose 启动**： ```bash sudo docker-compose up -d --build ``` ---"},{"id":"v-715f7b72","path":"/project/fileUpload.html","pageTitle":"前端大文件上传","headerTitle":null,"text":"# 前端大文件上传 - 功能 - 分片，断点续传、暂停/继续/取消、进度条、并发上传、自动重试、断点恢复等 - 技术栈 - 前端：Next.js（App Router）、Ant Design（UI）、TypeScript - 通信：fetch+FormData - 后端：Next.js API 路由，Node.js 文件操作 ##"},{"id":"v-715f7b72#初始实现-基础上传与进度条","path":"/project/fileUpload.html#初始实现-基础上传与进度条","pageTitle":"前端大文件上传","headerTitle":"初始实现：基础上传与进度条","text":"初始实现：基础上传与进度条 - 实现目标 - 完成基础的文件上传功能，为后续扩展打好基础。 - 提供文件上传入口，上传后能获得文件访问链接。 - UI 能反馈上传进度（最初用模拟进度）。 - 前端实现 - 使用 Ant Design 的 Upload 组件，触发上传操作。 - 利用 beforeUpload 拦截文件，实现自定义上传逻辑。 - 进度条组件展示上传进度，最初阶段可简单模拟。 - 关键代码片段： ```tsx <Upload showUploadList={false} beforeUpload={beforeUpload} maxCount={1} > <Button icon={<UploadOutlined />}>上传文件</Button> </Upload> <Progress percent={progress} /> ``` - 后端实现 - 提供 `/api/upload` POST 接口，支持 multipart/form-data。 - 文件直接保存到 `public/uploads` 目录。 - 返回上传后文件的 URL 供前端展示。 - 关键代码片段（省略部分细节）： ```typescript export async function POST(req: NextRequest) { const formData = await req.formData(); const file = formData.get(\"file\") as File; const fileName = formData.get(\"fileName\") as string; if (file && fileName) { const bytes = await file.arrayBuffer(); const buffer = Buffer.from(bytes); await fs.writeFile(filePath, buffer); const fileUrl = `/uploads/${fileName}`; return NextResponse.json({ url: fileUrl }); } return NextResponse.json({ error: \"参数不全\" }, { status: 400 }); } ``` - 知识点与扩展 - Ant Design 的 Upload 组件自带 UI 体验好，但大文件上传、断点等高级功能需自定义。 - fetch+FormData 适合现代浏览器环境，便于后续扩展分片上传。 - 进度条初始实现可直接受控于上传事件，后续可与分片进度结合。 ##"},{"id":"v-715f7b72#分片上传与真实进度","path":"/project/fileUpload.html#分片上传与真实进度","pageTitle":"前端大文件上传","headerTitle":"分片上传与真实进度","text":"分片上传与真实进度 - 目标 - 解决大文件上传问题，防止浏览器内存溢出和网络异常导致的上传失败。 - 进度条要能真实反映上传进度。 - 实现细节 - 前端将文件按固定大小（如 2MB）切片，每个分片单独上传。 - 分片进度通过“已上传分片数/总分片数”计算，进度条实时反馈。 - 分片上传可采用串行或并发，后续实现并发。 - 关键代码片段： ```typescript const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB const totalChunks = Math.ceil(file.size / CHUNK_SIZE); const chunk = file.slice(start, end); // 分片上传 const formData = new FormData(); formData.append(\"file\", chunk); formData.append(\"fileId\", fileId); formData.append(\"chunkIndex\", chunkIndex.toString()); formData.append(\"totalChunks\", totalChunks.toString()); ``` - 后端支持 - 每个分片单独存储，目录结构为 public/uploads/chunks/${fileId}/${chunkIndex} - 提供合并接口，前端上传完毕后通知后端合并为完整文件。 - 知识点与扩展 - `File.slice` 支持大文件切割，浏览器兼容性好。 - 分片上传能显著提升大文件上传的可靠性和容错性。 - 进度条以分片为单位更真实，便于处理重试/断点等场景。 ##"},{"id":"v-715f7b72#断点续传与分片管理","path":"/project/fileUpload.html#断点续传与分片管理","pageTitle":"前端大文件上传","headerTitle":"断点续传与分片管理","text":"断点续传与分片管理 - 目标 - 支持断点续传，保证上传失败/刷新后可以继续，提升用户体验和资源利用率。 - 实现细节 - 上传前先询问后端哪些分片已上传，避免重复上传。 - 上传进度实时保存到 localStorage，刷新后可恢复状态。 - 上传完成后，前端发起合并请求，后端负责合并分片并清理临时目录。 - 关键代码片段： ```typescript // 查询已上传分片 async function getUploadedChunks(fileId: string) { ... } // 保存断点到 localStorage localStorage.setItem( `upload_${fileId}`, JSON.stringify({ fileName: file.name, fileSize: file.size, totalChunks, uploadedChunks: Array.from(finishedSet), }) ); ``` - 后端 GET `/api/upload?fileId=...` 返回已上传分片索引数组，POST 支持单分片上传。 - 知识点与扩展 - 利用 localStorage 记录断点，前端可随时恢复上传状态。 - 分片上传与断点续传方案配合能极大提高大文件上传的可用性。 - 分片索引同步保证前后端一致，防止分片丢失。 ##"},{"id":"v-715f7b72#暂停、继续、取消与并发上传","path":"/project/fileUpload.html#暂停、继续、取消与并发上传","pageTitle":"前端大文件上传","headerTitle":"暂停、继续、取消与并发上传","text":"暂停、继续、取消与并发上传 - 目标 - 支持用户在上传过程中随时暂停、继续或取消，提升灵活性。 - 支持多个分片并发上传，提高带宽利用率和上传速度。 - 分片上传失败可自动重试，增强健壮性。 - 实现细节 - 每个分片上传都配备独立的 AbortController，便于单独中断。 - 暂停操作：调用 controller.abort() 终止所有正在上传的分片，暂停新分片上传。 - 继续操作：检测断点信息，恢复未完成分片上传。 - 取消操作：清理本地 localStorage 和后端临时分片，重置 UI 状态。 - 控制最大并发数（如 3），通过 activeCount 计数器控制上传队列。 - 分片失败自动重试最多 3 次，防止临时网络波动导致整体失败。 - 关键代码片段： ```typescript // 暂停 setPaused(true); pausedRef.current = true; Object.values(uploadTasksRef.current).forEach((controller) => controller.abort()); // 并发上传核心 while (activeCount < MAX_CONCURRENT && nextChunk < totalChunks) { const controller = new AbortController(); uploadTasksRef.current[chunkIndex] = controller; uploadChunkWithRetry(..., controller, ...) } ``` - 知识点与扩展 - AbortController 能精准控制 fetch 请求，适合中断分片上传。 - 并发上传要平衡速度与资源占用，避免过高并发带来带宽/服务器压力。 - 自动重试机制是应对分片级别短暂失败的最佳实践。 ##"},{"id":"v-715f7b72#断点恢复与刷新恢复","path":"/project/fileUpload.html#断点恢复与刷新恢复","pageTitle":"前端大文件上传","headerTitle":"断点恢复与刷新恢复","text":"断点恢复与刷新恢复 - 目标 - 页面刷新后能自动检测未完成的上传任务，并提示用户继续上传。 - 实现细节 - localStorage 记录每个上传任务的 fileId、fileName、fileSize、已上传分片索引等信息。 - 页面加载时检测 localStorage，若存在断点信息则展示断点恢复 UI，要求用户选择同名同大小文件继续上传。 - 恢复上传时校验文件名、大小是否一致，防止上传错误文件。 - 关键代码片段： ```typescript function detectPendingResume() { if (typeof window === \"undefined\") return null; // 遍历 localStorage 查找断点 for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && key.startsWith(\"upload_\")) { // ...判断有效断点 return {...} } } return null; } ``` ```tsx { pendingResume && !uploading && !paused && ( <div> <Progress percent={resumeProgress} /> <Button onClick={() => fileInputRef.current?.click()}> 请选择文件以继续上传 </Button> <Button onClick={handleAbandonResume}>放弃断点</Button> </div> ); } ``` - 知识点与扩展 - localStorage 断点检测需 SSR 兼容，避免 window 未定义报错。 - 文件名、大小的严格校验，防止断点恢复时上传非原文件。 - UI 友好提示，提升用户体验。 ##"},{"id":"v-715f7b72#代码结构优化与关注点分离","path":"/project/fileUpload.html#代码结构优化与关注点分离","pageTitle":"前端大文件上传","headerTitle":"代码结构优化与关注点分离","text":"代码结构优化与关注点分离 - 目标 - 提升代码可维护性和可扩展性，便于团队协作和后期优化。 - 实现细节 - 工具函数、分片上传核心、断点检测、UI 渲染等分区明确。 - 组件内部只关注 UI 和状态管理，逻辑和工具函数外置。 - 变量命名清晰，添加关键注释，降低后续维护成本。 - 关键结构示例： ```typescript // ========== 工具函数 ========== // getFileId, getUploadedChunks, mergeChunks ... // ========== 分片上传核心逻辑 ========== // concurrentUploadChunks, uploadChunkWithRetry ... // ========== 断点检测工具 ========== // detectPendingResume ... // ========== 组件 ========== export default function UpLoadFile() { ... } ``` - 知识点与扩展 - 关注点分离（Separation of Concerns）是可扩展项目的基础。 - 工具函数、核心逻辑与 UI 完全解耦，方便单元测试和多人协作。 ##"},{"id":"v-715f7b72#fetch-方案统一与体验细节","path":"/project/fileUpload.html#fetch-方案统一与体验细节","pageTitle":"前端大文件上传","headerTitle":"fetch 方案统一与体验细节","text":"fetch 方案统一与体验细节 - 目标 - 所有分片上传统一用 fetch，便于前端统一管理和后续扩展。 - 实现细节 - 使用 fetch+FormData 进行分片上传，统一所有上传请求格式。 - 进度条以“分片数量进度”模拟，兼容 fetch 的进度不可控问题。 - 保留自动重试、断点续传等所有功能。 - 关键代码片段： ```typescript const res = await fetch(\"/api/upload\", { method: \"POST\", body: formData, signal: controller.signal, }); ``` - 知识点与扩展 - fetch API 现代浏览器支持好，适合数据流式传输。 - 进度条用分片进度模拟，实际体验与 xhr 基于事件的进度类似。 - fetch 信号机制适合实现暂停/取消。 ##"},{"id":"v-715f7b72#常见问题与最终优化","path":"/project/fileUpload.html#常见问题与最终优化","pageTitle":"前端大文件上传","headerTitle":"常见问题与最终优化","text":"常见问题与最终优化 - localStorage is not defined - SSR 阶段 window 不存在，需用 typeof window !== 'undefined' 判断，避免首屏报错。 - 代码示例： ```typescript if (typeof window === \"undefined\") return null; ``` - Hydration failed - localStorage 检查逻辑放到 useEffect，pendingResume 初始为 null，解决 SSR/CSR 不一致导致的 React Hydration 报错。 - 断点假提示 - 上传成功后同步清理 localStorage 和 UI 状态，避免断点“假提示”误导用户。 - 其他体验细节 - 进度条下方增加暂停说明提示。 - 断点提示区域直观显示文件名、大小。 - 使用 messageApi 消息防堆叠，防止多次弹窗影响体验。 - 知识点与扩展 - SSR/CSR 兼容是 Next.js 项目常见难点，需特别注意状态的初始化时机。 - 状态与 UI 一致性管理，用户体验优化细节。 ##"},{"id":"v-715f7b72#最终版代码的核心知识点","path":"/project/fileUpload.html#最终版代码的核心知识点","pageTitle":"前端大文件上传","headerTitle":"最终版代码的核心知识点","text":"最终版代码的核心知识点 - 分片切割与唯一标识 - 利用 fileName+fileSize 生成唯一 fileId，保证断点和分片管理准确。 ```typescript function getFileId(file: File) { return `${file.name}-${file.size}`; } ``` - 分片并发上传与自动重试 - 见 concurrentUploadChunks、uploadChunkWithRetry，实现并发和失败重试。 - 断点检测与 localStorage 管理 - 见 detectPendingResume 和分片进度本地持久化。 - 状态流转：暂停/继续/取消/放弃断点 - handlePause、handleResume、handleCancel、handleAbandonResume 各自负责一类状态转换，避免混乱。 - 合并分片与后端协作 - 前端上传完毕后调用合并接口，后端合并分片生成最终文件。 ```typescript async function mergeChunks( fileId: string, fileName: string, totalChunks: number ) { await fetch(\"/api/upload/merge\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ fileId, fileName, totalChunks }), }); } ``` - SSR/CSR 兼容与 hydration 问题规避 - 所有 window/localStorage 操作均在 useEffect 和客户端执行，保证一致性。 - 关注点分离与代码结构优化 - 工具函数、分片上传核心、断点检测、UI 渲染完全独立，便于维护和扩展。 ##"},{"id":"v-715f7b72#完整代码示例","path":"/project/fileUpload.html#完整代码示例","pageTitle":"前端大文件上传","headerTitle":"完整代码示例","text":"完整代码示例 ```TSX //src\\app\\(upload)\\UpLoadFile \"use client\"; import { useState, useRef, useEffect } from \"react\"; import { Upload, Button, Progress, Modal } from \"antd\"; import { message } from \"antd\"; import { UploadOutlined, PauseOutlined, PlayCircleOutlined, } from \"@ant-design/icons\"; // ========== 常量 ========== const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB const MAX_CONCURRENT = 3; // ========== 工具函数 ========== function getFileId(file: File) { return `${file.name}-${file.size}`; } async function getUploadedChunks(fileId: string) { const res = await fetch(`/api/upload?fileId=${encodeURIComponent(fileId)}`); if (!res.ok) return []; const data = await res.json(); return data.uploadedChunks || []; } async function mergeChunks( fileId: string, fileName: string, totalChunks: number ) { const res = await fetch(\"/api/upload/merge\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ fileId, fileName, totalChunks }), }); if (!res.ok) throw new Error(\"合并失败\"); return await res.json(); } // ========== 分片上传核心逻辑 ========== async function concurrentUploadChunks( file: File, fileId: string, totalChunks: number, uploadedChunks: number[], onProgress: (percent: number) => void, pausedRef: { current: boolean }, canceledRef: { current: boolean }, uploadTasksRef: React.RefObject<{ [key: number]: AbortController }> ): Promise<void> { let nextChunk = 0; const finishedSet = new Set<number>(uploadedChunks); let progressArr = Array(totalChunks).fill(0); function saveProgress() { localStorage.setItem( `upload_${fileId}`, JSON.stringify({ fileName: file.name, fileSize: file.size, totalChunks, uploadedChunks: Array.from(finishedSet), }) ); } return new Promise<void>((resolve, reject) => { let activeCount = 0; let error: any = null; function uploadNext() { if (canceledRef.current || pausedRef.current || error) return; if (finishedSet.size === totalChunks) { saveProgress(); onProgress(100); resolve(); return; } while (activeCount < MAX_CONCURRENT && nextChunk < totalChunks) { if (finishedSet.has(nextChunk)) { progressArr[nextChunk] = 100; onProgress(Math.round((finishedSet.size / totalChunks) * 100)); nextChunk++; continue; } const chunkIndex = nextChunk++; activeCount++; const controller = new AbortController(); uploadTasksRef.current[chunkIndex] = controller; uploadChunkWithRetry( file, chunkIndex, fileId, totalChunks, controller, (percent: number) => { progressArr[chunkIndex] = percent; const totalPercent = Math.round( (finishedSet.size / totalChunks) * 100 ); onProgress(totalPercent); } ) .then(() => { delete uploadTasksRef.current[chunkIndex]; progressArr[chunkIndex] = 100; finishedSet.add(chunkIndex); saveProgress(); onProgress(Math.round((finishedSet.size / totalChunks) * 100)); activeCount--; uploadNext(); }) .catch(() => { delete uploadTasksRef.current[chunkIndex]; activeCount--; uploadNext(); }); } } uploadNext(); }); } function uploadChunkWithRetry( file: File, chunkIndex: number, fileId: string, totalChunks: number, controller: AbortController, onChunkProgress: (percent: number) => void, retry = 0 ): Promise<void> { return new Promise<void>(async (resolve, reject) => { const start = chunkIndex * CHUNK_SIZE; const end = Math.min(file.size, start + CHUNK_SIZE); const chunk = file.slice(start, end); const formData = new FormData(); formData.append(\"file\", chunk); formData.append(\"fileId\", fileId); formData.append(\"chunkIndex\", chunkIndex.toString()); formData.append(\"totalChunks\", totalChunks.toString()); formData.append(\"fileName\", file.name); try { const res = await fetch(\"/api/upload\", { method: \"POST\", body: formData, signal: controller.signal, }); if (res.ok) { onChunkProgress(100); resolve(); } else { if (retry < 3) { setTimeout(() => { uploadChunkWithRetry( file, chunkIndex, fileId, totalChunks, controller, onChunkProgress, retry + 1 ) .then(resolve) .catch(reject); }, 500); } else { reject(new Error(`分片${chunkIndex}上传失败`)); } } } catch (e: any) { if (controller.signal.aborted) { reject(new Error(\"abort\")); } else if (retry < 3) { setTimeout(() => { uploadChunkWithRetry( file, chunkIndex, fileId, totalChunks, controller, onChunkProgress, retry + 1 ) .then(resolve) .catch(reject); }, 500); } else { reject(new Error(`分片${chunkIndex}上传失败`)); } } }); } // ========== 断点检测工具 ========== function detectPendingResume() { if (typeof window === \"undefined\") return null; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && key.startsWith(\"upload_\")) { try { const info = JSON.parse(localStorage.getItem(key)!); if (info && info.fileName && info.totalChunks && info.fileSize) { return { fileId: key.replace(\"upload_\", \"\"), fileName: info.fileName, fileSize: info.fileSize, totalChunks: info.totalChunks, uploadedChunks: info.uploadedChunks || [], progress: Math.round( ((info.uploadedChunks?.length || 0) / info.totalChunks) * 100 ), }; } } catch {} } } return null; } // ========== 组件 ========== export default function UpLoadFile() { // UI状态 const [fileUrl, setFileUrl] = useState<string | null>(null); const [fileType, setFileType] = useState<string | null>(null); const [uploading, setUploading] = useState(false); const [progress, setProgress] = useState(0); const [paused, setPaused] = useState(false); const [currentFile, setCurrentFile] = useState<File | null>(null); const [messageApi, contextHolder] = message.useMessage(); // 断点相关 const [pendingResume, setPendingResume] = useState<ReturnType<typeof detectPendingResume>>(null); useEffect(() => { setPendingResume(detectPendingResume()); }, []); const fileInputRef = useRef<HTMLInputElement | null>(null); // 上传上下文 const uploadContext = useRef<{ file: File; fileId: string; totalChunks: number; nextChunk: number; } | null>(null); // 分片上传相关ref const uploadTasksRef = useRef<{ [key: number]: AbortController }>({}); const pausedRef = useRef(false); const canceledRef = useRef(false); // 断点恢复时的进度 const resumeProgress = pendingResume?.progress || 0; // 断点文件选择 const handleResumeFileSelect = async ( e: React.ChangeEvent<HTMLInputElement> ) => { const file = e.target.files?.[0]; if (file && pendingResume) { if ( file.name === pendingResume.fileName && file.size === pendingResume.fileSize ) { await beforeUpload(file); setPendingResume(null); } else { messageApi.open({ type: \"error\", content: \"请选择与上次未完成上传相同的文件\", }); } } }; // 暂停/继续控制 const handlePause = () => { setPaused(true); pausedRef.current = true; Object.values(uploadTasksRef.current).forEach((controller) => controller.abort() ); }; const handleResume = async () => { setPaused(false); pausedRef.current = false; if (currentFile && uploadContext.current) { await continueUpload(); } }; // 取消上传 const handleCancel = async () => { canceledRef.current = true; setPaused(false); pausedRef.current = false; setUploading(false); setProgress(0); setCurrentFile(null); if (uploadContext.current) { const { fileId } = uploadContext.current; await fetch(`/api/upload?fileId=${encodeURIComponent(fileId)}`, { method: \"DELETE\", }); localStorage.removeItem(`upload_${fileId}`); } messageApi.open({ type: \"success\", content: \"取消上传成功\", }); }; // 分片上传主逻辑 const beforeUpload = async (file: File) => { setUploading(true); setProgress(0); setFileUrl(null); setFileType(null); setPaused(false); pausedRef.current = false; canceledRef.current = false; setCurrentFile(file); const fileId = getFileId(file); const totalChunks = Math.ceil(file.size / CHUNK_SIZE); uploadContext.current = { file, fileId, totalChunks, nextChunk: 0 }; // 读取localStorage断点 let uploadedChunks = []; const saved = localStorage.getItem(`upload_${fileId}`); if (saved) { try { const parsed = JSON.parse(saved); if ( parsed.fileName === file.name && parsed.fileSize === file.size && parsed.totalChunks === totalChunks ) { uploadedChunks = parsed.uploadedChunks || []; } } catch {} } else { uploadedChunks = await getUploadedChunks(fileId); } try { await concurrentUploadChunks( file, fileId, totalChunks, uploadedChunks, setProgress, pausedRef, canceledRef, uploadTasksRef ); // 合并 const res = await mergeChunks(fileId, file.name, totalChunks); setFileUrl(res.url); setFileType(file.type); setCurrentFile(null); localStorage.removeItem(`upload_${fileId}`); setPendingResume(null); } catch (e) { if (!canceledRef.current) { await fetch(`/api/upload?fileId=${encodeURIComponent(fileId)}`, { method: \"DELETE\", }); messageApi.open({ type: \"error\", content: \"上传失败\", }); localStorage.removeItem(`upload_${fileId}`); } } finally { if (!pausedRef.current && !canceledRef.current) { setUploading(false); } } return false; }; // 继续上传 const continueUpload = async () => { if (!uploadContext.current) return; setUploading(true); setPaused(false); pausedRef.current = false; canceledRef.current = false; const { file, fileId, totalChunks, nextChunk } = uploadContext.current; let uploadedChunks = []; const saved = localStorage.getItem(`upload_${fileId}`); if (saved) { try { const parsed = JSON.parse(saved); if ( parsed.fileName === file.name && parsed.fileSize === file.size && parsed.totalChunks === totalChunks ) { uploadedChunks = parsed.uploadedChunks || []; } } catch {} } else { uploadedChunks = await getUploadedChunks(fileId); } try { await concurrentUploadChunks( file, fileId, totalChunks, uploadedChunks, setProgress, pausedRef, canceledRef, uploadTasksRef ); // 合并 const res = await mergeChunks(fileId, file.name, totalChunks); setFileUrl(res.url); setFileType(file.type); setCurrentFile(null); localStorage.removeItem(`upload_${fileId}`); setPendingResume(null); } catch (e) { await fetch(`/api/upload?fileId=${encodeURIComponent(fileId)}`, { method: \"DELETE\", }); messageApi.open({ type: \"error\", content: \"上传失败\", }); localStorage.removeItem(`upload_${fileId}`); } finally { if (!pausedRef.current && !canceledRef.current) { setUploading(false); } } }; // 放弃断点 const handleAbandonResume = async () => { if (pendingResume) { await fetch( `/api/upload?fileId=${encodeURIComponent(pendingResume.fileId)}`, { method: \"DELETE\", } ); localStorage.removeItem(`upload_${pendingResume.fileId}`); setPendingResume(null); } }; // ========== UI渲染 ========== return ( <div> {contextHolder} <input type=\"file\" ref={fileInputRef} style={{ display: \"none\" }} onChange={handleResumeFileSelect} /> {pendingResume && !uploading && !paused && ( <div style={{ marginBottom: 20 }}> <Progress percent={resumeProgress} /> <Button type=\"primary\" onClick={() => fileInputRef.current?.click()} style={{ marginLeft: 8 }} > 请选择文件以继续上传 </Button> <Button danger onClick={handleAbandonResume} style={{ marginLeft: 8 }} > 放弃断点 </Button> </div> )} <Upload showUploadList={false} beforeUpload={beforeUpload} maxCount={1} disabled={uploading && !paused} > <Button icon={<UploadOutlined />} disabled={uploading && !paused}> 上传文件 </Button> </Upload> <div style={{ marginTop: 20 }}> {(uploading || paused) && ( <> <Progress percent={progress} /> {!paused ? ( <Button icon={<PauseOutlined />} onClick={handlePause} style={{ marginLeft: 8 }} > 暂停 </Button> ) : ( <Button icon={<PlayCircleOutlined />} onClick={handleResume} style={{ marginLeft: 8 }} > 继续 </Button> )} <Button danger onClick={handleCancel} style={{ marginLeft: 8 }}> 取消上传 </Button> <div style={{ color: \"#888\", fontSize: 12, marginTop: 4 }}> 暂停将在当前分片上传完成后生效 </div> </> )} {!uploading && !paused && fileUrl && fileType?.startsWith(\"audio/\") && ( <audio src={fileUrl} controls style={{ width: 300 }} /> )} {!uploading && !paused && fileUrl && fileType?.startsWith(\"video/\") && ( <video src={fileUrl} controls style={{ width: 300 }} /> )} </div> </div> ); } ``` ```TS // src\\app\\api\\upload\\route.ts import { NextRequest, NextResponse } from \"next/server\"; import { promises as fs } from \"fs\"; import path from \"path\"; // 分片临时存储目录 const UPLOAD_DIR = path.join(process.cwd(), \"public\", \"uploads\", \"chunks\"); // 工具：确保目录存在 async function ensureDir(dir: string) { await fs.mkdir(dir, { recursive: true }); } // 工具：获取分片文件路径 function getChunkPath(fileId: string, chunkIndex: string) { return path.join(UPLOAD_DIR, fileId, chunkIndex); } // 工具：获取分片目录 function getChunkDir(fileId: string) { return path.join(UPLOAD_DIR, fileId); } // 工具：获取最终文件路径 function getFinalFilePath(fileName: string) { return path.join(process.cwd(), \"public\", \"uploads\", fileName); } // GET: 查询已上传分片 export async function GET(req: NextRequest) { const { searchParams } = new URL(req.url); const fileId = searchParams.get(\"fileId\"); if (!fileId) { return NextResponse.json({ uploadedChunks: [] }); } const chunkDir = getChunkDir(fileId); try { const files = await fs.readdir(chunkDir); // 返回已上传分片的索引数组 const uploadedChunks = files.map((name) => Number(name)).filter((n) => !isNaN(n)); return NextResponse.json({ uploadedChunks }); } catch { return NextResponse.json({ uploadedChunks: [] }); } } // POST: 接收单个分片 export async function POST(req: NextRequest) { const formData = await req.formData(); const file = formData.get(\"file\") as File; const fileId = formData.get(\"fileId\") as string; const chunkIndex = formData.get(\"chunkIndex\") as string; // 兼容普通上传 const fileName = formData.get(\"fileName\") as string; if (!file || !fileId || !chunkIndex) { // 普通上传 if (file && fileName) { const bytes = await file.arrayBuffer(); const buffer = Buffer.from(bytes); const uploadDir = path.join(process.cwd(), \"public\", \"uploads\"); await ensureDir(uploadDir); const filePath = path.join(uploadDir, fileName); await fs.writeFile(filePath, buffer); const fileUrl = `/uploads/${fileName}`; return NextResponse.json({ url: fileUrl }); } return NextResponse.json({ error: \"参数不全\" }, { status: 400 }); } // 分片上传 const chunkDir = getChunkDir(fileId); await ensureDir(chunkDir); const chunkPath = getChunkPath(fileId, chunkIndex); const bytes = await file.arrayBuffer(); const buffer = Buffer.from(bytes); await fs.writeFile(chunkPath, buffer); return NextResponse.json({ success: true }); } // DELETE: 删除分片目录 export async function DELETE(req: NextRequest) { const { searchParams } = new URL(req.url); const fileId = searchParams.get(\"fileId\"); if (!fileId) { return NextResponse.json({ error: \"缺少fileId\" }, { status: 400 }); } const chunkDir = getChunkDir(fileId); try { await fs.rm(chunkDir, { recursive: true, force: true }); return NextResponse.json({ success: true }); } catch { return NextResponse.json({ error: \"删除失败\" }, { status: 500 }); } } ``` ```TS // src\\app\\api\\upload\\merge\\route.ts import { NextRequest, NextResponse } from \"next/server\"; import { promises as fs } from \"fs\"; import path from \"path\"; const UPLOAD_DIR = path.join(process.cwd(), \"public\", \"uploads\", \"chunks\"); function getChunkDir(fileId: string) { return path.join(UPLOAD_DIR, fileId); } function getFinalFilePath(fileName: string) { return path.join(process.cwd(), \"public\", \"uploads\", fileName); } export async function POST(req: NextRequest) { const { fileId, fileName, totalChunks } = await req.json(); if (!fileId || !fileName || !totalChunks) { return NextResponse.json({ error: \"参数不全\" }, { status: 400 }); } const chunkDir = getChunkDir(fileId); const finalPath = getFinalFilePath(fileName); try { // 合并所有分片 const writeStream = await fs.open(finalPath, \"w\"); for (let i = 0; i < totalChunks; i++) { const chunkPath = path.join(chunkDir, String(i)); const data = await fs.readFile(chunkPath); await writeStream.write(data); } await writeStream.close(); // 删除分片目录 await fs.rm(chunkDir, { recursive: true, force: true }); const fileUrl = `/uploads/${fileName}`; return NextResponse.json({ url: fileUrl }); } catch (e) { return NextResponse.json({ error: \"合并失败\" }, { status: 500 }); } } ```"},{"id":"v-10819306","path":"/project/flutter-config.html","pageTitle":"flutter环境配置与踩坑总结","headerTitle":null,"text":"# flutter环境配置与踩坑总结 ##"},{"id":"v-10819306#第一阶段-安装与环境配置","path":"/project/flutter-config.html#第一阶段-安装与环境配置","pageTitle":"flutter环境配置与踩坑总结","headerTitle":"第一阶段：安装与环境配置","text":"第一阶段：安装与环境配置 这个阶段的目标是让您的电脑认识 Flutter 和 Android 的所有命令行工具。 1. **您需要做什么：** 准备 Flutter 和 Android 的开发环境。 - **遇到的第一个错误：** `avdmanager is missing` (缺少安卓虚拟设备管理器)。 - **原因：** 您的 Android SDK 安装不完整，缺少了核心的“命令行工具”组件。 - **解决方案：** 在 Android Studio 的 **SDK Manager -> SDK Tools** 选项卡中，勾选并安装 **Android SDK Command-line Tools**。 - **遇到的第二个错误：** `Unable to find suitable Visual Studio toolchain` (找不到 VS 工具)。 - **原因：** 您尝试在 Windows 平台运行 App，但这需要 C++ 的编译环境，而您没有安装对应的 Visual Studio 组件。 - **解决方案：** 运行 **Visual Studio Installer**，选择“修改”，然后勾选并安装 **“使用 C++ 的桌面开发”** 工作负载。 - **遇到的第三个错误：** `flutter doctor` 提示 `Some Android licenses not accepted` (安卓许可证未接受)。 - **原因：** 您还没有同意 Android SDK 的用户协议。 - **解决方案：** 在终端中运行 `flutter doctor --android-licenses` 命令，然后一路输入 `y` 同意所有协议。 ##"},{"id":"v-10819306#第二阶段-创建项目与首次编译","path":"/project/flutter-config.html#第二阶段-创建项目与首次编译","pageTitle":"flutter环境配置与踩坑总结","headerTitle":"第二阶段：创建项目与首次编译","text":"第二阶段：创建项目与首次编译 这是最容易出错的阶段，核心问题都围绕着 **Gradle 构建系统** 和 **网络环境**。 1. **您需要做什么：** 创建一个新 Flutter 项目并尝试在模拟器上运行它。 - **遇到的第一个错误：** 编译时卡住不动，最后报出 `java.net.SocketException` (网络连接超时)。 - **原因：** 项目的构建工具 Gradle 需要从国外的官方服务器下载依赖，但您的网络环境访问这些服务器非常缓慢或不稳定。 - **解决方案：** **配置国内镜像源**。我们修改了项目中的 `android/build.gradle.kts` 和 `android/settings.gradle.kts` 文件，将下载地址从 `google()` 和 `mavenCentral()` 替换为了速度更快的阿里云镜像。 - **遇到的第二个错误：** 修改镜像后，报出 `Unexpected tokens` 或 `Plugin ... not found` 等语法和插件版本错误。 - **原因：** 1. 最初的镜像配置语法不兼容您项目的 Kotlin 脚本 (`.kts`) 文件。 2. 在修改过程中，可能不小心将安卓插件版本号改为了一个不存在的 `8.9.1`。 - **解决方案：** 1. 为您提供了适用于 `.kts` 文件的正确语法 (`url = uri(\"...\")`)。 2. 最终我们通过**创建一个全新的干净项目**来查找官方推荐的正确版本号，再把它复制回您的项目中，从而解决了版本错误问题。 - **遇到的第三个错误：** `Your project path contains non-ASCII characters` (项目路径含中文字符)。 - **原因：** 您的项目存放在了 `D:\\web前端\\` 目录下，Windows 上的安卓构建工具无法处理路径中的中文。 - **解决方案：** 将项目移动到一个**纯英文**的路径下（例如 `D:\\web_frontend\\`），彻底解决了这个问题。 ##"},{"id":"v-10819306#第三阶段-编码与调试","path":"/project/flutter-config.html#第三阶段-编码与调试","pageTitle":"flutter环境配置与踩坑总结","headerTitle":"第三阶段：编码与调试","text":"第三阶段：编码与调试 成功运行 App 后，您开始尝试修改代码并理解其工作原理。 1. **您需要做什么：** 学习基础语法，修改 App 内容并查看效果。 - **遇到的第一个困惑：** 修改了 `MaterialApp` 中的 `title`，但模拟器顶部的标题栏文字没有变。 - **原因：** 您修改的是 App 的“内部名称”（用于任务切换器等），而不是页面上实际显示的标题。 - **解决方案：** 为您指出了真正控制页面标题的代码位置，即传递给 `MyHomePage` 组件的 `title` 参数：`home: const MyHomePage(title: '我的第一个App')`。 - **遇到的第二个困惑：** 拆分组件到新文件后，出现了满屏的红线报错。 - **原因：** 您对 `StatefulWidget` 的标准写法不熟悉，两个类重名且 `createState` 方法实现错误。 - **解决方案：** 为您提供了 `StatefulWidget` 的标准模板，解释了 Widget 类和 State 类必须分开且命名规范，`createState` 必须准确返回 State 类的实例。 - **遇到的一个持续性干扰：** VS Code 不断弹出 `shellsheck not installed properly` 的错误。 - **原因：** 这个问题**与 Flutter 无关**。是您的 VS Code 中安装了一个名为 “ShellCheck” 的插件（可能是被其他插件包附带安装的），但它依赖的核心程序没有安装。 - **解决方案：** 既然您不编写 Shell 脚本，最佳方法是在 VS Code 的**“扩展”**面板中搜索并**卸载**这个插件，一了百了。 ##"},{"id":"v-10819306#第四阶段-环境优化","path":"/project/flutter-config.html#第四阶段-环境优化","pageTitle":"flutter环境配置与踩坑总结","headerTitle":"第四阶段：环境优化","text":"第四阶段：环境优化 为了更好的开发体验和节省 C 盘空间，您希望自定义工具的存储位置。 1. **您需要做什么：** 将 **Android SDK** 和**安卓模拟器 (AVD)** 的存储位置从 C 盘移到 D 盘。 - **原因：** C 盘空间紧张，且将开发工具统一存放更利于管理。 - **解决方案：** 1. **对于 Android SDK：** 在 Android Studio 设置中重新指定 D 盘路径让其重新下载，然后更新系统的 `ANDROID_HOME` 环境变量。 2. **对于安卓模拟器 (AVD)：** 新建一个 `ANDROID_AVD_HOME` 环境变量指向 D 盘的新文件夹，然后将 `C:\\Users\\用户名\\.android\\avd` 目录下的旧文件移动过去。"},{"id":"v-27f2cc28","path":"/project/flutter.html","pageTitle":"Flutter 综合学习笔记","headerTitle":null,"text":"# Flutter 综合学习笔记 这是一份根据前三天学习和实践整理的综合笔记，旨在帮助理解 Flutter 的核心概念，从基础入门到状态管理。 ##"},{"id":"v-27f2cc28#_1-flutter-核心基础","path":"/project/flutter.html#_1-flutter-核心基础","pageTitle":"Flutter 综合学习笔记","headerTitle":"1. Flutter 核心基础","text":"1. Flutter 核心基础 ### Flutter 的项目入口：`lib/main.dart` 每个 Flutter 应用程序的执行都始于 `lib/main.dart` 文件，该文件是程序的指定入口点。 * **lib 目录**: 此目录是项目的核心，作为几乎所有 Dart 源代码的主要存储库。 * **main.dart 文件**: 这是应用的**主入口文件**。操作系统（无论是安卓、iOS还是Web）启动您的应用时，第一个执行的就是这个文件里的 `main()` 函数。 * **main() 函数**: 这是程序的起点。在这个函数里，我们通常会调用 `runApp()` 函数。 **代码示例 (lib/main.dart):** ```dart import 'package:flutter/material.dart'; // ... 其他导入 // 程序的入口函数 void main() { // runApp() 告诉 Flutter 运行哪个组件作为应用的根 runApp(const MyApp()); } // MyApp 就是应用的根组件 class MyApp extends StatelessWidget { // ... } ``` ### 核心理念：一切皆组件 (Everything is a Widget) 这是您需要记住的最重要的一句话。在 Flutter 中，您看到的**任何东西**都是一个“组件”（Widget），或者由更小的组件组合而成。 * 一个按钮？是 `ElevatedButton` 组件。 * 一行文字？是 `Text` 组件。 * 甚至连页面的整体布局（比如居中 `Center`、按行排列 `Row`、按列排列 `Column`），以及看不见的内边距 `Padding`，都是组件。 * `Scaffold` 是一个搭建页面的**脚手架组件**。 ### `@override` 到底是什么意思？ `@override` 是一个“注解”，意思是：“我正在**重写**父类中的同名方法”。 * **背景**: 您的 `_HomePageState` 继承了 `State<HomePage>`。`State` 类本身已经定义了一个叫做 `build` 的方法。 * **作用**: 您的 `_HomePageState` 必须提供一个具体的 `build` 方法来描述页面内容。`@override` 就在这里起作用，它告诉编译器和阅读代码的人：“我这里的 `build` 方法是在重写父类 `State` 的 `build` 方法，不是我自己随便创建的新方法。” * **好处**: 1. 代码更清晰。2. 安全检查（拼写错误会报错）。 **代码示例 (lib/pages/home_page.dart):** ```dart class _HomePageState extends State<HomePage> { // @override 表示这个 build 方法是重写父类 State 的方法 @override Widget build(BuildContext context) { // ... 返回您的组件树 } } ``` ### Dart 命名规范与 `_` (下划线) * **类名**: 使用 `UpperCamelCase` (大驼峰命名法)，例如 `HomePage`, `MyApp`。 * **文件名、变量名、函数名**: 使用 `lowerCamelCase` (小驼峰命名法)。 * **_ (下划线) 表示私有**: 在 Dart 中，如果一个变量、函数或类的名字以下划线 `_` 开头，那么它就是**私有的**。 * **“私有”的范围**: 不是指这个类内部，而是指**当前文件 (.dart 文件) 内部**。`_HomePageState` 这个类只能在 `home_page.dart` 这个文件里被访问，其他文件无法 `import` 和使用它。 ### `final` 的意思 `final` 是一个关键字，用来声明一个**只能被赋值一次**的变量。一旦被赋值，它的值（或引用）就不能再改变了。 * **为什么组件的属性常用 final?** 在 Flutter 中，组件被设计为“不可变的”（immutable）。如果需要更新界面，Flutter 的做法是创建一个新的组件实例来替换旧的，而不是去修改旧组件的属性。使用 `final` 可以强制保证这一点，让代码更安全。 **代码示例 (lib/pages/web_view_page.dart):** ```dart class WebViewPage extends StatefulWidget { // title 被声明为 final，意味着一旦 WebViewPage 被创建， // 它的 title 就不能再被修改了。 final String title; const WebViewPage({super.key, required this.title}); // ... } ``` ## 2. 布局与样式 (Styling) ### `SafeArea`：不被状态栏遮挡的安全区域 `SafeArea` 是一个非常有用的布局组件。它的作用是创建一个“安全”的矩形区域，这个区域会自动避开手机屏幕顶部的刘海、状态栏，以及底部的导航条。 **代码示例 (home_page.dart):** ```dart Scaffold( // 将 body 包裹在 SafeArea 中 body: SafeArea( child: Column(...) // Column 里的所有内容都不会被遮挡了 ), ); ``` ### 添加样式 (Styling) 在 Flutter 中，给组件添加样式通常是通过组件自身的属性来实现的。 * **Text 组件**: 使用 `style` 属性，它接收一个 `TextStyle` 对象。 * **Container 组件**: 使用 `decoration` 属性，它接收一个 `BoxDecoration` 对象，可以设置边框、圆角、背景色等。 ### 尺寸单位全解析 #### Flutter 默认单位：逻辑像素 (Logical Pixels) * **写法**: 直接写数字，如 `width: 150`, `fontSize: 14`。 * **含义**: 这是一个**固定的、绝对的**单位。在不同尺寸屏幕上视觉比例会失调。 #### `flutter_screenutil` 适配单位 这是用来实现UI适配的利器，它们都是**相对单位**。 * **.w (width)**: 基于**屏幕宽度**进行缩放。适合设置**水平方向**的尺寸。 * **.h (height)**: 基于**屏幕高度**进行缩放。适合设置**垂直方向**的尺寸。 * **.r (radius/responsive)**: 基于屏幕**宽高的较小值**进行缩放。非常适合设置**圆角半径**或**正方形元素**。 * **.sp (scalable pixel)**: 专门用于**字体大小**的适配。它不仅会根据屏幕尺寸缩放，还会**参考用户在系统设置里调整的字体大小**。 ## 3. 路由与导航 (Navigation) “路由”就是页面的代称。Flutter 使用一个 `Navigator` (导航器) 组件来管理一个页面栈（先进后出）。 ### 基本路由跳转 * **跳转到新页面 (push)**: `Navigator.push()` 会将一个新的页面（路由）压入栈顶。 * **返回上一页 (pop)**: `Navigator.pop()` 会将栈顶的页面弹出。 ### 路由封装（进阶） 为了让项目结构更清晰，我们将路由跳转进行封装。 1. **lib/route/routes.dart**: 这个文件负责**定义**和**生成**路由。 * `RoutePaths` 类：用 `static const` 字符串常量来定义所有页面的路由名称（如 `'/web_view_page'`），避免使用魔法字符串。 * `Routes` 类：`generateRoute` 静态方法像一个“交通枢纽”，通过 `switch` 语句判断路由名称，并返回对应的页面。 2. **lib/route/RouteUtils.dart**: 这个文件封装了具体的**跳转动作**。 * 创建 `push` 和 `pushForNamed` 等静态方法，将 `Navigator.of(context).push(...)` 封装起来。 * **好处**：页面逻辑更简洁，调用 `RouteUtils.pushForNamed(context, ...)` 即可。 ### 页面传值的两种核心方式 #### 方式一：构造函数传值（类型安全，推荐） 这是最直观、最安全的方式。 * **传递**: 创建新页面组件实例时，通过**构造函数**来完成。 ```dart // 在 RouteUtils.push 中 Navigator.push(context, MaterialPageRoute(builder: (context){ // 直接把 \"webView\" 字符串传给 title 参数 return WebViewPage(title: \"webView\"); })); ``` * **接收**: 在目标页面 (`WebViewPage`) 的 `StatefulWidget` 部分用 `final` 变量声明，并在 `State` 部分通过 `widget.变量名` 访问。 ```dart class WebViewPage extends StatefulWidget { final String title; // 1. 声明要接收的参数 const WebViewPage({super.key, required this.title}); // 2. 在构造函数中接收 } class _WebViewPageState extends State<WebViewPage> { Widget build(BuildContext context) { // 3. 通过 widget.title 使用参数 return AppBar(title: Text(widget.title)); } } ``` #### 方式二：`arguments` 传值（灵活，用于命名路由） 这种方式在与**命名路由** (`pushNamed`) 结合时非常灵活。 * **传递**: 在跳转时，通过 `arguments` 参数传递一个对象，通常是 `Map`。 ```dart // 在 HomePage 中 RouteUtils.pushForNamed( context, RoutePaths.webViewPage, arguments: {\"title\": \"webView\"} // 将 Map 作为 arguments 传递 ); ``` * **接收**: 在目标页面的 `State` 内部，通过 `ModalRoute.of(context)!.settings.arguments` 来获取。这个过程必须在 `build` 方法或者 `initState` 中（通常配合 `addPostFrameCallback`）完成。 ```dart class _WebViewPageState extends State<WebViewPage> { String name = \"\"; @override void initState() { super.initState(); // 确保在第一帧渲染后执行，此时 context 才可用 WidgetsBinding.instance.addPostFrameCallback((_) { if (mounted) { var args = ModalRoute.of(context)!.settings.arguments; if (args is Map) { setState(() { // 获取到值后，调用 setState 更新界面 name = args[\"title\"] ?? \"默认标题\"; }); } } }); } // ... build 方法中使用 name ... } ``` ## 4. 状态管理 (State Management) ### Level 1: 本地状态 (Local State) 与 `setState` `StatefulWidget`（有状态组件）拥有一个 `State` 对象，可以保存和改变数据，并在数据改变时**刷新界面**。 * **State 对象**: 专门用来存储组件内部的可变数据。 * **setState((){ ... })**: 这是刷新UI的**唯一指令**。 * **原理**: 调用 `setState` 会通知 Flutter 框架：“这个组件的数据变了，请重新调用它的 `build` 方法来重绘界面！”。 * **注意**: 如果只修改变量而不调用 `setState`，数据虽然变了，但UI不会刷新。 ### Level 2: 应用/全局状态 (App State) 与 `Provider` 当多个页面需要共享同一个状态（如用户登录信息、主题色），或者需要将状态传递给很深的子组件时，使用 `setState` 会变得非常繁琐（即“状态提升”和“Prop-drilling”）。 `Provider` 是 Google 官方推荐的、简单轻量的状态管理方案。 #### 核心概念 1: `ChangeNotifier` (ViewModel / 状态) `ChangeNotifier` 是一个 Flutter SDK 内置的类。我们创建的 `ViewModel` (VM) 通常会继承它。 * **职责**: 1. **持有数据**: 比如 `List<Banner> bannerList`。 2. **封装业务逻辑**: 比如 `getBanner()` 方法。 3. **通知更新**: 当数据发生变化时（例如网络请求成功后），调用 `notifyListeners()` 方法，向所有监听者（Consumer）发送“数据变了”的信号。 ```dart // 示例：home_vm.dart class HomeViewModel extends ChangeNotifier { List<Banner> bannerList = []; // 1. 持有数据 // 2. 封装业务逻辑 Future<void> fetchBanners() async { var data = await ApiService.getBanner(); // 假设 ApiService 负责请求 bannerList = ...; // 把 data 转换成 bannerList // 3. 通知更新 notifyListeners(); } } ``` #### 核心概念 2: `ChangeNotifierProvider` (供应器) `ChangeNotifierProvider` 是 `provider` 包提供的组件。 * **职责**: 向其子组件树**提供**一个 `ChangeNotifier` (即 VM) 的实例。 * **位置**: 通常放在需要共享该状态的**组件树的顶层**，或者直接放在 `main.dart` 的 `runApp` 中，使其成为全局可访问。 ```dart // 示例：main.dart void main() { runApp( // 1. 创建并提供了 HomeViewModel 的实例 ChangeNotifierProvider( create: (context) => HomeViewModel(), child: const MyApp(), // 2. MyApp 及其所有子组件都能访问到 HomeViewModel ), ); } ``` #### 核心概念 3: `Consumer` / `context.watch` (监听器) `Consumer` (或 `context.watch`) 负责从 `Provider` 获取 `ViewModel` 并**监听**其变化。 * **`Consumer` (组件方式)**: * 是一个 Widget，它会**只重建**其 `builder` 内部的组件，性能较好。 * `builder` 提供三个参数：`context`、`viewModel` (我们需要的VM实例) 和 `child`。 * **`context.watch<T>()` (Hook 方式 - 更常用)**: * 在 `build` 方法内部调用。 * 它会告诉 Flutter：“我依赖 `HomeViewModel`，当它调用 `notifyListeners()` 时，请**重建整个**调用了 `watch` 的 `build` 方法”。 **代码实践 (解答：“为啥vm就能拿到bannerlist的值”)** **连接流程如下：** 1. `HomeViewModel` (`VM`) 自己负责调用 API 并获取数据，然后将数据存入 `VM.bannerList` 变量中。 2. 获取数据后，`VM` 调用 `notifyListeners()`。 3. `ChangeNotifierProvider` 在 `main.dart` 中创建了这个 `VM` 实例。 4. `Consumer` (或 `context.watch`) 在 `HomePage` 中监听这个 `VM`。 5. 当 `Consumer` 收到 `notifyListeners()` 信号时，它会**自动重建**，并访问 `VM` 实例上**已经更新好**的 `bannerList` 数据，从而刷新UI。 ```dart // 示例：home_page.dart class _HomePageState extends State<HomePage> { @override void initState() { super.initState(); // 第一次加载时，获取 VM 实例并调用其方法 // 使用 context.read 不会监听变化，适合在 initState 或 onTap 中调用方法 context.read<HomeViewModel>().fetchBanners(); } @override Widget build(BuildContext context) { // 1. 使用 watch 来监听 HomeViewModel 的变化 final vm = context.watch<HomeViewModel>(); return Scaffold( body: ListView.builder( // 2. vm 上的 bannerList 已经是最新的了 itemCount: vm.bannerList.length, itemBuilder: (context, index) { // 3. 使用数据渲染UI return Text(vm.bannerList[index].title); }, ), ); } } ``` * **`context.read<T>()`**: 仅**读取**一次 `VM` 实例，**不**监听后续变化。适合在 `initState` 或 `onPressed` 中调用 `VM` 的方法。 * **`context.watch<T>()() `**: **读取**并**持续监听** `VM` 的变化。适合在 `build` 方法中获取数据以渲染UI。 ## 5. 异步编程 (Async) 网络请求等耗时操作不能阻塞UI线程。Dart 使用 `Future` 来处理这类**异步操作**。 ### `Future`、`async` 和 `await` * **Future**: 一个“未来的凭证”或“快递单”。调用异步函数时，它不会立即给你结果，而是先给你一个 `Future`。 * **async**: 用来标记一个函数是**异步函数**，这个函数会自动返回一个 `Future`。 * **await**: 只能用在 `async` 函数内部，意思是“**在这里暂停，一直等到这个 `Future` 有结果了，再继续往下执行**”。 **代码实践 (home_vm.dart):** ```dart // 'async' 标记这是一个异步函数 static Future getBanner() async { Dio dio = Dio(); // ... // 'await' 在这里暂停，直到 dio.get() 这个 Future 完成 Response response = await dio.get(\"/banner/json\"); // Future 完成后，才会执行下面的 print 和 return print(\"response===>${response.data}\"); return response.data; } ``` ## 6. Dart 进阶与包管理 ### `static` 静态成员详解 `static` 关键字修饰的成员（变量或方法）**属于类本身，而不是类的某个具体实例（对象）**。 * **非静态成员 (实例成员)**: 像“房子的家具”，必须先创建实例（盖房子）才能访问。 * **静态成员 (static)**: 像“建筑图纸上的规范”，不需要创建实例，直接通过**类名**访问。 * **用法**: `RoutePaths.home`, `HomeViewModel.getBanner()`。 ### `var` (类型推断) vs. `Dio` (显式类型) * **var**: `var dio = Dio();`。Dart 编译器自动推断 `dio` 的类型是 `Dio`。 * **Dio**: `Dio dio = Dio();`。明确地告诉编译器 `dio` 变量的类型**必须是** `Dio`。 * **推荐**: 在团队协作中，显式类型 (`Dio dio`) 可读性更强、意图更明确。 ### 包管理 (`pub.dev`) * **pub.dev**: Dart 和 Flutter 官方的包（Package）仓库，类似组件的应用商店。 * **pubspec.yaml**: 项目的“依赖清单”。 * **flutter pub get**: 1. 读取 `pubspec.yaml`。 2. 去 `pub.dev` 下载包的源代码（.dart 文件）。 3. 存储在本地缓存中。 4. 在 `.dart_tool/package_config.json` 中创建映射（地址簿），告诉 `import` 语句去哪里找文件。"},{"id":"v-bf406928","path":"/project/macOS_Guide.html","pageTitle":"Mac 操作指南","headerTitle":null,"text":"# Mac 操作指南 目前设置了外接键盘 ctrl 和 command 键位，以模拟 windows ##"},{"id":"v-bf406928#截图","path":"/project/macOS_Guide.html#截图","pageTitle":"Mac 操作指南","headerTitle":"截图","text":"截图 全屏截图：shift+command+3 框选截图：shift+command+4 窗口截图：shift+command+4+空格 调出截图总菜单：shift+command+4 ##"},{"id":"v-bf406928#辅助软件","path":"/project/macOS_Guide.html#辅助软件","pageTitle":"Mac 操作指南","headerTitle":"辅助软件","text":"辅助软件 ###"},{"id":"v-bf406928#homebrew","path":"/project/macOS_Guide.html#homebrew","pageTitle":"Mac 操作指南","headerTitle":"Homebrew","text":"Homebrew mac 好用的包管理工具 #### Homebrew 常用命令及终端快捷操作指南 ##### 1. 搜索软件包 (Formulas 和 Casks) - 搜索所有类型 (命令行工具和图形应用): ```bash brew search <关键词> # 或者简写 brew s <关键词> ``` _示例:_ `brew search python` - 仅搜索图形界面应用程序 (Casks): ```bash brew search --casks <关键词> ``` _示例:_ `brew search --casks visual-studio-code` ##### 2. 安装软件包 - 安装命令行工具和库 (Formulas): ```bash brew install <软件包名称> ``` _示例:_ `brew install git` - 安装图形界面应用程序 (Casks): ```bash brew install --cask <应用程序名称> ``` _示例:_ `brew install --cask firefox` ##### 3. 卸载软件包 - 卸载命令行工具和库: ```bash brew uninstall <软件包名称> ``` _示例:_ `brew uninstall git` - 卸载图形界面应用程序: ```bash brew uninstall --cask <应用程序名称> ``` _示例:_ `brew uninstall --cask firefox` ##### 4. 更新与升级 - 更新 Homebrew 自身及软件包列表 (获取最新版本信息): ```bash brew update ``` _(注意：此命令不升级已安装的包)_ - 升级所有已安装的软件包: ```bash brew upgrade ``` - 升级指定的命令行工具/库: ```bash brew upgrade <软件包名称> ``` _示例:_ `brew upgrade git` - 升级所有已安装的图形应用程序: ```bash brew upgrade --cask ``` - 升级指定的图形应用程序: ```bash brew upgrade --cask <应用程序名称> ``` _示例:_ `brew upgrade --cask firefox` ##### 5. 查看信息 - 列出所有已安装的命令行工具和库: ```bash brew list # 或者简写 brew ls ``` - 列出所有已安装的图形应用程序: ```bash brew list --cask ``` - 查看特定命令行工具/库的详细信息: ```bash brew info <软件包名称> ``` _示例:_ `brew info python` - 查看特定图形应用程序的详细信息: ```bash brew info --cask <应用程序名称> ``` _示例:_ `brew info --cask visual-studio-code` ##### 6. 清理与维护 - 清理所有软件包的旧版本和下载缓存: ```bash brew cleanup ``` - 清理指定软件包的旧版本: ```bash brew cleanup <软件包名称> ``` - 显示将要被清理的文件 (不实际删除): ```bash brew cleanup -s ``` - 检查 Homebrew 配置问题并获取修复建议: ```bash brew doctor ``` ##### 7. 获取帮助 - 显示常用命令概览: ```bash brew help ``` - 显示特定命令的帮助信息: ```bash brew help <命令名称> ``` _示例:_ `brew help install` - 显示 Homebrew 完整的 man 手册页: ```bash man brew ``` #### mos 解决 mac 鼠标滚轮反转问题 ```bash brew install --cask mos ``` #### maccy 剪切板工具，简洁处理剪切板，可显示剪切板 ```bash brew install --cask maccy ``` # 终端通用快捷操作 以下快捷键适用于 macOS 终端 (Terminal.app, iTerm2 等) 以及大多数 Linux 终端，可以极大提升命令行操作效率。 - `Ctrl + C`: 强制终止当前正在运行的命令。 - `Ctrl + A`: 将光标移动到命令行的开头。 - `Ctrl + E`: 将光标移动到命令行的末尾。 - `Ctrl + U`: 删除从光标到行首的所有字符。 - `Ctrl + K`: 删除从光标到行尾的所有字符。 - `Ctrl + W`: 删除光标前的一个单词。 - `Ctrl + L`: 清除终端屏幕显示内容。 - `Option (Alt) + ←` (左箭头): 光标向左移动一个单词。 - `Option (Alt) + →` (右箭头): 光标向右移动一个单词。 - `↑` (上箭头): 显示上一条执行过的历史命令。 - `↓` (下箭头): 显示下一条执行过的历史命令 (需先按上箭头)。 - `Ctrl + R`: 反向搜索命令历史 (输入关键词进行搜索)。 - `Tab`: 命令或路径自动补全 (非常实用！)。 - 输入部分命令或文件名/路径后按 `Tab`，终端会尝试自动补全。 - 如果存在多个匹配项，连按两次 `Tab` 通常会列出所有可能的选项。 # macOS 开发环境配置笔记 ( 2025-05) 本文档总结了在 macOS 上配置常用开发工具的步骤，包括版本管理工具 NVM、Node.js、安全连接工具 SSH 以及版本控制系统 Git。 ##"},{"id":"v-bf406928#一、git-版本控制系统","path":"/project/macOS_Guide.html#一、git-版本控制系统","pageTitle":"Mac 操作指南","headerTitle":"一、Git 版本控制系统","text":"一、Git 版本控制系统 Git 是现代软件开发中必不可少的版本控制系统。 ###"},{"id":"v-bf406928#a-安装-git","path":"/project/macOS_Guide.html#a-安装-git","pageTitle":"Mac 操作指南","headerTitle":"A. 安装 Git","text":"A. 安装 Git 在 macOS 上安装 Git 通常有以下几种方式： 1. **通过 Xcode Command Line Tools (命令行开发者工具):** - 打开“终端 (Terminal.app)”，输入 `git --version`。如果尚未安装，系统会提示安装。 2. **通过 Homebrew (推荐的包管理器):** - 如果已安装 Homebrew，运行： ```bash brew install git ``` 3. **从 Git 官网下载:** - 访问 [https://git-scm.com/download/mac](https://git-scm.com/download/mac) 下载安装程序。 ###"},{"id":"v-bf406928#b-git-基本配置","path":"/project/macOS_Guide.html#b-git-基本配置","pageTitle":"Mac 操作指南","headerTitle":"B. Git 基本配置","text":"B. Git 基本配置 首次使用 Git 前，建议配置您的用户信息： ```bash git config --global user.name \"你的名字或昵称\" git config --global user.email \"你的邮箱地址\" ``` ###"},{"id":"v-bf406928#c-拉取-克隆-项目","path":"/project/macOS_Guide.html#c-拉取-克隆-项目","pageTitle":"Mac 操作指南","headerTitle":"C. 拉取 (克隆) 项目","text":"C. 拉取 (克隆) 项目 从远程仓库获取项目到本地： 1. **获取仓库 URL:** - HTTPS URL: 例如 `https://github.com/username/repository.git` - SSH URL: 例如 `git@github.com:username/repository.git` 2. **打开终端，导航到目标本地目录 (例如 `cd ~/Documents/Projects`)。** 3. **执行克隆命令:** Bash ``` # 使用 HTTPS git clone [https://github.com/username/repository.git](https://github.com/username/repository.git) # 或者使用 SSH (需先完成 SSH 配置) git clone git@github.com:username/repository.git # 克隆并指定本地文件夹名称 (可选) git clone <repository_url> <your_folder_name> ``` 4. **进入项目目录:** Bash ``` cd repository_name # 或者你指定的文件夹名称 ``` ###"},{"id":"v-bf406928#d-git-常用命令概览","path":"/project/macOS_Guide.html#d-git-常用命令概览","pageTitle":"Mac 操作指南","headerTitle":"D. Git 常用命令概览","text":"D. Git 常用命令概览 - `git status`: 查看当前仓库状态。 - `git add <file>` 或 `git add .`: 将文件更改添加到暂存区。 - `git commit -m \"提交信息\"`: 将暂存区的更改提交到本地仓库。 - `git push`: 将本地提交推送到远程仓库。 - `git pull`: 从远程仓库拉取最新更改并合并到本地。 - `git branch`: 查看、创建或删除分支。 - `git checkout <branch_name>`: 切换分支。 - `git merge <branch_name>`: 合并分支。 - `git log`: 查看提交历史。 ##"},{"id":"v-bf406928#二、ssh-密钥配置-macos","path":"/project/macOS_Guide.html#二、ssh-密钥配置-macos","pageTitle":"Mac 操作指南","headerTitle":"二、SSH 密钥配置 (macOS)","text":"二、SSH 密钥配置 (macOS) SSH 密钥用于安全地连接到远程服务器。 ###"},{"id":"v-bf406928#a-检查现有-ssh-密钥","path":"/project/macOS_Guide.html#a-检查现有-ssh-密钥","pageTitle":"Mac 操作指南","headerTitle":"A. 检查现有 SSH 密钥","text":"A. 检查现有 SSH 密钥 Bash ``` ls -al ~/.ssh ``` 查看是否存在 `id_rsa`、`id_ed25519` (及对应的 `.pub`公钥文件)。 ###"},{"id":"v-bf406928#b-生成新的-ssh-密钥对","path":"/project/macOS_Guide.html#b-生成新的-ssh-密钥对","pageTitle":"Mac 操作指南","headerTitle":"B. 生成新的 SSH 密钥对","text":"B. 生成新的 SSH 密钥对 如果不存在或想创建新的： 1. 运行 `ssh-keygen` 命令 (推荐 Ed25519): Bash ``` # 推荐使用 Ed25519 算法 ssh-keygen -t ed25519 -C \"你的邮箱地址\" # 或者使用 RSA 算法 (4096位) # ssh-keygen -t rsa -b 4096 -C \"你的邮箱地址\" ``` 2. 按提示操作： - **文件保存位置：** 直接回车使用默认路径 (如 `~/.ssh/id_ed25519`)。 - **设置密码短语 (Passphrase)：** 强烈建议设置。 ###"},{"id":"v-bf406928#c-将-ssh-私钥添加到-ssh-agent-并使用-macos-keychain","path":"/project/macOS_Guide.html#c-将-ssh-私钥添加到-ssh-agent-并使用-macos-keychain","pageTitle":"Mac 操作指南","headerTitle":"C. 将 SSH 私钥添加到 ssh-agent 并使用 macOS Keychain","text":"C. 将 SSH 私钥添加到 ssh-agent 并使用 macOS Keychain 1. **确保 ssh-agent 运行并配置 `~/.ssh/config`:** Bash ``` # 确保 ssh-agent 在当前会话运行 (通常 macOS 会自动处理) eval \"$(ssh-agent -s)\" # 打开或创建 ~/.ssh/config 文件，例如使用 nano # nano ~/.ssh/config ``` 在 `~/.ssh/config` 文件中添加以下内容 (如果文件已存在，请确保 `Host *` 配置不冲突)： ``` Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519 # 如果使用RSA, 改为 id_rsa ``` 保存文件后，确保其权限正确： Bash ``` chmod 600 ~/.ssh/config ``` 2. **将私钥添加到 ssh-agent (并由 Keychain 管理密码短语):** 将 `~/.ssh/id_ed25519` 替换为你的实际私钥文件名。 Bash ``` ssh-add --apple-use-keychain ~/.ssh/id_ed25519 ``` 系统会提示输入私钥的密码短语。 ###"},{"id":"v-bf406928#d-复制公钥内容","path":"/project/macOS_Guide.html#d-复制公钥内容","pageTitle":"Mac 操作指南","headerTitle":"D. 复制公钥内容","text":"D. 复制公钥内容 公钥需要添加到远程服务器或服务 (如 GitHub) 上。 Bash ``` # Ed25519 公钥 pbcopy < ~/.ssh/id_ed25519.pub # RSA 公钥 (如果使用 RSA) # pbcopy < ~/.ssh/id_rsa.pub ``` 此命令会将公钥内容复制到剪贴板。或者使用 `cat ~/.ssh/id_ed25519.pub` 查看并手动复制。 ###"},{"id":"v-bf406928#e-将公钥添加到远程服务","path":"/project/macOS_Guide.html#e-将公钥添加到远程服务","pageTitle":"Mac 操作指南","headerTitle":"E. 将公钥添加到远程服务","text":"E. 将公钥添加到远程服务 登录你的 GitHub/GitLab 等账户，在 SSH 密钥设置页面，添加新 SSH 密钥，将复制的公钥内容粘贴进去。 ##"},{"id":"v-bf406928#三、nvm-node-version-manager-安装与使用","path":"/project/macOS_Guide.html#三、nvm-node-version-manager-安装与使用","pageTitle":"Mac 操作指南","headerTitle":"三、NVM (Node Version Manager) 安装与使用","text":"三、NVM (Node Version Manager) 安装与使用 NVM 用于管理多个 Node.js 版本。 ###"},{"id":"v-bf406928#a-安装-nvm-通过-homebrew","path":"/project/macOS_Guide.html#a-安装-nvm-通过-homebrew","pageTitle":"Mac 操作指南","headerTitle":"A. 安装 NVM (通过 Homebrew)","text":"A. 安装 NVM (通过 Homebrew) 1. **安装 NVM 并创建工作目录:** ```bash brew install nvm mkdir ~/.nvm ``` 2. **配置 Shell 环境 (以 Zsh 为例，macOS Catalina 及更高版本默认):** 打开或创建 `~/.zshrc` 文件 (例如 `nano ~/.zshrc`)，在文件末尾添加： ```bash export NVM_DIR=\"$HOME/.nvm\" [ -s \"$(brew --prefix nvm)/nvm.sh\" ] && \\. \"$(brew --prefix nvm)/nvm.sh\" # This loads nvm [ -s \"$(brew --prefix nvm)/etc/bash_completion.d/nvm\" ] && \\. \"$(brew --prefix nvm)/etc/bash_completion.d/nvm\" # This loads nvm bash_completion ``` 保存并退出。 _(如果使用 Bash，请编辑 `~/.bash_profile` 或 `~/.bashrc`)_ 3. **应用更改并验证 NVM 安装:** ```bash # 应用更改 (使配置生效) source ~/.zshrc # 或者 source ~/.bash_profile # 验证 NVM 安装 command -v nvm # 应输出 nvm nvm --version # 应输出 NVM 版本号 ``` ###"},{"id":"v-bf406928#b-使用-nvm-管理-node-js","path":"/project/macOS_Guide.html#b-使用-nvm-管理-node-js","pageTitle":"Mac 操作指南","headerTitle":"B. 使用 NVM 管理 Node.js","text":"B. 使用 NVM 管理 Node.js 1. **安装 Node.js 版本:** ```bash # 安装最新的 LTS (长期支持) 版本 (推荐) nvm install --lts # 安装特定版本 # nvm install 18.17.0 # 安装最新的 Node.js 版本 # nvm install node ``` 2. **查看与切换 Node.js 版本:** ```bash # 查看已安装的 Node.js 版本 (当前使用版本前有 -> 标记) nvm ls # 查看可供远程安装的 Node.js 版本 nvm ls-remote # 切换使用的 Node.js 版本 # nvm use 18.17.0 nvm use --lts # 切换到最新的已安装LTS版本 ``` 3. **设置默认的 Node.js 版本:** (设置后，每次新开终端会自动使用此版本) Bash ```bash # nvm alias default 18.17.0 nvm alias default --lts # 将最新的已安装LTS版本设为默认 ``` 4. **验证当前 Node.js 和 npm 版本:** ```bash node -v npm -v ```"},{"id":"v-5b795768","path":"/project/nextjs-auth-refresh.html","pageTitle":"基于 Next.js 的双 Token 无感刷新认证系统 - 学习笔记","headerTitle":null,"text":"# 基于 Next.js 的双 Token 无感刷新认证系统 - 学习笔记 ##"},{"id":"v-5b795768#🚀-概述","path":"/project/nextjs-auth-refresh.html#🚀-概述","pageTitle":"基于 Next.js 的双 Token 无感刷新认证系统 - 学习笔记","headerTitle":"🚀 概述","text":"🚀 概述 首先token分为两种一种是短期的一种是长期的，为什么要分为两个token呢，就是因为出于安全性考虑，比如说你单token登录，一个token过期时间设置为几天，如果被人获取到了这个token，别人就可以利用这个token登录用户的账号，这个token也不能设置的太短，如果太短的话用户体验就太差了，你去上个厕所回来就要重新登录了 再说回双token登录，短期token和长期token，短期token作为真正的token去使用所有的请求头都带上这个token，另外一个长期token作为刷新token，当我们的短期token过期的时候我们通过这个refreshtoken验证是否真正的过期，没有过期就重新签发一个短期token实现无感刷新 双Token体系,**两种Token的存储位置和方式完全不同**：短期token可以存在内存中，长期token在服务器中（服务端设置的 HttpOnly Cookie）里，所以前端获取不到这个代码，安全系数高 - **短期 accessToken**：因为它需要被JavaScript频繁读取并添加到请求头中，所以通常存储在**客户端的内存**里（比如React的state或Vuex/Pinia中）。这使得它容易受到XSS攻击，但因为它生命周期极短，被盗后的危害有限。 - **长期 refreshToken**：它的安全性最高。最佳实践是将其存储在由**服务端设置的 HttpOnly Cookie** 中。 - `HttpOnly` 属性意味着前端的JavaScript代码**完全无法读取**到这个Cookie。 - 这样一来，即使网站遭到XSS攻击，攻击者的脚本也偷不走 `refreshToken`，从而保证了用户长期会话的安全。 可能遇到的问题：[如果多个请求同时因为 Token 过期而失败，它们会同时触发刷新，造成浪费和冲突。](#第-7-步-处理并发请求-防止重复刷新) ##"},{"id":"v-5b795768#第一部分-后端-api-接口搭建","path":"/project/nextjs-auth-refresh.html#第一部分-后端-api-接口搭建","pageTitle":"基于 Next.js 的双 Token 无感刷新认证系统 - 学习笔记","headerTitle":"第一部分：后端 API 接口搭建","text":"第一部分：后端 API 接口搭建 我们在 Next.js 的 App Router 中创建三个核心的 API 接口，用于处理认证流程。 ### 第 1 步：用户登录接口 (`/api/auth/login`) **目的**：验证用户身份，成功后返回 `accessToken`，同时将 `refreshToken` 安全地设置在 `HttpOnly` Cookie 中。 #### 1.1 - 签发两种 Token ``` // 文件: /app/api/auth/login/route.ts import { sign } from 'jsonwebtoken'; // 假设用户验证成功，用户ID为 1 const userId = 1; const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'; // 创建 AccessToken (有效期短，例如15分钟) const accessToken = sign({ userId }, JWT_SECRET, { expiresIn: '15m' }); // 创建 RefreshToken (有效期长，例如7天) const refreshToken = sign({ userId }, JWT_SECRET, { expiresIn: '7d' }); ``` #### 1.2 - 将 RefreshToken 序列化为安全的 Cookie ``` // 文件: /app/api/auth/login/route.ts import { serialize } from 'cookie'; const serializedCookie = serialize('refreshToken', refreshToken, { httpOnly: true, // 防止JS读取，防御XSS攻击 secure: process.env.NODE_ENV === 'production', // 只在HTTPS下传输 sameSite: 'strict', // 严格的同站策略，防御CSRF攻击 maxAge: 60 * 60 * 24 * 7, // 7天有效期 path: '/', }); ``` #### 1.3 - 组合成完整接口 ``` // 文件: /app/api/auth/login/route.ts import { NextResponse } from 'next/server'; export async function POST(req: Request) { // ... 用户名密码验证逻辑 ... // ... 签发 token 和序列化 cookie 的代码 ... return NextResponse.json( { accessToken }, // 在body中返回accessToken { status: 200, headers: { 'Set-Cookie': serializedCookie }, // 在header中设置cookie } ); } ``` > 💡 **核心知识点回顾** > > - **jsonwebtoken**: 这是一个构建和验证“数字身份证”（JWT）的工具。 > - `jwt.sign()`: **签发凭证**。它接收用户信息（Payload）、一个绝密的秘钥（Secret Key），生成一个带防伪签名（Signature）的 Token 字符串。这确保了 Token 的内容未经篡改。 > - `jwt.verify()`: **验证凭证**。它使用**同一个秘钥**来检查 Token 的签名是否正确、是否在有效期内。这是实现**无状态认证**的关键，服务器无需存储 Session 信息。 > - **NextResponse.json()**: 这不是简单的 `JSON.stringify()`。它是一个**完整的 HTTP 响应构造器**。 > - 它将 JS 对象转换为 JSON 字符串作为**响应体 (Body)**。 > - **自动设置**关键的 `Content-Type: application/json` **响应头 (Header)**，告知浏览器数据格式。 > - 它返回一个功能齐全的 `NextResponse` 对象，允许你链式地设置状态码、Cookie (`Set-Cookie`) 和其他自定义 Headers，是构建健壮后端 API 的基石。 ### 第 2 步：刷新 Token 接口 (`/api/auth/refresh`) **目的**：当 `accessToken` 过期时，前端调用此接口，验证 `refreshToken` Cookie，并返回一个新的 `accessToken`。 #### 2.1 - 读取并验证 Cookie ``` // 文件: /app/api/auth/refresh/route.ts import { cookies } from 'next/headers'; import { verify } from 'jsonwebtoken'; const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'; export async function POST(req: Request) { const cookieStore = cookies(); const refreshToken = cookieStore.get('refreshToken')?.value; if (!refreshToken) { return NextResponse.json({ message: 'RefreshToken 未找到' }, { status: 401 }); } try { const decoded = verify(refreshToken, JWT_SECRET) as { userId: number }; // ... 接 2.2 } catch (error) { return NextResponse.json({ message: '会话无效，请重新登录' }, { status: 401 }); } } ``` #### 2.2 - 签发新的 AccessToken ``` // 文件: /app/api/auth/refresh/route.ts // ... (在 try 块内部) // 使用从 refreshToken 解码出的用户信息来创建新的 accessToken const accessToken = sign({ userId: decoded.userId }, JWT_SECRET, { expiresIn: '15m' }); return NextResponse.json({ accessToken }); ``` ### 第 3 步：用户登出接口 (`/api/auth/logout`) **目的**：让 `refreshToken` Cookie 失效，完成登出。通过返回一个同名、同路径但 `maxAge` 为负数的 Cookie 实现。 ``` // 文件: /app/api/auth/logout/route.ts import { NextResponse } from 'next/server'; import { serialize } from 'cookie'; export async function POST(req: Request) { const serializedCookie = serialize('refreshToken', '', { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', path: '/', maxAge: -1, // 关键：设置为负数使其立即过期 }); return NextResponse.json( { message: '登出成功' }, { status: 200, headers: { 'Set-Cookie': serializedCookie }, } ); } ``` ## 第二部分：前端认证状态管理 (`\"use client\"`) ### 第 4 步：创建认证上下文 (AuthContext) **目的**：创建一个全局状态管理器，让应用中任何组件都能方便地获取认证状态和方法。 ``` // 文件: /app/contexts/AuthContext.tsx \"use client\"; import React, { createContext, useContext, useState, ReactNode } from 'react'; // ... (接口定义和 Provider/Hook 骨架) ``` ### 第 5 步：封装认证请求 (`authFetch`) **目的**：创建一个 `fetch` 的替代品，它能自动为请求添加 `Authorization` 头，并处理后续的无感刷新。 ### 第 6 步：实现核心的无感刷新逻辑 在 `authFetch` 内部捕获 401 错误，调用刷新 API，获取新的 `accessToken`，然后用新 Token **重试**刚才失败的请求。 ### 第 7 步：处理并发请求，防止重复刷新 问题：如果多个请求同时因为 Token 过期而失败，它们会同时触发刷新，造成浪费和冲突。 解决方案：使用一个外部变量作为“锁”，确保同一时间只有一个刷新请求在进行。 ``` // 文件: /app/contexts/AuthContext.tsx // 在 AuthProvider 组件外部定义一个变量 let refreshTokenPromise: Promise<string | null> | null = null; // 在 AuthProvider 内部，authFetch 的 401 处理逻辑 if (response.status === 401) { if (!refreshTokenPromise) { // 如果当前没有正在刷新的请求，则发起一个新的 refreshTokenPromise = new Promise(async (resolve, reject) => { try { // ... (执行刷新Token的API调用) ... const newAccessToken = '...'; resolve(newAccessToken); } catch (e) { reject(e); } finally { // 结束后，清空Promise，以便下次可以再次触发 refreshTokenPromise = null; } }); } try { // 等待正在进行的刷新请求完成 const newAccessToken = await refreshTokenPromise; // ... (用 newAccessToken 重试请求) ... } catch (e) { // 刷新失败，登出 } } ``` > 🧠 **深度解析：并发刷新与 Promise 锁模式** > > 这是一个极其巧妙的并发控制模式。为什么必须用 `Promise` 而不是简单的布尔值 `isRefreshing`？ > > - **布尔值的缺陷**: 布尔值只能告知“**是否在刷新**”，但它无法提供一个机制让后来的请求**暂停并等待结果**，也无法**传递最终的结果**（新的Token）。简单的 `while(isRefreshing)` 会阻塞 JavaScript 主线程，导致页面卡死。 > - **Promise 的完美 çözüm**： > 1. **状态即是锁**: 一个处于 `pending` 状态的 Promise 本身就是一个完美的“锁”。 > 2. **await 即是等待**: `await` 关键字天生就是用来“暂停”当前函数，等待一个 Promise 完成，并且**不会阻塞主线程**。 > 3. **resolve 即是结果传递**: 当 Promise 被 `resolve(value)` 时，所有 `await` 这个 Promise 的地方都会被唤醒，并拿到这个 `value`。 > > > 思想升华：发布-订阅模式的精妙应用 > > > 这个 Promise 锁模式，本质上是**利用 Promise 的原生特性，实现了一次性的、带记忆功能的发布-订阅模式**。 > > > - **主题**: `refreshTokenPromise` 这个 Promise 对象。 > > - **发布者**: 第一个触发刷新并创建 `new Promise` 的请求。它通过调用 `resolve` 或 `reject` 来“发布”最终结果。 > > - **订阅者**: 所有后来 `await refreshTokenPromise` 的请求。它们“订阅”了这个主题，等待最终结果的通知。 > > > 这证明了**设计模式是一种思想，而非固定的代码**。通过理解其核心（如解耦），我们可以用各种工具（如 Promise）巧妙地实现它。 ## 第三部分：整合与使用 ### 第 8 步：全局应用 Provider 将 `AuthProvider` 包裹在根布局 `layout.tsx` 中，使整个应用都能访问到认证状态。 ``` // 文件: /app/layout.tsx import { AuthProvider } from './contexts/AuthContext'; export default function RootLayout({ children }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> <AuthProvider> {children} </AuthProvider> </body> </html> ); } ``` ### 第 9 步：在组件中使用 在任何客户端组件中，通过 `useAuth` hook 来获取数据或执行操作。`authFetch` 会在后台自动处理所有 Token 刷新逻辑，实现真正的“无感刷新”。 ``` // 文件: /app/dashboard/page.tsx \"use client\"; import { useAuth } from \"../contexts/AuthContext\"; import { useEffect } from \"react\"; export default function Dashboard() { const { authFetch, logout } = useAuth(); useEffect(() => { const loadData = async () => { try { // 使用我们封装好的 authFetch，它会自动处理认证和刷新 const res = await authFetch('/api/some-protected-data'); const data = await res.json(); console.log(data); } catch (error) { // 刷新失败的错误会在这里被捕获 console.error(error); } }; loadData(); }, [authFetch]); return <button onClick={logout}>登出</button>; } ```"},{"id":"v-bd774998#总结对比","path":"/project/nextjs-dir.html#总结对比","pageTitle":"Next.js 项目文件夹结构笔记","headerTitle":"总结对比","text":"总结对比 | 特性 | `utils/` (工具) | `hooks/` (React逻辑) | `lib/` (库) | `services/` (专家/部门) | | :--- | :--- | :--- | :--- | :--- | | **职责** | 通用、无状态的JS功能 | **有状态的React逻辑** | 项目特定、共享的设置与实例 | 封装一个完整的业务能力 | | **抽象** | 代码级（如何做） | **UI逻辑级（如何响应）** | 项目级（共享的定义） | 架构级（做什么） | | **状态** | 严格无状态 | **有状态 (useState)** | 一般无状态（但可导出实例） | **可以有内部状态** | | **示例** | `formatDate()` | `useWindowSize()` | `db.ts`, `lib/constants.ts` | `storageService.saveState()` |"},{"id":"v-0d62a64c","path":"/project/nextjs-i18n.html","pageTitle":"Next.js的一种国际化方案","headerTitle":null,"text":"# Next.js的一种国际化方案 [原文章链接](https://developer.aliyun.com/article/1644850) ##"},{"id":"v-0d62a64c#具体步骤","path":"/project/nextjs-i18n.html#具体步骤","pageTitle":"Next.js的一种国际化方案","headerTitle":"具体步骤","text":"具体步骤 - 安装依赖 ```powershell pnpm add next-intl ``` - 根目录新建 `messages` 文件夹，并写入对应的国际化文件： ```json // en.json { \"Route\":{ \"about\":\"About\", \"dashboard\":\"Dashboard\", \"system-manage\":\"System Manage\", \"internationalization\":\"Internationalization\" } } // zh.json { \"Route\":{ \"about\":\"关于\", \"dashboard\":\"仪表盘\", \"system-manage\":\"系统管理\", \"internationalization\":\"国际化\" } } ``` - 根目录的 `next.config.ts` 文件设置插件： ```ts import type { NextConfig } from \"next\"; import createNextIntlPlugin from 'next-intl/plugin'; const withNextIntl = createNextIntlPlugin(); const nextConfig: NextConfig = { }; export default withNextIntl(nextConfig); ``` - 新建 `src/i18n/config.ts` 文件，写入配置： ```ts export type Locale = (typeof locales)[number]; export const locales = ['zh', 'en'] as const; export const defaultLocale: Locale = 'zh'; ``` - 新建 `src/i18n/request.ts` 文件，创建一个请求范围的配置对象： ```ts import { getRequestConfig } from 'next-intl/server'; import { getLocale } from '@/i18n'; export default getRequestConfig(async () => { const locale = await getLocale(); return { locale, messages: (await import(`../../messages/${ locale}.json`)).default, }; }); ``` - 新建 `src/i18n/index.ts` 文件，用于服务端获取和设置语言 ```ts 'use server'; import { cookies } from 'next/headers'; import { defaultLocale, Locale } from '@/i18n/config'; // In this example the locale is read from a cookie. You could alternatively // also read it from a database, backend service, or any other source. const COOKIE_NAME = 'NEXT_LOCALE'; export async function getLocale() { return (await cookies()).get(COOKIE_NAME)?.value || defaultLocale; } export async function setLocale(locale: Locale) { (await cookies()).set(COOKIE_NAME, locale); } ``` - `app/layout.tsx` 文件配置 `NextIntlClientProvider`： ```ts import { NextIntlClientProvider} from 'next-intl'; import { getLocale, getMessages} from 'next-intl/server'; export default async function RootLayout({ children }: { children: React.ReactNode; }) { const locale = await getLocale(); // Providing all messages to the client // side is the easiest way to get started const messages = await getMessages(); return ( <html lang={ locale}> <body> <NextIntlClientProvider messages={ messages}> { children} </NextIntlClientProvider> </body> </html> ); } ``` - 在文件中使用： ```ts import { useTranslations } from 'next-intl'; export default function Dashboard() { const t = useTranslations('Route'); return ( <h1> { t('dashboard')} </h1> ); } ``` ##"},{"id":"v-0d62a64c#切换语言","path":"/project/nextjs-i18n.html#切换语言","pageTitle":"Next.js的一种国际化方案","headerTitle":"切换语言","text":"切换语言 - 新建 `src/components/LangSwitch/index.tsx` 文件： ```html 'use client'; import { useLocale } from 'next-intl'; import { Button } from '@/components/ui/button'; import { setLocale } from '@/i18n'; import { type Locale, locales } from '@/i18n/config'; export default function LangSwitch() { const [ZH, EN] = locales; const locale = useLocale(); // 切换语言 function onChangeLang(value: Locale) { const locale = value as Locale; setLocale(locale); } return ( <Button variant=\"ghost\" size=\"icon\" onClick={() => onChangeLang(locale === ZH ? EN : ZH)}> {locale === ZH ? '中' : 'EN'} <span className=\"sr-only\">Toggle Lang</span> </Button> ); } ``` - 在需要的位置引入组件： ```html import LangSwitch from '@/components/LangSwitch'; <LangSwitch /> ```"},{"id":"v-53a116b4","path":"/project/nextjs.html","pageTitle":"nextjs - 15 版本及以上","headerTitle":null,"text":"# nextjs - 15 版本及以上 ##"},{"id":"v-53a116b4#介绍","path":"/project/nextjs.html#介绍","pageTitle":"nextjs - 15 版本及以上","headerTitle":"介绍","text":"介绍 nextjs 官网：https://nextjs.org/docs/getting-started Next.js 是一个 React 框架，它允许你使用 React 框架建立超强的、有利于 SEO 的、极度面向用户的静态网站和网络应用。Next.js 以在构建具有你所需要的所有功能的生产就绪的应用程序时的最佳开发者体验而闻名。 它具有混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等功能，无需额外配置。 **环境准备** - Node.js 18+ - npm/yarn/pnpm（推荐使用 pnpm） - 代码编辑器（推荐 VS Code） ##"},{"id":"v-53a116b4#项目搭建","path":"/project/nextjs.html#项目搭建","pageTitle":"nextjs - 15 版本及以上","headerTitle":"项目搭建","text":"项目搭建 ```bash $ npx create-next-app # 若还未安装 create-next-app ，则需要先安装以下软件包: Need to install the following packages: create-next-app Ok to proceed? (y) y # 项目名称 √ What is your project named? ... my-app # 是否需要使用 TypeScript √ Would you like to use TypeScript? ... No / Yes ✔ # 是否需要使用 ESLint √ Would you like to use ESLint? ... No / Yes ✔ # 是否需要使用 Tailwind CSS（https://www.tailwindcss.cn/）只需书写 HTML 代码，无需书写 CSS # 本质上是一个工具集，包含了大量类似 flex、 pt-4、 text-center 以及 rotate-90 等工具类，可以组合使用并直接在 HTML 代码上实现任何 UI 设计。 √ Would you like to use Tailwind CSS? ... No / Yes ✔ # 是否需要在项目中使用 src 目录，若不使用 src 目录默认会把所有文件放在根目录，为了方便开发，这里启用 src 目录 √ Would you like to use `src/` directory? ... No / Yes ✔ # 是否使用 App Router，若选择 No 则默认是 Pages Router（具体区别在下面，可以先简单看下再选择） √ Would you like to use App Router? (recommended) ... No ✔ / Yes # 是否启用路径别名 √ Would you like to customize the default import alias? ... No / Yes ✔ # 希望配置什么导入别名（默认是 @/*，若不修改默认别名则直接回车） √ What import alias would you like configured? ... @/* # 完成配置选择后，下面工具将会根据上述配置进行项目搭建 Creating a new Next.js app in E:\\xxx\\my-app. Using npm. # 若上述选择了 App Router 则模板初始化项目为 app-tw，若没选择则模板初始化项目为 default-tw #（下面会展示对应模板的初始化目录） Initializing project with template: default-tw Installing dependencies: - react - react-dom - next - typescript - @types/react - @types/node - @types/react-dom - tailwindcss - postcss - autoprefixer - eslint - eslint-config-next added 326 packages, and audited 327 packages in 2m 117 packages are looking for funding run `npm fund` for details found 0 vulnerabilities Initialized a git repository. Success! Created my-app at E:\\xxx\\my-app ``` ###"},{"id":"v-53a116b4#项目目录结构","path":"/project/nextjs.html#项目目录结构","pageTitle":"nextjs - 15 版本及以上","headerTitle":"项目目录结构","text":"项目目录结构 ``` ├── src/ │ ├── app/ # App Router 核心目录 │ │ ├── layout.tsx # 全局布局 │ │ └── page.tsx # 首页组件 │ ├── components/ # 公共组件 │ ├── lib/ # 工具函数/第三方库 │ └── styles/ # 全局样式 ├── public/ # 静态资源 ├── next.config.js # Next.js 配置 └── package.json ``` ##"},{"id":"v-53a116b4#node-js-与前端项目中的环境变量-env-笔记","path":"/project/nextjs.html#node-js-与前端项目中的环境变量-env-笔记","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Node.js 与前端项目中的环境变量（env）笔记","text":"Node.js 与前端项目中的环境变量（env）笔记 1. 环境变量的作用 - 环境变量（Environment Variables，简称 env）用于存储应用运行时的配置信息，如数据库连接、API 密钥、运行模式（开发/生产）、第三方服务凭证等。 - 通过环境变量，可以将敏感或易变的信息与代码分离，提升安全性与灵活性。 - 常见使用场景：数据库 URL、API Token、不同环境下的配置切换（如开发、测试、生产）。 2. 环境变量的定义与使用方式 - 一般通过 `.env` 文件定义环境变量，格式为 `KEY=VALUE`。 - 在 Node.js、Next.js、Vite 等现代前端/全栈框架中，官方都内置了环境变量管理机制。 **示例：.env 文件内容** ``` # .env DATABASE_URL=postgres://user:pass@localhost:5432/mydb NEXT_PUBLIC_API_BASE=https://api.example.com SECRET_KEY=xxxxx NODE_ENV=development ``` 3. Node.js 项目中如何读取环境变量 - Node.js 通过 `process.env` 读取环境变量。 **示例代码：** ```js // 读取环境变量 const dbUrl = process.env.DATABASE_URL; const secret = process.env.SECRET_KEY; ``` 4. Next.js、Vite 等前端框架中的环境变量 - 约定以 `NEXT_PUBLIC_`（Next.js）或 `VITE_`（Vite）为前缀的变量自动暴露到浏览器端。**不要把敏感信息暴露给前端！** - 其余变量只在服务端可用，保证安全性。 **Next.js 示例：** ```js // 服务端可读取所有变量 const dbUrl = process.env.DATABASE_URL; // 客户端只能读取 NEXT_PUBLIC_ 前缀的变量 const apiBase = process.env.NEXT_PUBLIC_API_BASE; ``` **Vite 示例：** ```js // 只能读取以 VITE_ 为前缀的变量 const baseUrl = import.meta.env.VITE_API_BASE; ``` 5. .env 文件的种类和优先级 - 常见文件有 `.env`、`.env.local`、`.env.development`、`.env.production` 等。 - 优先级：本地优先（如 `.env.local` 覆盖 `.env`），可根据环境自动切换不同配置。 - 生产环境建议通过运维/CI/CD 系统设置环境变量，不要直接上传 .env 文件。 6. 环境变量的安全与最佳实践 - **敏感信息（如密码、密钥）只放在服务端可用的变量，不要加 NEXT*PUBLIC*/VITE\\_ 前缀。** - `.env` 文件一般加入 `.gitignore`，防止泄露敏感信息到代码仓库。 - 生产环境推荐用云服务、CI/CD、服务器环境配置方式设置变量。 7. 环境变量的类型和默认值 - 环境变量默认都是字符串类型。取值时注意转换。 - 可以通过代码设定默认值，防止变量未定义导致程序报错。 **示例：设置默认值** ```js const port = process.env.PORT || 3000; ``` 8. 参考 - [Node.js 官方文档：process.env](https://nodejs.org/api/process.html#processenv) - [Next.js 官方文档：环境变量](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables) - [Vite 官方文档：环境变量](https://vitejs.dev/guide/env-and-mode.html) ##"},{"id":"v-53a116b4#为项目添加可使用-引入","path":"/project/nextjs.html#为项目添加可使用-引入","pageTitle":"nextjs - 15 版本及以上","headerTitle":"为项目添加可使用@引入","text":"为项目添加可使用@引入 通常情况可在创建项目时加入，如果未集成，可以手动加入配置 - 修改 next.config.mjs ``` import path from \"path\"; import { fileURLToPath } from \"url\"; // 获取 ESM 的 __dirname 等效值 const __filename = fileURLToPath(import.meta.url); const __dirname = path.dirname(__filename); export default { webpack: (config) => { config.resolve.alias = { ...config.resolve.alias, //路径映射 \"@\": path.resolve(__dirname, \"src\"), }; return config; }, }; ``` - 配置 jsconfig.json/tsconfig.json ``` { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { // 注意，这里不需要单独为每个文件配置路径，直接配置根路径，根路径下所有子文件夹都可以被访问到 // \"@components/*\": [\"src/components/*\"], \"@/*\": [\"src/*\"] } } } ``` - 注意事项 - jsconfig.json 中 不需要单独为每个文件配置路径，直接配置根路径，根路径下所有子文件夹都可以被访问到 - 组件中使用：@/xxx，注意斜杠，要使用@/，不是只有@，根据 jsconfig.json 中的配置作为判断依据 ##"},{"id":"v-53a116b4#next-js-核心渲染概念","path":"/project/nextjs.html#next-js-核心渲染概念","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js 核心渲染概念","text":"Next.js 核心渲染概念 Next.js 提供了多种灵活的渲染策略，以满足不同应用场景，优化性能、SEO 和用户体验。以下内容结合 Next.js 官方文档和社区权威资料详细介绍了主要的渲染机制。 --- **1. 静态渲染（Static Rendering）** **核心思想**：在构建时（build time）生成 HTML 文件，用户访问时直接返回静态文件。 - **实现方式**：Next.js 默认采用静态渲染，如果页面没有动态依赖（如 cookies、headers、搜索参数），会自动在构建阶段生成 HTML 文件。 - **优势**： - 速度极快：内容可部署到 CDN，用户可从最近节点读取页面，极大提升加载速度。 - 服务器压力低：页面仅需在构建阶段生成一次，后续请求无需服务器实时参与。 - SEO 友好：搜索引擎抓取到完整 HTML 内容。 - **适用场景**：博客、产品介绍页、公司官网等内容不常变且对所有用户一致的页面。 参考：[Partial Prerendering - Next.js 官方文档](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering) --- **2. 动态渲染（Dynamic Rendering）** **核心思想**：在请求时（request time）由服务器实时生成页面 HTML，允许页面内容根据每次请求个性化变化。 - **实现方式**：如果页面依赖 cookies、headers、实时数据等，Next.js 会自动切换为动态渲染。 - **优势**： - 数据实时：可展示每次请求的最新数据（如用户仪表盘、新闻流）。 - 内容个性化：支持为不同用户渲染不同内容。 - **适用场景**：需要展示个性化或实时数据的页面，如个人中心、购物车、社交动态等。 参考：[Dynamic rendering instead of Static rendering (StackOverflow)](https://stackoverflow.com/questions/77368815/next-js-13-dynamic-rendering-instead-of-static-rendering) --- **3. 组件级流式传输（Component-Level Streaming）** **核心思想**：利用 React 18 的 `<Suspense>` 组件，允许页面的部分内容（如慢速数据组件）异步流式加载，页面其余部分可先渲染并展示。 - **实现方式**： 1. 找出页面中数据加载较慢的组件（如需要复杂数据查询的图表）。 2. 让该组件自身异步获取数据（使用 async/await）。 3. 在父组件中使用 `<Suspense fallback={<Skeleton />}>` 包裹慢组件，未加载前显示骨架屏。 - **优势**： - 用户体验优：页面静态部分可快速可见，大幅缩短首屏时间。 - 可渐进增强：慢组件加载完毕后无缝“流入”页面。 - **适用场景**：含有部分慢数据加载、希望优化首屏体验的复杂页面。 - **决定 Suspense 的边界在哪里**： - Suspense 的界限取决于以下几点： 1. 您希望用户如何体验页面流动。 2. 您想要优先考虑哪些内容。 3. 如果组件依赖于数据获取。 - 你可以整体流式传输页面，也可以只流式某些组件，具体看业务需求。 参考：[Understanding rendering in Next.js - Educative](https://www.educative.io/answers/understanding-rendering-in-nextjs) --- **4. 部分预渲染（Partial Prerendering，PPR）** **核心思想**：结合静态与动态渲染的优点。Next.js 先为页面生成静态“壳”，动态内容部分预留“漏洞”（Holes），动态数据随后异步流入。 - **工作原理**： 1. Next.js 预渲染静态框架（如布局、通用组件）。 2. 页面上的动态内容部分以“漏洞”形式留空，待请求时异步填充。 3. 用户可立刻看到静态内容，动态内容加载完成后自动补全。 - **优势**： - 兼顾速度与实时性：首屏极快可见，个性化/实时内容随后补全。 - SEO 友好：静态壳提升可抓取性，动态内容可按需加载。 - **适用场景**：既有静态内容又有个性化/实时内容的页面，如电商首页、社交信息流等。 - **状态演进**： - Next.js 14：PPR 为实验性功能，需 canary 版本并在配置中手动开启。 - Next.js 15：PPR 已为稳定特性，默认开启，无需额外配置。 参考： - [Getting Started: Partial Prerendering - Next.js 官方文档](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering) - [Next.js Rendering Strategies and how they affect core web vitals](https://nextjs.org/docs/app/building-your-application/rendering) --- **5. 术语对比总结** | 渲染策略 | 生成时机 | 是否个性化 | 性能 | SEO | 典型场景 | | ----------------- | -------- | ---------- | -------- | --- | ------------------ | | 静态渲染 | 构建时 | 否 | 极快 | 优 | 博客、产品介绍页 | | 动态渲染 | 请求时 | 支持 | 较慢 | 优 | 用户仪表盘、购物车 | | 组件级流式传输 | 请求时 | 支持 | 渐进提升 | 优 | 慢组件的复杂页面 | | 部分预渲染（PPR） | 混合 | 支持 | 极快+优 | 优 | 电商、社交信息流 | --- **参考** - [Next.js 官方文档：Partial Prerendering](https://nextjs.org/docs/app/building-your-application/rendering/partial-prerendering) - [Next.js Rendering Strategies and how they affect core web vitals](https://nextjs.org/docs/app/building-your-application/rendering) - [Understanding rendering in Next.js - Educative](https://www.educative.io/answers/understanding-rendering-in-nextjs) - [next js 13 Dynamic rendering instead of Static rendering (StackOverflow)](https://stackoverflow.com/questions/77368815/next-js-13-dynamic-rendering-instead-of-static-rendering) --- ##"},{"id":"v-53a116b4#我有一些页面不需要用到根布局怎么办","path":"/project/nextjs.html#我有一些页面不需要用到根布局怎么办","pageTitle":"nextjs - 15 版本及以上","headerTitle":"我有一些页面不需要用到根布局怎么办？","text":"我有一些页面不需要用到根布局怎么办？ 通常情况下，我们创建页面有一套骨架，大部分页面可以在此之上通用，但是有一些“特立独行”的页面，比如登录页，详情页等等他们并不需要用到根布局 也就是 layout ，这时我们可以使用 nextjs 提供的路由组 (Route Groups) ,最好是在创建项目时就考虑拆分路由组，以免二次修改。 --- 1. 什么是路由组？ 定义：路由组是一个特殊的文件夹，其名称被圆括号 () 包裹。 核心规则：路由组的文件夹名会被路由系统忽略，不会出现在最终的 URL 路径中。 示例： 文件路径 `app/(marketing)/about/page.tsx` 在浏览器中对应的 URL 是 `/about`，而不是 `/marketing/about`。 2. 为什么要使用路由组？（两大核心用途） 路由组的主要价值在于组织和管理路由，它提供了两种非常实用的能力： - 用途一：创建多套独立的、互不嵌套的布局 这是路由组最强大的功能。通常情况下，子目录的 layout.tsx 会嵌套在父目录的 layout.tsx 中。路由组可以让你打破这种嵌套关系，创建平行的布局系统。 场景：您的应用需要一个带侧边栏和播放器的“主应用布局”，同时还需要一个只有简单背景的“登录/注册布局”。 解决方案： 将主应用页面（如 dashboard, music）放入一个路由组，例如 (main)，并在这个组里创建复杂的 layout.tsx。 将登录/注册页面放入另一个路由组，例如 (auth)，并在这个组里创建极简的 layout.tsx。 在最顶层的 app/layout.tsx 只保留最基础的 `<html>` 和`<body>`。 文件结构示例： ``` src/app/ ├── (main)/ # 主应用组 │ ├── music/ │ │ └── page.tsx # URL: /music │ └── layout.tsx # ✅ 带侧边栏和播放器的复杂布局 │ ├── (auth)/ # 身份验证组 │ ├── login/ │ │ └── page.tsx # URL: /login │ └── layout.tsx # ✅ 只有居中卡片的极简布局 │ └── layout.tsx # //真正的根布局，只包含<html>和<body> ``` 结果： 访问 /music 时，应用的是 (main)/layout.tsx。 访问 /login 时，应用的是 (auth)/layout.tsx。 这两套布局是平级的，(auth) 布局不会被嵌套在 (main) 布局中，完美实现了 UI 隔离。 - 用途二：组织项目文件，保持路由整洁 有时您只想在文件系统里将相关的页面归类，但又不希望为它们创建一套新的布局。 场景：您的应用有很多营销相关的页面，如 /about, /contact, /pricing。您希望把它们放在一个文件夹里，但它们都应该使用全局的根布局。 解决方案： 创建一个路由组 (marketing)，将这些页面放进去，但不要在这个组里创建 layout.tsx 文件。 文件结构示例： ``` src/app/ ├── (marketing)/ # 仅用于组织文件的路由组 │ ├── about/ │ │ └── page.tsx # URL: /about │ ├── contact/ │ │ └── page.tsx # URL: /contact │ └── pricing/ │ └── page.tsx # URL: /pricing │ └── layout.tsx # 全局根布局 ``` 结果： 访问 /about, /contact, /pricing 时，因为 (marketing) 文件夹内没有自己的 layout.tsx，Next.js 会向上查找，并最终使用最外层的 app/layout.tsx。 这样既保持了文件结构的整洁，又没有引入不必要的布局层级。 3. 关键点总结 路由组通过文件夹名加括号 () 来创建。 它的核心特性是不影响最终的 URL 结构。 最大的作用是创建并行的、隔离的布局系统，用于处理像应用主界面和登录页这种完全不同的 UI。 当一个路由组内不包含 layout.tsx 文件时，它就只起到组织文件的作用，其内部页面会沿用父级的布局。 它是组织复杂 Next.js 项目、实现高级布局模式的官方标准方法。 ##"},{"id":"v-53a116b4#next-js-server-component-直接数据库","path":"/project/nextjs.html#next-js-server-component-直接数据库","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js Server Component (直接数据库)","text":"Next.js Server Component (直接数据库) 1. 官方文档解读 - [Next.js 数据获取官方文档](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching)指出：在 Server Component（服务端组件）里可以直接用数据库驱动（如 [postgres.js](https://github.com/porsager/postgres)）访问数据库，无需专门写 API 层。 - 传统写法：前端请求 `/api/list` 这样的 API 路径，API 代码里查数据库。 - Next.js Server Component 新写法：服务端组件里直接查数据库，省掉单独 API 层，代码依然运行在服务端，安全性有保障。 2. Server Component 如何连接数据库 - 在 Server Component、Route Handler 或 API Route 都可以直接用数据库驱动。 - 只要代码保证只在服务端运行（如 page.tsx 默认是 Server Component），就可以连数据库。 **数据库访问示例：** ```typescript // app/lib/data.ts import postgres from \"postgres\"; const sql = postgres(process.env.DATABASE_URL!, { ssl: \"require\" }); export async function getInvoices() { return await sql`SELECT * FROM invoices`; } // app/invoices/page.tsx import { getInvoices } from \"../lib/data\"; export default async function InvoicePage() { const invoices = await getInvoices(); return ( <ul> {invoices.map((inv) => ( <li key={inv.id}>{inv.amount}</li> ))} </ul> ); } ``` 3. 前端如何使用这些服务端数据 - 页面渲染时，Server Component 查库，服务器生成 HTML 并直接返回，首屏体验极佳。 - 需要交互、异步、局部刷新时，前端通过 fetch 调用 API Route，后端查库返回数据。 **使用场景总结：** - 首屏渲染、静态内容 → Server Component 直查数据库 - 用户交互（搜索、分页、表单提交等）→ fetch + API Route 4. Server Component 直查库 vs API Route 的适用场景 - 页面初次加载、静态内容：推荐用 Server Component 直接查库。 - 用户操作、异步刷新等：推荐用 fetch + API Route。 - 实时/轮询需求（如点赞、聊天等）：也推荐用 API Route。 **对比表：** | 场景 | 推荐方式 | 说明 | | ------------ | ----------------- | ------------ | | 页面初次加载 | Server Component | 直接查库渲染 | | 用户操作 | fetch + API Route | 动态查库 | | 实时/轮询 | fetch + API Route | 持续获取数据 | | 静态页面 | Server Component | 只查一次 | 5. 具体例子 - 搜索/分页/表单提交等需要用户交互：客户端 fetch API 路由，API Route 查库返回。 - 首页加载数据、静态展示：Server Component 直接查库，渲染进 HTML。 **示例代码：** ```typescript // 搜索场景（API Route） // app/api/search/route.ts import postgres from \"postgres\"; const sql = postgres(process.env.DATABASE_URL!, { ssl: \"require\" }); export async function GET(req) { const { query } = req.query; const res = await sql`SELECT * FROM invoices WHERE customer ILIKE ${ \"%\" + query + \"%\" }`; return Response.json(res); } // 客户端 fetch fetch(\"/api/search?query=xxx\").then((res) => res.json()); // 首页首屏（Server Component） // app/invoices/page.tsx export default async function InvoicePage() { const invoices = await getInvoices(); return ( <ul> {invoices.map((inv) => ( <li key={inv.id}>{inv.amount}</li> ))} </ul> ); } ``` 6. 表单提交如何安全插入数据库 - 必须通过 API Route 或 Server Action 收集表单数据，服务端再执行 SQL 插入，前端不能直连数据库。 - 插入/更新/删除操作建议统一在服务端路由/函数中完成，保证安全与一致性。 7. SQL 注入防范建议 - 使用如 postgres.js 这类现代数据库驱动，采用**参数化查询**自动防注入。 - 写法：`sql\\`SELECT \\* FROM users WHERE name = ${name}\\`` - 无论 name 传什么内容，驱动会自动转义，防止 SQL 注入攻击。 **示例代码：** ```typescript const name = \"张三'; DROP TABLE users; --\"; const rows = await sql`SELECT * FROM users WHERE name = ${name}`; // 安全，无注入风险 ``` 8. 最佳实践总结 - 查询（SELECT）：可直接在 Server Component 里做，页面渲染时查库。 - 插入/更新/删除：推荐通过 [Server Action](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions) 或 API Route，实现安全的“提交入口”。 - 千万不要把“有副作用的操作”（如插入/更新/删除）混在页面渲染逻辑里，以免重复执行。 - 参考 - [Next.js 官方文档：数据获取](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching) - [postgres.js 官方文档](https://github.com/porsager/postgres) ##"},{"id":"v-53a116b4#next-js-url-查询参数结合服务端实现搜索和分页","path":"/project/nextjs.html#next-js-url-查询参数结合服务端实现搜索和分页","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js URL 查询参数结合服务端实现搜索和分页","text":"Next.js URL 查询参数结合服务端实现搜索和分页 **1. 三大核心 API 钩子的作用** - 1.1 useSearchParams - **作用**：用于在客户端组件中访问和操作当前 URL 的查询参数（search params）。 - **典型用法**：获取如 `?query=xxx&page=2` 这样的参数，并据此更新组件数据或 UI。 - **适用场景**：需要读取或响应 URL 查询参数变化的客户端组件，如搜索框、分页器等。 - 1.2 usePathname - **作用**：获取当前页面的路径名（不含查询参数），如 `/dashboard/invoices`。 - **典型用法**：搭配 useSearchParams，拼接更新后的完整 URL。 - **适用场景**：需要生成新 URL 或实现前端跳转时，确保路径正确。 - 1.3 useRouter - **作用**：提供客户端导航能力，允许在不刷新页面的情况下，编程式地跳转/替换 URL（如使用 replace 或 push 方法）。 - **典型用法**：用户输入后，动态更新 URL 查询参数，并自动发起页面数据的刷新。 - **适用场景**：如搜索、分页等用户行为发生后，自动同步 URL，触发相关数据刷新。 --- **2. 为什么要使用 URL 查询参数实现搜索和分页？** - **URL 可分享可收藏**：用户可以复制/收藏包含当前搜索或分页状态的完整 URL，历史状态易于恢复和分享。 - **服务器端渲染友好**：服务端可以直接根据 URL 参数渲染初始内容，无需依赖客户端状态，使 SSR 更加自然强大。 - **便于统计和分析**：URL 中有参数，便于埋点、分析、追踪用户行为。 - **状态与 UI 同步**：页面刷新、后退/前进、收藏、外链跳转等场景下，状态都能自动恢复。 --- **3. 实现步骤概览** - 3.1 搜索功能 1. **捕获输入**：在 `<Search />` 客户端组件中，监听输入框变化。 2. **更新 URL**：使用 useRouter + usePathname + useSearchParams，构造新的 URL 查询参数（如 `?query=xxx`），调用 replace 方法更新 URL。 3. **输入与 URL 同步**：通过 `defaultValue={searchParams.get('query')}`，确保输入框内容和 URL 状态一致。 4. **服务端获取数据**：在服务端组件（如 `<Table />`）中，通过 props 传递的 searchParams 获取查询参数，调用数据库/接口返回匹配数据。 - 3.2 分页功能 1. **分页参数获取**：通过 useSearchParams 获取当前页码（如 `page=2`），服务端组件据此查询数据。 2. **生成分页 URL**：分页按钮用 createPageURL 方法，基于当前 searchParams 和 pathname 拼接各分页跳转的完整 URL。 3. **跳转与数据刷新**：用户点击分页按钮，跳转到带有新页码的 URL；服务端据此返回对应数据。 --- **4. 代码片段说明** - 搜索组件核心逻辑（/app/ui/search.tsx） ```tsx \"use client\"; import { useSearchParams, usePathname, useRouter } from \"next/navigation\"; import { useDebouncedCallback } from \"use-debounce\"; export default function Search({ placeholder }) { const searchParams = useSearchParams(); const { replace } = useRouter(); const pathname = usePathname(); // 防抖，避免每次输入都发送请求 const handleSearch = useDebouncedCallback((term) => { const params = new URLSearchParams(searchParams); params.set(\"page\", \"1\"); // 搜索时重置页码 if (term) { params.set(\"query\", term); } else { params.delete(\"query\"); } replace(`${pathname}?${params.toString()}`); }, 300); return ( <input placeholder={placeholder} onChange={(e) => handleSearch(e.target.value)} defaultValue={searchParams.get(\"query\")?.toString()} /> ); } ``` - 分页组件核心逻辑（/app/ui/invoices/pagination.tsx） ```tsx \"use client\"; import { usePathname, useSearchParams } from \"next/navigation\"; export default function Pagination({ totalPages }) { const pathname = usePathname(); const searchParams = useSearchParams(); const currentPage = Number(searchParams.get(\"page\")) || 1; // 生成跳转到指定页的 URL const createPageURL = (pageNumber) => { const params = new URLSearchParams(searchParams); params.set(\"page\", pageNumber.toString()); return `${pathname}?${params.toString()}`; }; // ...分页按钮渲染 } ``` --- **5. 何时用 useSearchParams，何时用 searchParams prop？** - **客户端组件**：如 `<Search />`、`<Pagination />`，用 useSearchParams 读取和响应 URL 参数变化。 - **服务器端组件**：如 `<Table />`，通过页面组件传入的 searchParams prop 获取参数，传递给数据查询逻辑。 - **最佳实践**：客户端钩子只在客户端组件使用，避免不必要的服务端渲染和 hydration。 --- **6. 防抖（Debounce）优化** - **作用**：防止每次输入都发请求，减少数据库压力。用户停止输入一段时间后才触发查询。 - **实现**：use-debounce 库的 useDebouncedCallback。 --- [参考：Next.js 官方文档：Routing and Navigation](https://nextjs.org/docs/app/api-reference/functions/use-search-params) --- ##"},{"id":"v-53a116b4#next-js-server-actions","path":"/project/nextjs.html#next-js-server-actions","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js Server Actions","text":"Next.js Server Actions 1. Server Actions 的核心概念 - Server Actions 是 React 和 Next.js 的新特性，允许你在服务端直接写和执行异步操作（如数据库增删改查），**无需单独写 API 路由**。 - 优势：简化数据变更流程、提升安全性（自动作用于服务端，防止敏感逻辑泄漏到客户端）、更易维护。 - 关键技术点：加密闭包、严格输入检查、错误哈希等提升安全。 **示例：定义 Server Action** ```tsx // app/dashboard/invoices/create/page.tsx export default function Page() { async function create(formData: FormData) { \"use server\"; // 这里可以直接访问数据库等服务端资源 // 比如 await db.insert(...) } return <form action={create}>...</form>; } ``` 2. 表单与 Server Actions 的集成方式 - 直接在 `<form>` 的 action 属性中传入 server action 函数。 - 提交表单时，表单数据（FormData）自动传递给 server action。 - 即使前端 JS 未加载（如极端弱网或禁用 JS），表单也能正常提交（渐进增强/Progressive Enhancement）。 **示例：表单 action 绑定 Server Action** ```tsx function Page() { async function create(formData: FormData) { \"use server\"; // 处理逻辑 } return ( <form action={create}> <input name=\"name\" /> <button type=\"submit\">提交</button> </form> ); } ``` 3. Server Actions 与缓存的集成 - Next.js 的 Server Actions 与页面/数据缓存机制（如 ISR、SSG）无缝结合。 - 提供 `revalidatePath` 和 `revalidateTag` 等 API，允许在数据变更后主动刷新指定页面或标签的缓存，确保用户始终看到最新数据。 **示例：刷新缓存** ```typescript import { revalidatePath } from \"next/cache\"; import { redirect } from \"next/navigation\"; export async function createInvoice(formData: FormData) { // ...执行数据库操作 revalidatePath(\"/dashboard/invoices\"); // 刷新发票列表页面缓存 redirect(\"/dashboard/invoices\"); // 操作后重定向 } ``` 4. 创建发票的完整流程示例 - 1. 新建路由和表单页面，如 `/dashboard/invoices/create/page.tsx`，表单 action 绑定 `createInvoice`。 - 2. Server Action 用 `\"use server\"` 标记，参数类型通常为 `FormData`。 - 3. 用 `formData.get(\"字段名\")` 获取表单输入，并用 Zod 校验数据和自动类型转换。 - 4. 数据入库时建议金额用“美分”存储，防止浮点误差。 - 5. 操作成功后刷新缓存并重定向。 **示例代码：actions.ts** ```typescript import { z } from \"zod\"; import { revalidatePath } from \"next/cache\"; import { redirect } from \"next/navigation\"; import postgres from \"postgres\"; const sql = postgres(process.env.POSTGRES_URL!, { ssl: \"require\" }); const FormSchema = z.object({ id: z.string(), customerId: z.string(), amount: z.coerce.number(), status: z.enum([\"pending\", \"paid\"]), date: z.string(), }); const CreateInvoice = FormSchema.omit({ id: true, date: true }); export async function createInvoice(formData: FormData) { const { customerId, amount, status } = CreateInvoice.parse({ customerId: formData.get(\"customerId\"), amount: formData.get(\"amount\"), status: formData.get(\"status\"), }); const amountInCents = amount * 100; const date = new Date().toISOString().split(\"T\")[0]; await sql`INSERT INTO invoices (customer_id, amount, status, date) VALUES (${customerId}, ${amountInCents}, ${status}, ${date})`; revalidatePath(\"/dashboard/invoices\"); redirect(\"/dashboard/invoices\"); } ``` 5. 动态路由与发票编辑场景 - 动态路由通过 `[id]` 目录实现，例如 `/dashboard/invoices/[id]/edit/page.tsx`。 - 页面组件通过 `props.params` 拿到动态参数 id。 - 编辑流程：跳转到编辑页、服务端获取发票数据、表单预填充、提交后调用 Server Action 更新数据并刷新缓存。 - 主键建议使用 UUID 保证安全与唯一性（防止被枚举攻击）。 **示例：动态路由页面** ```tsx // app/dashboard/invoices/[id]/edit/page.tsx export default async function EditPage({ params }) { const invoice = await fetchInvoiceById(params.id); return ( <form action={updateInvoice}> <input name=\"amount\" defaultValue={invoice.amount / 100} /> {/* ...其他字段... */} <button type=\"submit\">保存</button> </form> ); } ``` 6. FormData 的类型安全与最佳实践 - `FormData.get()` 返回值都是字符串或 `null`，需要类型转换。 - 推荐用 Zod（或 Yup、Joi 等）统一做服务端类型校验和转换，避免类型漏洞、脏数据入库。 - 例如 `.coerce.number()` 可以自动把字符串转成数字。 **示例：Zod 类型转换** ```typescript const schema = z.object({ amount: z.coerce.number().gt(0, \"金额必须大于0\"), }); schema.parse({ amount: \"123\" }); // 自动转为数字 123 ``` 7. revalidatePath API 的作用 - 用于手动刷新某个页面（或路由段）的缓存，保证用户总能看到最新数据。 - 增、删、改等操作完成后应调用，避免页面展示过期内容。 **示例：刷新缓存** ```typescript revalidatePath(\"/dashboard/invoices\"); // 刷新发票列表 ``` 8. 实践建议与总结 - Server Actions 极大简化全栈开发流程，提升安全性和开发效率。 - 表单 action 与 Server Actions 松耦合，支持无 JS/弱网场景。 - 后端统一用 Zod 校验保证类型安全和数据一致性。 - 动态路由让编辑、详情等页面实现更灵活。 - revalidatePath/redirect 等 API 让数据与 UI 始终同步。 - 推荐阅读： - [Next.js 官方文档：Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions) - [Zod 文档](https://zod.dev/) - [FormData Web API](https://developer.mozilla.org/en-US/docs/Web/API/FormData) ##"},{"id":"v-53a116b4#next-js-zod-表单校验","path":"/project/nextjs.html#next-js-zod-表单校验","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js + Zod 表单校验","text":"Next.js + Zod 表单校验 **1. 为什么要用 Zod 管理表单校验？** - **原有问题**：传统的 if/else 手写校验容易出错、难以维护、代码分散。 - **Zod 优势**：声明式、类型安全、代码复用、前后端一致的数据结构。 --- **2. 校验规则单独抽离：schemas.ts** - **目的**：将所有表单字段的校验规则集中在一个文件中，便于维护和复用。 - **做法**： - 用 zod 的 API 定义一个 InvoiceSchema，详细规定每个字段的类型、必填、范围等。 - 利用 `omit` 方法再派生出 CreateInvoice（用于新建时不需要 id、date 字段）。 **示例代码：** ```typescript import { z } from \"zod\"; export const InvoiceSchema = z.object({ id: z.string(), customerId: z .string({ invalid_type_error: \"请必须选择一个客户。\", }) .nonempty({ message: \"请选择一个客户，不能为空。\", }), amount: z.coerce.number().gt(0, { message: \"请输入一个大于 $0 的金额。\" }), status: z.enum([\"pending\", \"paid\"], { invalid_type_error: \"请选择一个发票状态。\", }), date: z.string(), }); export const CreateInvoice = InvoiceSchema.omit({ id: true, date: true }); ``` - **优势**：每当涉及表单字段变动，只需维护一个 Schema 文件即可。 --- **3. Server Action 使用 Zod 简化校验逻辑** - **旧写法**：大量 if/else 判断、手动组装错误对象。 - **新写法**：用 `CreateInvoice.safeParse(formData)` 一行搞定全部校验，错误信息自动结构化。 **示例代码片段：** ```typescript const validatedFields = CreateInvoice.safeParse({ customerId: formData.get(\"customerId\"), amount: formData.get(\"amount\"), status: formData.get(\"status\"), }); if (!validatedFields.success) { return { errors: validatedFields.error.flatten().fieldErrors, message: \"表单数据无效，请修正后重试。\", }; } ``` - **优点**：类型安全，校验更健壮，逻辑更清晰，FormState 结构与前端完全契合。 --- **4. 前端表单组件无缝对接** - **优势**：前端只关心 `state.errors`，不关心错误信息的生成方式。 - **做法**： - 使用 `useActionState` 连接 server action（如 createInvoice）。 - 利用 antd 的表单组件和 `state.errors`，自动展示后端返回的校验失败信息。 **伪代码结构：** ```tsx const [state, dispatch] = useActionState(createInvoice, initialState); <Form action={dispatch}> <Form.Item help={state.errors?.customerId?.join(', ')} ...> {/* ... */} </Form.Item> {/* ... 其他字段 ... */} </Form> ``` - **好处**：前后端数据契约一致，前端组件无需为校验重构代码，体验平滑。 --- **5. 总结亮点** - **逻辑分层**：校验逻辑与业务逻辑彻底分离，易读易维护。 - **后端健壮**：Zod 提供更丰富的边界检查，避免遗漏。 - **代码简洁**：大量冗余 if/else 被简化。 - **前端无感知**：错误结构保持一致，前端代码不需变动。 - **最佳实践**：契合现代全栈开发理念，前后端通过类型数据契约对齐。 --- **6. 推荐实践** - 复杂表单都建议用 Zod 这样的 Schema 管理校验逻辑。 - 所有的错误对象结构应与前端约定一致，方便组件复用。 - 以后扩展表单字段或修改规则只需维护 schema 一处。 --- ##"},{"id":"v-53a116b4#next-js-错误处理机制","path":"/project/nextjs.html#next-js-错误处理机制","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Next.js 错误处理机制","text":"Next.js 错误处理机制 **1. 服务器操作中的异常处理（try/catch）** 在 Next.js 的服务器端操作（如数据库 CRUD）中，合理使用 `try/catch` 可以帮助我们优雅地处理运行时错误。 - **建议**：所有可能抛出异常的操作都应包裹在 `try/catch` 中。 - 在 `catch` 里可以返回友好提示，或者根据业务需求执行特定的补救措施。 - **注意**：`redirect()` 之类会直接抛出异常的函数，不能放在 `try` 块内，否则会被 `catch` 捕获，导致流程异常。 **2. 路由级别的错误 UI（error.tsx）** Next.js 支持为每个路由段（segment）自定义一个 `error.tsx` 文件，用于捕获当前段下所有未处理的异常。 - `error.tsx` 必须是客户端组件（记得加 `'use client'`）。 - 该组件接收 `error`（异常对象）和 `reset`（恢复函数）两个参数。 - 可以在此自定义用户友好的错误提示界面，并提供重试按钮等交互。 - 这样即使后台出错，用户也不会看到杂乱的报错，而是一个友好的页面。 **3. 针对 404 场景的处理（notFound 和 not-found.tsx）** 对于不存在的资源（比如找不到某个发票），Next.js 推荐用 `notFound()` 函数主动抛出 404。 - 在服务端数据获取逻辑中判断资源是否存在，不存在时调用 `notFound()`。 - `notFound()` 被触发时，会自动渲染同级目录下的 `not-found.tsx` 文件。 - 通过自定义 `not-found.tsx`，可以为用户展示自定义的 404 页面和返回按钮等。 **4. error.tsx 与 not-found.tsx 的优先级** - `not-found.tsx` 的优先级高于 `error.tsx`。如果资源不存在并调用了 `notFound()`，将渲染 404 页面而不是通用错误页。 - 通常建议： - 资源不存在时用 `notFound()` 和 `not-found.tsx` - 其他服务器异常用 `error.tsx` **5. 实际开发建议** - 服务器操作时务必做好异常捕获，给前端返回明确的错误提示。 - 为核心路由（如涉及数据操作的页面）都加上 `error.tsx` 和 `not-found.tsx`。 - 错误 UI 设计应考虑用户体验，如“重试”或“返回首页”等操作按钮。 - 可以在 `error.tsx` 里加日志上报，方便监控线上错误。 **6. 相关文档推荐** - [Next.js Error Handling 官方文档](https://nextjs.org/docs/app/building-your-application/routing/error-handling) - [error.tsx API 参考](https://nextjs.org/docs/app/api-reference/file-conventions/error) - [notFound() API 参考](https://nextjs.org/docs/app/api-reference/functions/notfound) - [not-found.tsx API 参考](https://nextjs.org/docs/app/api-reference/file-conventions/not-found) --- ##"},{"id":"v-53a116b4#zod-校验库简介","path":"/project/nextjs.html#zod-校验库简介","pageTitle":"nextjs - 15 版本及以上","headerTitle":"Zod 校验库简介","text":"Zod 校验库简介 **1. 什么是 Zod？** Zod 是一个 TypeScript 优先的**模式校验（Schema Validation）库**，用于在前端或后端代码中对数据进行结构和类型的声明式校验。它简单、灵活、与 TypeScript 深度集成，常用于表单校验、API 入参校验、数据转换等场景。 --- **2. Zod 的主要特点** - **TypeScript 优先**：Zod 的 schema 自动为你推导出类型，类型和校验规则始终一致。 - **声明式 API**：用链式语法声明每个字段的类型、校验规则和错误信息，易读易维护。 - **无第三方依赖**：纯 TypeScript 实现，轻量安全。 - **可组合**：支持对象、数组、枚举、联合类型、嵌套等复杂数据结构的校验。 - **安全转换**：支持类型转换（如字符串转数字）。 --- **3. 基本用法示例** - 定义 Schema ```typescript import { z } from \"zod\"; const UserSchema = z.object({ name: z.string().min(1, \"姓名不能为空\"), age: z.number().int().nonnegative(), email: z.string().email(), }); ``` - 校验数据 ```typescript // 校验成功 const result = UserSchema.safeParse({ name: \"张三\", age: 25, email: \"zhangsan@example.com\", }); // result.success === true // 校验失败 const bad = UserSchema.safeParse({ name: \"\", age: -3, email: \"not-an-email\", }); // bad.success === false，bad.error 包含详细错误 ``` - 提取类型 ```typescript type User = z.infer<typeof UserSchema>; ``` --- **4. 进阶特性** - **嵌套对象/数组**：支持任意层级的嵌套校验。 - **枚举与联合类型**：如 `z.enum(['A', 'B'])`、`z.union([z.string(), z.number()])` - **自定义校验**：用 `.refine()` 或 `.superRefine()` 定制更复杂的校验逻辑。 - **类型转换**：如 `z.coerce.number()` 自动把字符串转为数字。 - **错误信息定制**：每个规则都可自定义报错提示。 --- **5. 常见应用场景** - React/Vue/Next.js 等前端表单校验 - Node.js/Express/Koa/Fastify 等后端接口参数校验 - API 数据解析与类型安全 - 数据迁移、脚本、配置文件校验 --- **6. Zod 与其他校验库对比** | 特性 | Zod | Yup | Joi | | ---------- | -------- | ----------- | -------- | | TypeScript | 原生支持 | 部分支持 | 无 | | 体积 | 小 | 较小 | 较大 | | API 风格 | 链式声明 | 链式声明 | 链式声明 | | 类型推导 | 自动 | 需额外配置 | 无 | | 依赖 | 无 | 依赖 lodash | 依赖 | --- **7. 官方文档** - [Zod 官方文档](https://zod.dev/) - [GitHub 仓库](https://github.com/colinhacks/zod) --- ##"},{"id":"v-53a116b4#如何使用-next-image-组件","path":"/project/nextjs.html#如何使用-next-image-组件","pageTitle":"nextjs - 15 版本及以上","headerTitle":"如何使用 next/image 组件","text":"如何使用 next/image 组件 [next/image 官方文档](https://nextjs.org/docs/app/api-reference/components/image) 1. 基本用法 - `next/image` 是 Next.js 的内置图片优化组件，自动实现懒加载、响应式图片、图片格式优化等。 - 必须传递 `src`（图片路径）、`alt`（图片描述）、`width` 和 `height`（图片尺寸，单位 px）。 **示例代码：** ```jsx import Image from \"next/image\"; export default function MyComponent() { return ( <Image src=\"/images/example.jpg\" // 本地 public 下图片或远程图片地址 alt=\"描述文本\" width={500} height={300} /> ); } ``` - `src`：支持本地 `/public` 下路径或远程图片。 - `alt`：无障碍图片描述，必填。 - `width`、`height`：必须指定，否则图片不会正常显示。 2. 常用属性 - `layout`：图片布局方式。常见值： - `\"fixed\"`（默认）：固定宽高。 - `\"responsive\"`：宽度自适应父容器，高度等比缩放。 - `\"fill\"`：填满父容器，需配合父容器 `position: relative`。 - `priority`：优先加载图片（如首屏大图）。 - `placeholder`：占位类型，常用 `\"blur\"` 实现模糊占位。 - `blurDataURL`：自定义模糊图片的 url，可用小图或 base64。 - `lodaer`: 图片加载器，可自定义图片加载方式。 - 自定义 loader 后，图片不会再走 Next.js 内置的图片优化（即不会经过 /\\_next/image 路径），而是直接用你生成的 URL。 - 仅当你有自定义图片服务需求时才需要自定义 loader，普通项目建议使用 Next.js 默认优化。 ```tsx import Image from \"next/image\"; const customLoad = ({ src }) => src; const MyImage = (props) => { return <Image {...props} loader={customLoad} />; }; MyImage.displayName = \"Image\"; export default MyImage; ``` - `displayName`: 用于在 React DevTools 中显示组件名称。 **示例代码：** ```jsx <Image src=\"/images/example.jpg\" alt=\"示例图片\" width={500} height={300} placeholder=\"blur\" blurDataURL=\"/images/blur.jpg\" /> ``` 3. 远程图片用法 - 需要在 `next.config.js` 配置允许的远程图片域名。 **配置示例：** ```js // next.config.js module.exports = { images: { domains: [\"example.com\"], }, }; ``` **使用示例：** ```jsx <Image src=\"https://example.com/pic.jpg\" alt=\"远程图片\" width={400} height={200} /> ``` 4. 响应式图片 - 使用 `layout=\"responsive\"`，图片宽度适应父容器，高度按比例缩放。 **示例代码：** ```jsx <div style={{ width: 300 }}> <Image src=\"/images/photo.jpg\" alt=\"响应式图片\" width={1200} height={800} layout=\"responsive\" /> </div> ``` 5. 占位模糊效果 - 用于提升大图首屏体验，先展示模糊占位。 **示例代码：** ```jsx <Image src=\"/images/sample.jpg\" alt=\"模糊占位图片\" width={800} height={400} placeholder=\"blur\" blurDataURL=\"/images/sample-blur.jpg\" // 可用小尺寸或 base64 图片 /> ``` 6. 注意事项 - `width` 和 `height` 必须指定，否则图片不显示。 - 本地图片路径基于 `/public` 目录。 - 远程图片需配置 `images.domains`。 - `layout=\"fill\"` 时父元素需 `position: relative`，且不需再指定 `width`/`height`。 7. 参考 - [Next.js 官方文档：Image 组件](https://nextjs.org/docs/app/api-reference/components/image) ##"},{"id":"v-53a116b4#nextjs-中-userouter-错误引入","path":"/project/nextjs.html#nextjs-中-userouter-错误引入","pageTitle":"nextjs - 15 版本及以上","headerTitle":"nextjs 中 useRouter 错误引入","text":"nextjs 中 useRouter 错误引入 这个报错 `Error: NextRouter was not mounted.` 通常发生在 Next.js 应用中，当你尝试在不正确的上下文中使用 `useRouter` Hook 时 。 根据你的文件路径 `src/app/register/page.jsx`，你的项目正在使用 Next.js 的 **App Router** 。 然而，在你的代码中，你导入 `useRouter` 的方式是： ``` import { useRouter } from \"next/router\"; ``` 这个导入路径是用于 **Pages Router** 的 。 **问题原因：** 你在 App Router 的页面 (`src/app/...`) 中使用了 Pages Router 的 `useRouter` Hook。这两个路由系统有不同的 API 。 **解决方法：** 你需要将 `useRouter` 的导入路径更改为 App Router 对应的 `next/navigation` 。 请将你的代码中的导入语句修改为： JavaScript ``` import { useRouter } from \"next/navigation\"; ``` ## Ant Design 静态方法与 React Context 问题 (`<App>` 组件) **日期:** 2025 年 05 月 01 日 **主题:** 理解并解决 Ant Design 警告: `Warning: [antd: Modal] Static function can not consume context like dynamic theme. Please use 'App' component instead.` **受影响的方法:** 主要包括 `Modal.confirm()`, `Modal.info()`, `Modal.success()`, `Modal.error()`, `Modal.warning()`, `message.success()`, `message.error()`, `message.info()`, `message.warning()`, `message.loading()`, `notification.open()` 等静态调用方法。 --- #### 问题描述 当在代码中直接（静态地）调用 `Modal.confirm(...)` 或 `message.success(...)` 这类方法时，浏览器的开发者控制台会出现上述警告。该警告指出这些静态函数无法消费（获取）像动态主题这样的 React Context 信息。 #### 问题根源：静态方法 vs React Context 1. **React Context (上下文):** 这是 React 提供的一种机制，允许数据（例如主题配置、语言设置、用户信息等）在组件树中向下传递，而无需手动地在每一层都传递 props。Ant Design 使用 `<ConfigProvider>` 组件来提供主题、国际化等全局配置的 Context。 2. **静态方法 (Static Methods):**像 `Modal.confirm` 这样的方法是直接在导入的 `Modal` 对象上调用的，而不是在 React 组件树中渲染的某个实例上调用。这些方法的调用发生在触发它们的 React 组件的常规渲染生命周期和上下文之外。 3. **核心矛盾:** 由于这些静态方法在 React 组件实例的上下文之外执行，它们无法“看到”或“访问”由上层 `<ConfigProvider>` 等组件提供的 Context。因此，它们对应用内设置的主题、语言等配置是“无感知”的。 #### 解决方案: `<App />` 组件与 `useApp` Hook 为了解决这个问题，Ant Design v5 版本引入了 `<App />` 组件和 `App.useApp()` 这个 Hook： 1. **`<App />` 组件包裹:** 你需要在应用的根节点附近（通常在 `<ConfigProvider>` 内部）使用 `<App />` 组件包裹你的主要应用内容。这个 `<App />` 组件会创建一个特殊的上下文环境，并在内部管理 `modal`, `message`, `notification` 等服务的实例。 2. **`App.useApp()` Hook:** 在 `<App />` 组件包裹下的**任何子组件**中，可以通过调用 `App.useApp()` 这个 Hook 来获取一个包含 `modal`, `message`, `notification` 实例的对象。这些实例是**能够感知到 Context** 的。 3. **正确用法:** - **第一步:** 在你的根布局文件（如 `layout.jsx`）中，用 `<App>` 包裹你的应用主体。 - **第二步:** 在你需要调用 `Modal`, `message`, `notification` 的**具体组件**中，导入 `App` 并调用 `const { modal, message, notification } = App.useApp();`。 - **第三步:** 将原先的静态调用（如 `Modal.confirm(...)`）替换为通过 Hook 获取到的实例调用（如 `modal.confirm(...)`）。 #### 如果不使用 `<App />` 包裹会怎么样？ 如果你选择不使用 `<App />` 组件包裹应用，或者继续使用静态方法调用，会导致以下后果： 1. **主题样式不一致:** 这是最直接的影响。通过静态方法创建的 `Modal`, `message`, `notification` 组件**无法应用**通过 `<ConfigProvider>` 设置的**动态主题**。例如，当你的应用切换到暗色模式时，这些弹窗或提示可能仍然显示为默认的亮色模式样式，造成界面视觉风格的割裂和不统一。 2. **其他 Context 配置失效:** 虽然动态主题是最典型的例子，但理论上 `<ConfigProvider>` 提供的其他基于 Context 的配置（如国际化语言包影响默认按钮文字、全局组件尺寸等，如果这些配置未来会影响静态方法的话）也可能无法被这些静态组件获取。 3. **持续的控制台警告:** 浏览器开发者工具中会一直显示该警告信息，这表明你的代码实践与 Ant Design 的推荐方式不符，也可能干扰调试。 4. **潜在的未来兼容性问题:** Ant Design 未来可能会更加依赖 Context 机制来配置组件行为。坚持使用旧的静态方法调用方式，在未来升级 antd 版本时，可能会遇到更多难以预料的行为或兼容性问题。 #### 总结 Ant Design 中关于静态方法无法消费 Context 的警告，源于全局静态调用与 React 组件树上下文之间的隔离。使用 `<App />` 组件包裹应用并在具体组件中通过 `App.useApp()` Hook 获取 `modal`, `message`, `notification` 实例，是 antd v5+ 官方推荐的、确保这些全局提示/弹窗能正确继承上下文（尤其是动态主题）的**标准解决方案**。忽略此模式会导致 UI 样式不一致，并可能引发未来的维护和兼容性风险。 ## Next.js + Auth.js 权限控制与登录流程全解 **整体流程与核心原理** 在 Next.js 应用中结合 Auth.js（NextAuth），你可以通过配置 `auth.config.ts`、`auth.ts` 及 `middleware.ts`，实现灵活的页面访问控制。整个流程核心包括： - **路由列表分组**：哪些页面是公开的，哪些需要登录，哪些是认证页面。 - **中间件拦截**：所有页面请求都会被 middleware.ts 拦截，再决定是否放行或重定向。 - **权限判断与角色控制**：通过解密的 JWT（Session Token）携带用户身份与角色，灵活配置权限。 - **登录流程体验优化**：自动带上 callbackUrl，登录成功后回到原目标页。 --- **auth.config.ts 路由权限配置** **目标需求**：未登录用户只能访问页面 A、B，不能访问 C、D、E、F。登录后可访问所有页面。 - 实现思路： 1. **分组路由列表** - `publicRoutes`: 未登录可访问（如 `/public-page-a`, `/public-page-b`） - `protectedRoutes`: 登录才能访问（如 `/dashboard`, `/products`, `/orders`，使用前缀匹配可覆盖子页面） - `authRoutes`: 登录页面本身（如 `/login`），已登录用户访问时应重定向到主页 2. **配置 callbacks.authorized** 逻辑顺序如下： - 若访问受保护路由，未登录则拦截 - 若访问登录页，已登录则重定向到主页 - 其他页面默认放行 ```typescript // auth.config.ts import type { NextAuthConfig } from \"next-auth\"; const publicRoutes = [\"/public-page-a\", \"/public-page-b\"]; const protectedRoutes = [\"/dashboard\", \"/products\", \"/orders\"]; const authRoutes = [\"/login\"]; export const authConfig = { pages: { signIn: \"/login\" }, callbacks: { authorized({ auth, request: { nextUrl } }) { const isLoggedIn = !!auth?.user; const { pathname } = nextUrl; // 受保护路由 const isOnProtectedRoute = protectedRoutes.some((route) => pathname.startsWith(route) ); if (isOnProtectedRoute) return isLoggedIn; // 登录页面 const isOnAuthRoute = authRoutes.some((route) => pathname.startsWith(route) ); if (isOnAuthRoute) { if (isLoggedIn) { // 已登录访问登录页，重定向到 dashboard return Response.redirect(new URL(\"/dashboard\", nextUrl)); } return true; } // 其他（如 publicRoutes），默认放行 return true; }, }, } satisfies NextAuthConfig; ``` --- **middleware.ts 中间件机制详解** - middleware.ts 是什么？如何被执行？ - 它是 Next.js 的“中央保安”，拦截所有页面请求，决定是否放行或重定向 - 通过“名字和位置约定”自动生效：只要在根目录或 `src/` 下有 middleware.ts (或 .js/.mjs)，Next.js 自动识别 - 运行在 Edge Runtime，速度快且离用户近 - 典型代码结构与注释说明： ```typescript // middleware.ts import NextAuth from \"next-auth\"; import { authConfig } from \"./auth.config\"; // 初始化 Auth.js 并导出中间件 export default NextAuth(authConfig).auth; // 配置 matcher 只拦截实际页面请求，静态资源、API 路由等不拦截 export const config = { matcher: [\"/((?!api|_next/static|_next/image|.*\\\\.png$|favicon.ico).*)\"], }; ``` - `matcher` 优化性能，只针对实际页面做权限校验 --- **providers 配置详解** - providers 决定了你支持哪些登录方式。分为两大类： 1. OAuth Provider（如 Google、GitHub） - 只需配置 `clientId`/`clientSecret` - 用户跳转至第三方授权页面，授权后回调到你站点 - 适合无自定义用户体系的场景 ```typescript import Google from \"next-auth/providers/google\"; providers: [ Google({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET, }), ]; ``` 2. Credentials Provider（账号密码登录） - 需自定义 authorize 逻辑（如查库、比对密码） - 适合有自定义用户表/权限设计的场景 ```typescript import Credentials from \"next-auth/providers/credentials\"; providers: [ Credentials({ async authorize(credentials) { // 验证逻辑（查库、比对密码） // 返回 user 对象则登录成功，否则失败 }, }), ]; ``` - 最佳实践： 所有需要用到 Node.js 模块（如数据库、bcrypt）的 provider 配置都放在 `auth.ts`，避免 Edge Runtime 报错。 --- **auth.ts 实例代码逐行详解** ```typescript import NextAuth from \"next-auth\"; import Credentials from \"next-auth/providers/credentials\"; import { authConfig } from \"./auth.config\"; import { z } from \"zod\"; import type { User } from \"@/app/lib/definitions\"; import bcrypt from \"bcrypt\"; import postgres from \"postgres\"; // 建立数据库连接 const sql = postgres(process.env.POSTGRES_URL!, { ssl: \"require\" }); // 查找用户辅助函数 async function getUser(email: string): Promise<User | undefined> { const user = await sql<User[]>`SELECT * FROM users WHERE email=${email}`; return user[0]; } export const { auth, signIn, signOut } = NextAuth({ ...authConfig, providers: [ Credentials({ async authorize(credentials) { // 1. 检查格式 const parsed = z .object({ email: z.string().email(), password: z.string().min(6), }) .safeParse(credentials); if (parsed.success) { const { email, password } = parsed.data; // 2. 查库 const user = await getUser(email); if (!user) return null; // 3. 密码比对 const match = await bcrypt.compare(password, user.password); if (match) return user; } // 4. 验证失败 console.log(\"Invalid credentials\"); return null; }, }), ], }); ``` - **zod**：前端/后端通用的数据校验 - **bcrypt**：密码哈希与比对，保障安全 - **getUser**：数据库查找用户 - **authorize**：整个自定义登录核心 --- **登录表单 callbackUrl 流程解释** **callbackUrl 用于：登录后自动回到原目标页** - 完整流程 1. **用户访问受保护页面**（如 `/dashboard/invoices`），未登录被中间件拦截 2. **中间件重定向到登录页**，自动带上 `?callbackUrl=/dashboard/invoices` 3. **登录表单组件**用 `useSearchParams().get('callbackUrl')` 读取参数，写入 `<input type=\"hidden\" name=\"redirectTo\" value={callbackUrl} />` 4. **表单提交**时，`redirectTo` 字段随表单一起 POST 到后端 Server Action 5. **Server Action（authenticate）** 读取 `redirectTo`，登录后自动 `redirect(redirectTo)` 6. **用户被送回最初想访问的页面** - 代码片段 ```tsx // LoginForm.tsx (核心片段) const searchParams = useSearchParams(); const callbackUrl = searchParams.get(\"callbackUrl\") || \"/dashboard\"; <input type=\"hidden\" name=\"redirectTo\" value={callbackUrl} />; ``` ```typescript // authenticate Server Action export async function authenticate(_, formData: FormData) { await signIn(\"credentials\", formData); // 登录 const redirectTo = formData.get(\"redirectTo\") || \"/dashboard\"; redirect(redirectTo); // 跳转回原页面 } ``` --- **auth 对象的来源与权限配置** - auth 对象来源 1. **用户登录**时，`authorize` 返回 user 对象 2. **user 数据被写入 JWT**（callbacks.jwt），JWT 存在 Cookie 3. **后续请求**中，middleware 解密 JWT 得到 auth 对象，传递给 authorized 回调 - 配置角色权限的完整流程 1. **数据库 user 表**增加 role 字段（如 `admin`/`user`） 2. **authorize 返回的 user**包含 role 3. **callbacks.jwt** 把 role 写进 token 4. **middleware 调用 authorized** 时，auth.user 里就有 role，可用来判断权限 - 示例：仅管理员能访问 /admin，下例中只有 role 为 admin 才能访问 /admin 页面： ```typescript // auth.config.ts export const authConfig = { callbacks: { authorized({ auth, request: { nextUrl } }) { const isLoggedIn = !!auth?.user; const pathname = nextUrl.pathname; if (pathname.startsWith(\"/admin\")) { // 只有 admin 角色放行 return isLoggedIn && auth.user?.role === \"admin\"; } // 其他保护逻辑... return isLoggedIn; }, }, // providers... }; ``` - 类型扩展： 为 TypeScript 类型推断更智能，增加 auth.d.ts： ```typescript // auth.d.ts import \"next-auth\"; declare module \"next-auth\" { interface Session { user: { role: \"admin\" | \"user\" } & DefaultSession[\"user\"]; } interface User { role: \"admin\" | \"user\"; } } declare module \"next-auth/jwt\" { interface JWT { role: \"admin\" | \"user\"; } } ``` --- - 总结 - **auth.config.ts** 管理页面访问规则，逻辑清晰 - **middleware.ts** 自动拦截请求，执行权限判断 - **providers** 决定登录方式，强烈建议放在 auth.ts - **auth.ts** 实现自定义登录逻辑，安全查库与比对密码 - **callbackUrl** 串起“原目标页-登录页-成功后跳转”的完整用户体验 - **auth 对象** 来源于 JWT，权限信息可随用户登录流程动态传递和校验 --- > **参考链接** > > - [Auth.js 官方文档](https://authjs.dev/getting-started/) > - [Next.js Middleware 官方文档](https://nextjs.org/docs/app/building-your-application/routing/middleware) > - [Vercel Next.js Dashboard Example](https://github.com/vercel/nextjs-dashboard) ## 遇到报错 Warning: [antd: compatible] antd v5 support React is 16 ~ 18. see https://u.ant.design/v5-for-19 for compatible. - 警告信息解析 这个警告信息明确指出了 Ant Design v5 官方支持的 React 版本范围是 16.x 到 18.x，而你的项目正在使用的 React 版本可能是 19.x 或更高。这种不兼容性导致 Ant Design 的一些功能（如波浪效果、Modal、Notification、Message 的静态方法）可能无法正常工作。 - 原因分析 Ant Design v5 在设计时，是基于 React 16.x 到 18.x 的 API 规范进行开发的。当 React 19 调整了 react-dom 的导出方法时，Ant Design v5 无法直接使用 ReactDOM.render 方法，从而引发了兼容性问题。 - 解决方案 针对这个问题，推荐使用 Ant Design 官方提供的兼容性包或使用 unstableSetRender 方法(不推荐)。 - 使用兼容性包解决 安装兼容性包： ```bash pnpm add @ant-design/v5-patch-for-react-19 --save ``` 在项目入口导入 ```bash import '@ant-design/v5-patch-for-react-19'; ```"}]