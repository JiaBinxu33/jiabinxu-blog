# 常见面试题

## 基础算法

### 算法实现对象中 url 拼接成数组

```JavaScript
const sidebarMenus = [
  {
    url: "",
    children: [
      {
        url: "/app",
        children: [
          {
            url: "/:id/info",
            children: [],
          },
          {
            url: "/:id/detail",
            children: [
              {
                url: "/group",
              },
            ],
          },
        ],
      },
    ],
  },
];

['', '/app', '/app/:id/info', '/app/:id/detail', '/app/:id/detail/group'];
function fn(arr, currentPath = "") {
  let result = [];
  arr.forEach((element) => {
    const newPath = currentPath + element.url; // 当前节点的新路径
    result.push(newPath); // 无论是否有子节点，都记录当前路径

    // 递归处理子节点，并合并结果(注意：element.children最后一个children中并没有children属性，需要判断是否存在children属性)
    if (element.children && element.children.length > 0) {
      result = result.concat(fn(element.children, newPath));
    }
  });
  return result;
}
```

### 过滤出对象数组中符合条件的数组

- 年龄大于等于 18 岁的用户
- 将用户姓名转换为大写
- 按照年龄升序排序
- 返回处理后的新数组

```JavaScript
  const users = [
    { name: "alice", age: 22 },
    { name: "bob", age: 17 },
    { name: "charlie", age: 19 },
    { name: "david", age: 15 },
  ];
  function fn(users) {
    let result
    result = users.filter(item => {
      return item.age >= 18;
    }).map(item =>{
      return {...item,name:item.name.toUpperCase()}
    }).sort((a,b)=>{
      return a.age - b.age;
    })
    return result;
  }
```

## 常见函数原理

### call()函数的实现

第一个参数为 null 或者 undefined 时，this 指向全局对象 window，值为原始值的指向该原始值的自动包装对象，如 String、Number、Boolean
为了避免函数名与上下文(context)的属性发生冲突，使用 Symbol 类型作为唯一值
将函数作为传入的上下文(context)属性执行
函数执行完成后删除该属性
返回执行结果

call 函数实例：

```JavaScript
var obj = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(obj); // 1
```

- 模拟实现该效果
  试想当调用 call 的时候，把 obj 对象改造成如下：

```JavaScript
    var obj = {
        value: 1,
        bar: function() {
            console.log(this.value)
        }
    };

    obj.bar(); // 1
```

这个时候 this 就指向了 obj,但是也为 obj 添加了一个多余的属性，所以需要删除多余的属性

```JavaScript
// 第一步
obj.fn = bar
// 第二步
obj.fn()
// 第三步
delete obj.fn
```

myCall 函数中的 this 指向 fn，所以把 obj.fn = this（myCall 中的 this）

- 注意
  return，函数可以有返回值
  判断传入参数 context
  可能存在多个参数，解构多个参数

```JavaScript
Function.prototype.myCall = function(context,...args){
    let cxt = context || window;
    //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)
    //新建一个唯一的Symbol变量避免重复
    let func = Symbol()
    cxt[func] = this;
    args = args ? args : []
    //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向
    const res = args.length > 0 ? cxt[func](...args) : cxt[func]();
    //删除该方法，不然会对传入对象造成污染（添加该方法）
    delete cxt[func];
    return res;
}
```

### 实现 PromisealSettled()方法

- 说明：PromisealSettled() 方法返回一个 Promise，该 Promise 在所有给定的 Promise 都已经成功解决(fulfilled) 或拒绝(rejected)之后解决，并返回一个对象数组，每个对象都描述了每个 Promise 的结果。与 Promise 不同的是, Promise.all 一旦遇到错误就会立即拒绝，而 PromisealSettled 则会等待所有 Promise 都结束(无论成功还是失败)

```JavaScript

```

## leetCode 系列

### 无重复字符的最长子串(from leetCode 华为面试题中等难度)

- 示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

- 示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

- 示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

1. 题解 1：暴力解法 双重 for 循环双指针移动，存储结果找到最长字串（O(n²)复杂度）

```JavaScript

var lengthOfLongestSubstring = function (s) {
    if(s.length === 1)return 1;
    let str = "";
    const len = s.length;
    for (let i = 0; i < s.length; i++) {
      let currentStr = s[i];
      for (let j = i + 1; j < len; j++) {
        if (currentStr.indexOf(s[j]) !== -1) {
          break;
        } else {
          currentStr += s[j];
        }
      }
      if (currentStr.length > str.length) str = currentStr;
    }
    return str.length;
};
```

2. 题解 2：使用滑块思想，移动滑块存储当前最长字符串（O(n²)复杂度）

```JavaScript

var lengthOfLongestSubstring = function (s) {
  let str = "";
    let len = s.length;
    if (len === 1) return 1;
    for (let i = 0; i < len; i++) {
      let currentStr = s[i];
      let j = i + 1;
      while (currentStr.indexOf(s[j]) == -1) {
        currentStr += s[j];
        j++;
        // 处理越界
        if (j >= len) {
          j = len - 1;
        }
      }

      if (currentStr.length > str.length) str = currentStr;
      // 如果j走到头了就不用判断了
      if (j === len - 1) {
        break;
      }
      i = s.indexOf(s[j], i);
    }
    return str.length;
};
```

3. 题解 3：使用滑块思想+Set 结构去除重复值（O(n)复杂度）

```JavaScript
var lengthOfLongestSubstring = function (s) {
    let seen = new Set(); // 存储当前窗口的字符
    let left = 0,
      maxLen = 0;
    for (let right = 0; right < s.length; right++) {
      while (seen.has(s[right])) {
        seen.delete(s[left]);
        left++;
      }
      seen.add(s[right]);
      maxLen = maxLen > seen.size ? maxLen : seen.size;
    }
    return maxLen;
};
```
