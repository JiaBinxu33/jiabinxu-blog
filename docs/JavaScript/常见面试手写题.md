# 常见面试题
## 基础算法
### 算法实现对象中url拼接成数组

```JavaScript
const sidebarMenus = [
  {
    url: "",
    children: [
      {
        url: "/app",
        children: [
          {
            url: "/:id/info",
            children: [],
          },
          {
            url: "/:id/detail",
            children: [
              {
                url: "/group",
              },
            ],
          },
        ],
      },
    ],
  },
];

['', '/app', '/app/:id/info', '/app/:id/detail', '/app/:id/detail/group'];
function fn(arr, currentPath = "") {
  let result = [];
  arr.forEach((element) => {
    const newPath = currentPath + element.url; // 当前节点的新路径
    result.push(newPath); // 无论是否有子节点，都记录当前路径

    // 递归处理子节点，并合并结果(注意：element.children最后一个children中并没有children属性，需要判断是否存在children属性)
    if (element.children && element.children.length > 0) {
      result = result.concat(fn(element.children, newPath));
    }
  });
  return result;
}
```
### 过滤出对象数组中符合条件的数组
 -  年龄大于等于18岁的用户
 -	将用户姓名转换为大写
 -	按照年龄升序排序
 -	返回处理后的新数组
```JavaScript
  const users = [
    { name: "alice", age: 22 },
    { name: "bob", age: 17 },
    { name: "charlie", age: 19 },
    { name: "david", age: 15 },
  ];
  function fn(users) {
    let result
    result = users.filter(item => {
      return item.age >= 18;
    }).map(item =>{
      return {...item,name:item.name.toUpperCase()}
    }).sort((a,b)=>{
      return a.age - b.age;
    })
    return result;
  }
  ```



## 常见函数原理
### call()函数的实现

第一个参数为 null 或者 undefined 时，this 指向全局对象 window，值为原始值的指向该原始值的自动包装对象，如 String、Number、Boolean
为了避免函数名与上下文(context)的属性发生冲突，使用 Symbol 类型作为唯一值
将函数作为传入的上下文(context)属性执行
函数执行完成后删除该属性
返回执行结果

```JavaScript
Function.prototype.myCall = function(context,...args){
    let cxt = context || window;
    //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)
    //新建一个唯一的Symbol变量避免重复
    let func = Symbol()
    cxt[func] = this;
    args = args ? args : []
    //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向
    const res = args.length > 0 ? cxt[func](...args) : cxt[func]();
    //删除该方法，不然会对传入对象造成污染（添加该方法）
    delete cxt[func];
    return res;
}
```
### 实现 PromisealSettled()方法
   - 说明：PromisealSettled() 方法返回一个Promise，该 Promise 在所有给定的 Promise都已经成功解决(fulfilled) 或拒绝(rejected)之后解决，并返回一个对象数组，每个对象都描述了每个 Promise 的结果。与Promise不同的是, Promise.all 一旦遇到错误就会立即拒绝，而 PromisealSettled 则会等待所有 Promise都结束(无论成功还是失败)
```JavaScript

```

## leetCode系列
### 无重复字符的最长子串(from leetCode 华为面试题中等难度)

- 示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
- 示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
- 示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

1. 题解1：暴力解法 双重for循环双指针移动，存储结果找到最长字串（O(n²)复杂度）
```JavaScript

var lengthOfLongestSubstring = function (s) {
    if(s.length === 1)return 1;
    let str = "";
    const len = s.length;
    for (let i = 0; i < s.length; i++) {
      let currentStr = s[i];
      for (let j = i + 1; j < len; j++) {
        if (currentStr.indexOf(s[j]) !== -1) {
          break;
        } else {
          currentStr += s[j];
        }
      }
      if (currentStr.length > str.length) str = currentStr;
    }
    return str.length;
};
```
2. 题解2：使用滑块思想，移动滑块存储当前最长字符串（O(n²)复杂度）
```JavaScript

var lengthOfLongestSubstring = function (s) {
  let str = "";
    let len = s.length;
    if (len === 1) return 1;
    for (let i = 0; i < len; i++) {
      let currentStr = s[i];
      let j = i + 1;
      while (currentStr.indexOf(s[j]) == -1) {
        currentStr += s[j];
        j++;
        // 处理越界
        if (j >= len) {
          j = len - 1;
        }
      }

      if (currentStr.length > str.length) str = currentStr;
      // 如果j走到头了就不用判断了
      if (j === len - 1) {
        break;
      }
      i = s.indexOf(s[j], i);
    }
    return str.length;
};
```
3. 题解3：使用滑块思想+Set结构去除重复值（O(n)复杂度）
```JavaScript
var lengthOfLongestSubstring = function (s) {
    let seen = new Set(); // 存储当前窗口的字符
    let left = 0,
      maxLen = 0;
    for (let right = 0; right < s.length; right++) {
      while (seen.has(s[right])) {
        seen.delete(s[left]);
        left++;
      }
      seen.add(s[right]);
      maxLen = maxLen > seen.size ? maxLen : seen.size;
    }
    return maxLen;
};
```