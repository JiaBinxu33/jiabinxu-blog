<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Flutter 综合学习笔记 | 贾滨旭的个人技术博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/jiabinxu-blog/R-C.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <meta name="description" content="前端开发知识体系">
    <meta name="algolia-site-verification" content="8AB7B96237F774B9">
    
    <link rel="preload" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css" as="style"><link rel="preload" href="/jiabinxu-blog/assets/js/app.f81cf313.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/3.bb87b8ff.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/2.180c3171.js" as="script"><link rel="preload" href="/jiabinxu-blog/assets/js/68.23192d8d.js" as="script"><link rel="prefetch" href="/jiabinxu-blog/assets/js/1.c3ce1b0a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/12.3c2a6c83.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/13.3c49b8de.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/14.91b5c8e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/15.ef4b17e3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/16.23f5619b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/17.4bb3669d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/18.664e814e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/19.21ad7801.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/20.d4db7480.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/21.31141967.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/22.8a3f30d9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/23.97e9a047.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/24.78676adc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/25.3050b4ef.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/26.cd43fc60.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/27.f04bcbc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/28.f5223a9d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/29.52241c93.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/30.2e981bab.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/31.d58d5448.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/32.fb28f85b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/33.d10d4810.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/34.f89661dc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/35.a2c20bce.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/36.e39b3fc8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/37.edabae48.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/38.8f37da54.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/39.86e08cd4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/4.3ff6f6b3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/40.42a528d4.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/41.46dbe14a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/42.0b72d4b8.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/43.7d892d86.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/44.164a4f16.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/45.5bc0d409.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/46.82b75b59.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/47.e959a5f5.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/48.cc983ac3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/49.ed08971b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/5.9cbc22ee.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/50.f9457251.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/51.63e6d8ea.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/52.51ebfdbe.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/53.2e948603.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/54.1907287a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/55.2aca8e9e.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/56.53572a11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/57.6c8d55a3.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/58.7c01df11.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/59.1df3a578.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/6.7cbe58bc.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/60.bf31f66a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/61.f2feff3d.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/62.d36efdc6.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/63.824240b9.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/64.6e5633db.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/65.0bc9c8bd.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/66.b03cfd91.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/67.3a221345.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/69.e15e8a6b.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/7.942695b2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/70.d4fc17a1.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/71.bdb98294.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/72.5b17ac84.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/73.3030d7e2.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/74.3329104a.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/8.c9879746.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/9.684a4798.js"><link rel="prefetch" href="/jiabinxu-blog/assets/js/vendors~docsearch.771dd409.js">
    <link rel="stylesheet" href="/jiabinxu-blog/assets/css/0.styles.6e2e750c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiabinxu-blog/" class="home-link router-link-active"><img src="/jiabinxu-blog/R-C.png" alt="贾滨旭的个人技术博客" class="logo"> <span class="site-name can-hide">贾滨旭的个人技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" placeholder="搜索..." autocomplete="off" spellcheck="false" value="" style="background-image:url(/jiabinxu-blog/search.svg);"> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/jiabinxu-blog/Html+Css/" class="nav-link">
  Html+Css
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/handwriting-code/" class="nav-link">
  常见面试手写题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/scenario-questions/" class="nav-link">
  常见面试场景题
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/JavaScript/javascript-core-objects/" class="nav-link">
  JavaScript核心对象
</a></li></ul></div></div><div class="nav-item"><a href="/jiabinxu-blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Hooks" class="dropdown-title"><span class="title">Hooks</span> <span class="arrow down"></span></button> <button type="button" aria-label="Hooks" class="mobile-dropdown-title"><span class="title">Hooks</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useState/" class="nav-link">
  useState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useEffect/" class="nav-link">
  useEffect
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useRef/" class="nav-link">
  useRef
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useContext/" class="nav-link">
  useContext
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemo/" class="nav-link">
  useMemo
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useCallback/" class="nav-link">
  useCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useMemoVSuseCallback/" class="nav-link">
  useMemoVSuseCallback
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useReducer/" class="nav-link">
  useReducer
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useSyncExternalStore/" class="nav-link">
  useSyncExternalStore
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useActionState/" class="nav-link">
  useActionState
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/React/Hooks/useOptimistic/" class="nav-link">
  useOptimistic
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目实战" class="dropdown-title"><span class="title">项目实战</span> <span class="arrow down"></span></button> <button type="button" aria-label="项目实战" class="mobile-dropdown-title"><span class="title">项目实战</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs/" class="nav-link">
  nextjs
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/deploy/" class="nav-link">
  前端部署
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/fileUpload/" class="nav-link">
  大文件上传
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/macOS_Guide/" class="nav-link">
  macOS指南
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/popular-libraries/" class="nav-link">
  常用库
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-i18n/" class="nav-link">
  Next.js国际化方案
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-auth-refresh/" class="nav-link">
  Next.js双token无感刷新
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/nextjs-dir/" class="nav-link">
  Next.js目录深入解读
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter-config/" class="nav-link">
  flutter环境配置
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-item"><!----> <a href="/jiabinxu-blog/project/chrome-dev-tools/" class="nav-link">
  Chrome调试工具
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Flutter 综合学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiabinxu-blog/project/flutter.html#_1-flutter-核心基础" class="sidebar-link">1. Flutter 核心基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#flutter-的项目入口-lib-main-dart" class="sidebar-link">Flutter 的项目入口：lib/main.dart</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#核心理念-一切皆组件-everything-is-a-widget" class="sidebar-link">核心理念：一切皆组件 (Everything is a Widget)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#override-到底是什么意思" class="sidebar-link">@override 到底是什么意思？</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#dart-命名规范与-下划线" class="sidebar-link">Dart 命名规范与 _ (下划线)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#final-的意思" class="sidebar-link">final 的意思</a></li></ul></li><li><a href="/jiabinxu-blog/project/flutter.html#_2-布局与样式-styling" class="sidebar-link">2. 布局与样式 (Styling)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#safearea-不被状态栏遮挡的安全区域" class="sidebar-link">SafeArea：不被状态栏遮挡的安全区域</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#添加样式-styling" class="sidebar-link">添加样式 (Styling)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#尺寸单位全解析" class="sidebar-link">尺寸单位全解析</a></li></ul></li><li><a href="/jiabinxu-blog/project/flutter.html#_3-路由与导航-navigation" class="sidebar-link">3. 路由与导航 (Navigation)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#基本路由跳转" class="sidebar-link">基本路由跳转</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#路由封装-进阶" class="sidebar-link">路由封装（进阶）</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#页面传值的两种核心方式" class="sidebar-link">页面传值的两种核心方式</a></li></ul></li><li><a href="/jiabinxu-blog/project/flutter.html#_4-状态管理-state-management" class="sidebar-link">4. 状态管理 (State Management)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#level-1-本地状态-local-state-与-setstate" class="sidebar-link">Level 1: 本地状态 (Local State) 与 setState</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#level-2-应用-全局状态-app-state-与-provider" class="sidebar-link">Level 2: 应用/全局状态 (App State) 与 Provider</a></li></ul></li><li><a href="/jiabinxu-blog/project/flutter.html#_5-异步编程-async" class="sidebar-link">5. 异步编程 (Async)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#future、async-和-await" class="sidebar-link">Future、async 和 await</a></li></ul></li><li><a href="/jiabinxu-blog/project/flutter.html#_6-dart-进阶与包管理" class="sidebar-link">6. Dart 进阶与包管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#static-静态成员详解" class="sidebar-link">static 静态成员详解</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#var-类型推断-vs-dio-显式类型" class="sidebar-link">var (类型推断) vs. Dio (显式类型)</a></li><li class="sidebar-sub-header"><a href="/jiabinxu-blog/project/flutter.html#包管理-pub-dev" class="sidebar-link">包管理 (pub.dev)</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="flutter-综合学习笔记"><a href="#flutter-综合学习笔记" class="header-anchor">#</a> Flutter 综合学习笔记</h1> <p>这是一份根据前三天学习和实践整理的综合笔记，旨在帮助理解 Flutter 的核心概念，从基础入门到状态管理。</p> <h2 id="_1-flutter-核心基础"><a href="#_1-flutter-核心基础" class="header-anchor">#</a> 1. Flutter 核心基础</h2> <h3 id="flutter-的项目入口-lib-main-dart"><a href="#flutter-的项目入口-lib-main-dart" class="header-anchor">#</a> Flutter 的项目入口：<code>lib/main.dart</code></h3> <p>每个 Flutter 应用程序的执行都始于 <code>lib/main.dart</code> 文件，该文件是程序的指定入口点。</p> <ul><li><strong>lib 目录</strong>: 此目录是项目的核心，作为几乎所有 Dart 源代码的主要存储库。</li> <li><strong>main.dart 文件</strong>: 这是应用的<strong>主入口文件</strong>。操作系统（无论是安卓、iOS还是Web）启动您的应用时，第一个执行的就是这个文件里的 <code>main()</code> 函数。</li> <li><strong>main() 函数</strong>: 这是程序的起点。在这个函数里，我们通常会调用 <code>runApp()</code> 函数。</li></ul> <p><strong>代码示例 (lib/main.dart):</strong></p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'package:flutter/material.dart'</span></span><span class="token punctuation">;</span>
<span class="token comment">// ... 其他导入</span>

<span class="token comment">// 程序的入口函数</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// runApp() 告诉 Flutter 运行哪个组件作为应用的根</span>
  <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// MyApp 就是应用的根组件</span>
<span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="核心理念-一切皆组件-everything-is-a-widget"><a href="#核心理念-一切皆组件-everything-is-a-widget" class="header-anchor">#</a> 核心理念：一切皆组件 (Everything is a Widget)</h3> <p>这是您需要记住的最重要的一句话。在 Flutter 中，您看到的<strong>任何东西</strong>都是一个“组件”（Widget），或者由更小的组件组合而成。</p> <ul><li>一个按钮？是 <code>ElevatedButton</code> 组件。</li> <li>一行文字？是 <code>Text</code> 组件。</li> <li>甚至连页面的整体布局（比如居中 <code>Center</code>、按行排列 <code>Row</code>、按列排列 <code>Column</code>），以及看不见的内边距 <code>Padding</code>，都是组件。</li> <li><code>Scaffold</code> 是一个搭建页面的<strong>脚手架组件</strong>。</li></ul> <h3 id="override-到底是什么意思"><a href="#override-到底是什么意思" class="header-anchor">#</a> <code>@override</code> 到底是什么意思？</h3> <p><code>@override</code> 是一个“注解”，意思是：“我正在<strong>重写</strong>父类中的同名方法”。</p> <ul><li><strong>背景</strong>: 您的 <code>_HomePageState</code> 继承了 <code>State&lt;HomePage&gt;</code>。<code>State</code> 类本身已经定义了一个叫做 <code>build</code> 的方法。</li> <li><strong>作用</strong>: 您的 <code>_HomePageState</code> 必须提供一个具体的 <code>build</code> 方法来描述页面内容。<code>@override</code> 就在这里起作用，它告诉编译器和阅读代码的人：“我这里的 <code>build</code> 方法是在重写父类 <code>State</code> 的 <code>build</code> 方法，不是我自己随便创建的新方法。”</li> <li><strong>好处</strong>: 1. 代码更清晰。2. 安全检查（拼写错误会报错）。</li></ul> <p><strong>代码示例 (lib/pages/home_page.dart):</strong></p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">class</span> _HomePageState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HomePage</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// @override 表示这个 build 方法是重写父类 State 的方法</span>
  <span class="token metadata function">@override</span>
  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 返回您的组件树</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="dart-命名规范与-下划线"><a href="#dart-命名规范与-下划线" class="header-anchor">#</a> Dart 命名规范与 <code>_</code> (下划线)</h3> <ul><li><strong>类名</strong>: 使用 <code>UpperCamelCase</code> (大驼峰命名法)，例如 <code>HomePage</code>, <code>MyApp</code>。</li> <li><strong>文件名、变量名、函数名</strong>: 使用 <code>lowerCamelCase</code> (小驼峰命名法)。</li> <li><strong>_ (下划线) 表示私有</strong>: 在 Dart 中，如果一个变量、函数或类的名字以下划线 <code>_</code> 开头，那么它就是<strong>私有的</strong>。
<ul><li><strong>“私有”的范围</strong>: 不是指这个类内部，而是指<strong>当前文件 (.dart 文件) 内部</strong>。<code>_HomePageState</code> 这个类只能在 <code>home_page.dart</code> 这个文件里被访问，其他文件无法 <code>import</code> 和使用它。</li></ul></li></ul> <h3 id="final-的意思"><a href="#final-的意思" class="header-anchor">#</a> <code>final</code> 的意思</h3> <p><code>final</code> 是一个关键字，用来声明一个<strong>只能被赋值一次</strong>的变量。一旦被赋值，它的值（或引用）就不能再改变了。</p> <ul><li><strong>为什么组件的属性常用 final?</strong>
在 Flutter 中，组件被设计为“不可变的”（immutable）。如果需要更新界面，Flutter 的做法是创建一个新的组件实例来替换旧的，而不是去修改旧组件的属性。使用 <code>final</code> 可以强制保证这一点，让代码更安全。</li></ul> <p><strong>代码示例 (lib/pages/web_view_page.dart):</strong></p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">WebViewPage</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>
  <span class="token comment">// title 被声明为 final，意味着一旦 WebViewPage 被创建，</span>
  <span class="token comment">// 它的 title 就不能再被修改了。</span>
  <span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span> 

  <span class="token keyword">const</span> <span class="token class-name">WebViewPage</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> required <span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-布局与样式-styling"><a href="#_2-布局与样式-styling" class="header-anchor">#</a> 2. 布局与样式 (Styling)</h2> <h3 id="safearea-不被状态栏遮挡的安全区域"><a href="#safearea-不被状态栏遮挡的安全区域" class="header-anchor">#</a> <code>SafeArea</code>：不被状态栏遮挡的安全区域</h3> <p><code>SafeArea</code> 是一个非常有用的布局组件。它的作用是创建一个“安全”的矩形区域，这个区域会自动避开手机屏幕顶部的刘海、状态栏，以及底部的导航条。</p> <p><strong>代码示例 (home_page.dart):</strong></p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token class-name">Scaffold</span><span class="token punctuation">(</span>
  <span class="token comment">// 将 body 包裹在 SafeArea 中</span>
  body<span class="token punctuation">:</span> <span class="token class-name">SafeArea</span><span class="token punctuation">(</span>
    child<span class="token punctuation">:</span> <span class="token class-name">Column</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// Column 里的所有内容都不会被遮挡了</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="添加样式-styling"><a href="#添加样式-styling" class="header-anchor">#</a> 添加样式 (Styling)</h3> <p>在 Flutter 中，给组件添加样式通常是通过组件自身的属性来实现的。</p> <ul><li><strong>Text 组件</strong>: 使用 <code>style</code> 属性，它接收一个 <code>TextStyle</code> 对象。</li> <li><strong>Container 组件</strong>: 使用 <code>decoration</code> 属性，它接收一个 <code>BoxDecoration</code> 对象，可以设置边框、圆角、背景色等。</li></ul> <h3 id="尺寸单位全解析"><a href="#尺寸单位全解析" class="header-anchor">#</a> 尺寸单位全解析</h3> <h4 id="flutter-默认单位-逻辑像素-logical-pixels"><a href="#flutter-默认单位-逻辑像素-logical-pixels" class="header-anchor">#</a> Flutter 默认单位：逻辑像素 (Logical Pixels)</h4> <ul><li><strong>写法</strong>: 直接写数字，如 <code>width: 150</code>, <code>fontSize: 14</code>。</li> <li><strong>含义</strong>: 这是一个<strong>固定的、绝对的</strong>单位。在不同尺寸屏幕上视觉比例会失调。</li></ul> <h4 id="flutter-screenutil-适配单位"><a href="#flutter-screenutil-适配单位" class="header-anchor">#</a> <code>flutter_screenutil</code> 适配单位</h4> <p>这是用来实现UI适配的利器，它们都是<strong>相对单位</strong>。</p> <ul><li><strong>.w (width)</strong>: 基于<strong>屏幕宽度</strong>进行缩放。适合设置<strong>水平方向</strong>的尺寸。</li> <li><strong>.h (height)</strong>: 基于<strong>屏幕高度</strong>进行缩放。适合设置<strong>垂直方向</strong>的尺寸。</li> <li><strong>.r (radius/responsive)</strong>: 基于屏幕<strong>宽高的较小值</strong>进行缩放。非常适合设置<strong>圆角半径</strong>或<strong>正方形元素</strong>。</li> <li><strong>.sp (scalable pixel)</strong>: 专门用于<strong>字体大小</strong>的适配。它不仅会根据屏幕尺寸缩放，还会<strong>参考用户在系统设置里调整的字体大小</strong>。</li></ul> <h2 id="_3-路由与导航-navigation"><a href="#_3-路由与导航-navigation" class="header-anchor">#</a> 3. 路由与导航 (Navigation)</h2> <p>“路由”就是页面的代称。Flutter 使用一个 <code>Navigator</code> (导航器) 组件来管理一个页面栈（先进后出）。</p> <h3 id="基本路由跳转"><a href="#基本路由跳转" class="header-anchor">#</a> 基本路由跳转</h3> <ul><li><strong>跳转到新页面 (push)</strong>: <code>Navigator.push()</code> 会将一个新的页面（路由）压入栈顶。</li> <li><strong>返回上一页 (pop)</strong>: <code>Navigator.pop()</code> 会将栈顶的页面弹出。</li></ul> <h3 id="路由封装-进阶"><a href="#路由封装-进阶" class="header-anchor">#</a> 路由封装（进阶）</h3> <p>为了让项目结构更清晰，我们将路由跳转进行封装。</p> <ol><li><strong>lib/route/routes.dart</strong>: 这个文件负责<strong>定义</strong>和<strong>生成</strong>路由。
<ul><li><code>RoutePaths</code> 类：用 <code>static const</code> 字符串常量来定义所有页面的路由名称（如 <code>'/web_view_page'</code>），避免使用魔法字符串。</li> <li><code>Routes</code> 类：<code>generateRoute</code> 静态方法像一个“交通枢纽”，通过 <code>switch</code> 语句判断路由名称，并返回对应的页面。</li></ul></li> <li><strong>lib/route/RouteUtils.dart</strong>: 这个文件封装了具体的<strong>跳转动作</strong>。
<ul><li>创建 <code>push</code> 和 <code>pushForNamed</code> 等静态方法，将 <code>Navigator.of(context).push(...)</code> 封装起来。</li> <li><strong>好处</strong>：页面逻辑更简洁，调用 <code>RouteUtils.pushForNamed(context, ...)</code> 即可。</li></ul></li></ol> <h3 id="页面传值的两种核心方式"><a href="#页面传值的两种核心方式" class="header-anchor">#</a> 页面传值的两种核心方式</h3> <h4 id="方式一-构造函数传值-类型安全-推荐"><a href="#方式一-构造函数传值-类型安全-推荐" class="header-anchor">#</a> 方式一：构造函数传值（类型安全，推荐）</h4> <p>这是最直观、最安全的方式。</p> <ul><li><p><strong>传递</strong>: 创建新页面组件实例时，通过<strong>构造函数</strong>来完成。</p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 在 RouteUtils.push 中</span>
<span class="token class-name">Navigator</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token class-name">MaterialPageRoute</span><span class="token punctuation">(</span>builder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 直接把 &quot;webView&quot; 字符串传给 title 参数</span>
    <span class="token keyword">return</span> <span class="token class-name">WebViewPage</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;webView&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>接收</strong>: 在目标页面 (<code>WebViewPage</code>) 的 <code>StatefulWidget</code> 部分用 <code>final</code> 变量声明，并在 <code>State</code> 部分通过 <code>widget.变量名</code> 访问。</p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">WebViewPage</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span> <span class="token comment">// 1. 声明要接收的参数</span>
  <span class="token keyword">const</span> <span class="token class-name">WebViewPage</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> required <span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. 在构造函数中接收</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> _WebViewPageState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WebViewPage</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3. 通过 widget.title 使用参数</span>
    <span class="token keyword">return</span> <span class="token class-name">AppBar</span><span class="token punctuation">(</span>title<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>widget<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="方式二-arguments-传值-灵活-用于命名路由"><a href="#方式二-arguments-传值-灵活-用于命名路由" class="header-anchor">#</a> 方式二：<code>arguments</code> 传值（灵活，用于命名路由）</h4> <p>这种方式在与<strong>命名路由</strong> (<code>pushNamed</code>) 结合时非常灵活。</p> <ul><li><p><strong>传递</strong>: 在跳转时，通过 <code>arguments</code> 参数传递一个对象，通常是 <code>Map</code>。</p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 在 HomePage 中</span>
<span class="token class-name">RouteUtils</span><span class="token punctuation">.</span><span class="token function">pushForNamed</span><span class="token punctuation">(</span>
  context<span class="token punctuation">,</span> 
  <span class="token class-name">RoutePaths</span><span class="token punctuation">.</span>webViewPage<span class="token punctuation">,</span>
  arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string-literal"><span class="token string">&quot;title&quot;</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;webView&quot;</span></span><span class="token punctuation">}</span> <span class="token comment">// 将 Map 作为 arguments 传递</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>接收</strong>: 在目标页面的 <code>State</code> 内部，通过 <code>ModalRoute.of(context)!.settings.arguments</code> 来获取。这个过程必须在 <code>build</code> 方法或者 <code>initState</code> 中（通常配合 <code>addPostFrameCallback</code>）完成。</p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">class</span> _WebViewPageState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WebViewPage</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">;</span>

  <span class="token metadata function">@override</span>
  <span class="token keyword">void</span> <span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 确保在第一帧渲染后执行，此时 context 才可用</span>
    <span class="token class-name">WidgetsBinding</span><span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">addPostFrameCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">if</span> <span class="token punctuation">(</span>mounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">ModalRoute</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">.</span>settings<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">is</span> <span class="token class-name">Map</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 获取到值后，调用 setState 更新界面</span>
            name <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;title&quot;</span></span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string-literal"><span class="token string">&quot;默认标题&quot;</span></span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... build 方法中使用 name ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_4-状态管理-state-management"><a href="#_4-状态管理-state-management" class="header-anchor">#</a> 4. 状态管理 (State Management)</h2> <h3 id="level-1-本地状态-local-state-与-setstate"><a href="#level-1-本地状态-local-state-与-setstate" class="header-anchor">#</a> Level 1: 本地状态 (Local State) 与 <code>setState</code></h3> <p><code>StatefulWidget</code>（有状态组件）拥有一个 <code>State</code> 对象，可以保存和改变数据，并在数据改变时<strong>刷新界面</strong>。</p> <ul><li><strong>State 对象</strong>: 专门用来存储组件内部的可变数据。</li> <li><strong>setState((){ ... })</strong>: 这是刷新UI的<strong>唯一指令</strong>。
<ul><li><strong>原理</strong>: 调用 <code>setState</code> 会通知 Flutter 框架：“这个组件的数据变了，请重新调用它的 <code>build</code> 方法来重绘界面！”。</li> <li><strong>注意</strong>: 如果只修改变量而不调用 <code>setState</code>，数据虽然变了，但UI不会刷新。</li></ul></li></ul> <h3 id="level-2-应用-全局状态-app-state-与-provider"><a href="#level-2-应用-全局状态-app-state-与-provider" class="header-anchor">#</a> Level 2: 应用/全局状态 (App State) 与 <code>Provider</code></h3> <p>当多个页面需要共享同一个状态（如用户登录信息、主题色），或者需要将状态传递给很深的子组件时，使用 <code>setState</code> 会变得非常繁琐（即“状态提升”和“Prop-drilling”）。</p> <p><code>Provider</code> 是 Google 官方推荐的、简单轻量的状态管理方案。</p> <h4 id="核心概念-1-changenotifier-viewmodel-状态"><a href="#核心概念-1-changenotifier-viewmodel-状态" class="header-anchor">#</a> 核心概念 1: <code>ChangeNotifier</code> (ViewModel / 状态)</h4> <p><code>ChangeNotifier</code> 是一个 Flutter SDK 内置的类。我们创建的 <code>ViewModel</code> (VM) 通常会继承它。</p> <ul><li><strong>职责</strong>:
<ol><li><strong>持有数据</strong>: 比如 <code>List&lt;Banner&gt; bannerList</code>。</li> <li><strong>封装业务逻辑</strong>: 比如 <code>getBanner()</code> 方法。</li> <li><strong>通知更新</strong>: 当数据发生变化时（例如网络请求成功后），调用 <code>notifyListeners()</code> 方法，向所有监听者（Consumer）发送“数据变了”的信号。</li></ol></li></ul> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 示例：home_vm.dart</span>
<span class="token keyword">class</span> <span class="token class-name">HomeViewModel</span> <span class="token keyword">extends</span> <span class="token class-name">ChangeNotifier</span> <span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">&gt;</span></span> bannerList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 1. 持有数据</span>

  <span class="token comment">// 2. 封装业务逻辑</span>
  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">void</span><span class="token punctuation">&gt;</span></span> <span class="token function">fetchBanners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token class-name">ApiService</span><span class="token punctuation">.</span><span class="token function">getBanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假设 ApiService 负责请求</span>
    bannerList <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment">// 把 data 转换成 bannerList</span>
    
    <span class="token comment">// 3. 通知更新</span>
    <span class="token function">notifyListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="核心概念-2-changenotifierprovider-供应器"><a href="#核心概念-2-changenotifierprovider-供应器" class="header-anchor">#</a> 核心概念 2: <code>ChangeNotifierProvider</code> (供应器)</h4> <p><code>ChangeNotifierProvider</code> 是 <code>provider</code> 包提供的组件。</p> <ul><li><strong>职责</strong>: 向其子组件树<strong>提供</strong>一个 <code>ChangeNotifier</code> (即 VM) 的实例。</li> <li><strong>位置</strong>: 通常放在需要共享该状态的<strong>组件树的顶层</strong>，或者直接放在 <code>main.dart</code> 的 <code>runApp</code> 中，使其成为全局可访问。</li></ul> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 示例：main.dart</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">runApp</span><span class="token punctuation">(</span>
    <span class="token comment">// 1. 创建并提供了 HomeViewModel 的实例</span>
    <span class="token class-name">ChangeNotifierProvider</span><span class="token punctuation">(</span>
      create<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">HomeViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      child<span class="token punctuation">:</span> <span class="token keyword">const</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 2. MyApp 及其所有子组件都能访问到 HomeViewModel</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="核心概念-3-consumer-context-watch-监听器"><a href="#核心概念-3-consumer-context-watch-监听器" class="header-anchor">#</a> 核心概念 3: <code>Consumer</code> / <code>context.watch</code> (监听器)</h4> <p><code>Consumer</code> (或 <code>context.watch</code>) 负责从 <code>Provider</code> 获取 <code>ViewModel</code> 并<strong>监听</strong>其变化。</p> <ul><li><p><strong><code>Consumer</code> (组件方式)</strong>:</p> <ul><li>是一个 Widget，它会<strong>只重建</strong>其 <code>builder</code> 内部的组件，性能较好。</li> <li><code>builder</code> 提供三个参数：<code>context</code>、<code>viewModel</code> (我们需要的VM实例) 和 <code>child</code>。</li></ul></li> <li><p><strong><code>context.watch&lt;T&gt;()</code> (Hook 方式 - 更常用)</strong>:</p> <ul><li>在 <code>build</code> 方法内部调用。</li> <li>它会告诉 Flutter：“我依赖 <code>HomeViewModel</code>，当它调用 <code>notifyListeners()</code> 时，请<strong>重建整个</strong>调用了 <code>watch</code> 的 <code>build</code> 方法”。</li></ul></li></ul> <p><strong>代码实践 (解答：“为啥vm就能拿到bannerlist的值”)</strong></p> <p><strong>连接流程如下：</strong></p> <ol><li><code>HomeViewModel</code> (<code>VM</code>) 自己负责调用 API 并获取数据，然后将数据存入 <code>VM.bannerList</code> 变量中。</li> <li>获取数据后，<code>VM</code> 调用 <code>notifyListeners()</code>。</li> <li><code>ChangeNotifierProvider</code> 在 <code>main.dart</code> 中创建了这个 <code>VM</code> 实例。</li> <li><code>Consumer</code> (或 <code>context.watch</code>) 在 <code>HomePage</code> 中监听这个 <code>VM</code>。</li> <li>当 <code>Consumer</code> 收到 <code>notifyListeners()</code> 信号时，它会<strong>自动重建</strong>，并访问 <code>VM</code> 实例上<strong>已经更新好</strong>的 <code>bannerList</code> 数据，从而刷新UI。</li></ol> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 示例：home_page.dart</span>
<span class="token keyword">class</span> _HomePageState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HomePage</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token metadata function">@override</span>
  <span class="token keyword">void</span> <span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第一次加载时，获取 VM 实例并调用其方法</span>
    <span class="token comment">// 使用 context.read 不会监听变化，适合在 initState 或 onTap 中调用方法</span>
    context<span class="token punctuation">.</span>read<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HomeViewModel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fetchBanners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata function">@override</span>
  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 使用 watch 来监听 HomeViewModel 的变化</span>
    <span class="token keyword">final</span> vm <span class="token operator">=</span> context<span class="token punctuation">.</span>watch<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HomeViewModel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>
      body<span class="token punctuation">:</span> <span class="token class-name">ListView</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>
        <span class="token comment">// 2. vm 上的 bannerList 已经是最新的了</span>
        itemCount<span class="token punctuation">:</span> vm<span class="token punctuation">.</span>bannerList<span class="token punctuation">.</span>length<span class="token punctuation">,</span> 
        itemBuilder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 3. 使用数据渲染UI</span>
          <span class="token keyword">return</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>bannerList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong><code>context.read&lt;T&gt;()</code></strong>: 仅<strong>读取</strong>一次 <code>VM</code> 实例，<strong>不</strong>监听后续变化。适合在 <code>initState</code> 或 <code>onPressed</code> 中调用 <code>VM</code> 的方法。</li> <li><strong><code>context.watch&lt;T&gt;()()</code></strong>: <strong>读取</strong>并<strong>持续监听</strong> <code>VM</code> 的变化。适合在 <code>build</code> 方法中获取数据以渲染UI。</li></ul> <h2 id="_5-异步编程-async"><a href="#_5-异步编程-async" class="header-anchor">#</a> 5. 异步编程 (Async)</h2> <p>网络请求等耗时操作不能阻塞UI线程。Dart 使用 <code>Future</code> 来处理这类<strong>异步操作</strong>。</p> <h3 id="future、async-和-await"><a href="#future、async-和-await" class="header-anchor">#</a> <code>Future</code>、<code>async</code> 和 <code>await</code></h3> <ul><li><strong>Future</strong>: 一个“未来的凭证”或“快递单”。调用异步函数时，它不会立即给你结果，而是先给你一个 <code>Future</code>。</li> <li><strong>async</strong>: 用来标记一个函数是<strong>异步函数</strong>，这个函数会自动返回一个 <code>Future</code>。</li> <li><strong>await</strong>: 只能用在 <code>async</code> 函数内部，意思是“<strong>在这里暂停，一直等到这个 <code>Future</code> 有结果了，再继续往下执行</strong>”。</li></ul> <p><strong>代码实践 (home_vm.dart):</strong></p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token comment">// 'async' 标记这是一个异步函数</span>
<span class="token keyword">static</span> <span class="token class-name">Future</span> <span class="token function">getBanner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span> 
  <span class="token class-name">Dio</span> dio <span class="token operator">=</span> <span class="token class-name">Dio</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 'await' 在这里暂停，直到 dio.get() 这个 Future 完成</span>
  <span class="token class-name">Response</span> response <span class="token operator">=</span> <span class="token keyword">await</span> dio<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;/banner/json&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// Future 完成后，才会执行下面的 print 和 return</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;response===&gt;</span><span class="token interpolation"><span class="token punctuation">${</span><span class="token expression">response<span class="token punctuation">.</span>data</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_6-dart-进阶与包管理"><a href="#_6-dart-进阶与包管理" class="header-anchor">#</a> 6. Dart 进阶与包管理</h2> <h3 id="static-静态成员详解"><a href="#static-静态成员详解" class="header-anchor">#</a> <code>static</code> 静态成员详解</h3> <p><code>static</code> 关键字修饰的成员（变量或方法）<strong>属于类本身，而不是类的某个具体实例（对象）</strong>。</p> <ul><li><strong>非静态成员 (实例成员)</strong>: 像“房子的家具”，必须先创建实例（盖房子）才能访问。</li> <li><strong>静态成员 (static)</strong>: 像“建筑图纸上的规范”，不需要创建实例，直接通过<strong>类名</strong>访问。</li> <li><strong>用法</strong>: <code>RoutePaths.home</code>, <code>HomeViewModel.getBanner()</code>。</li></ul> <h3 id="var-类型推断-vs-dio-显式类型"><a href="#var-类型推断-vs-dio-显式类型" class="header-anchor">#</a> <code>var</code> (类型推断) vs. <code>Dio</code> (显式类型)</h3> <ul><li><strong>var</strong>: <code>var dio = Dio();</code>。Dart 编译器自动推断 <code>dio</code> 的类型是 <code>Dio</code>。</li> <li><strong>Dio</strong>: <code>Dio dio = Dio();</code>。明确地告诉编译器 <code>dio</code> 变量的类型<strong>必须是</strong> <code>Dio</code>。</li> <li><strong>推荐</strong>: 在团队协作中，显式类型 (<code>Dio dio</code>) 可读性更强、意图更明确。</li></ul> <h3 id="包管理-pub-dev"><a href="#包管理-pub-dev" class="header-anchor">#</a> 包管理 (<code>pub.dev</code>)</h3> <ul><li><strong>pub.dev</strong>: Dart 和 Flutter 官方的包（Package）仓库，类似组件的应用商店。</li> <li><strong>pubspec.yaml</strong>: 项目的“依赖清单”。</li> <li><strong>flutter pub get</strong>:
<ol><li>读取 <code>pubspec.yaml</code>。</li> <li>去 <code>pub.dev</code> 下载包的源代码（.dart 文件）。</li> <li>存储在本地缓存中。</li> <li>在 <code>.dart_tool/package_config.json</code> 中创建映射（地址簿），告诉 <code>import</code> 语句去哪里找文件。</li></ol></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/jiabinxu-blog/assets/js/app.f81cf313.js" defer></script><script src="/jiabinxu-blog/assets/js/3.bb87b8ff.js" defer></script><script src="/jiabinxu-blog/assets/js/2.180c3171.js" defer></script><script src="/jiabinxu-blog/assets/js/68.23192d8d.js" defer></script>
  </body>
</html>
